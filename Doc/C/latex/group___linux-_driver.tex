\hypertarget{group___linux-_driver}{\section{Linux-\/\+Driver}
\label{group___linux-_driver}\index{Linux-\/\+Driver@{Linux-\/\+Driver}}
}


Device-\/driver in kernel-\/mode per my\+G\+P\+I\+O.  


Diagramma di collaborazione per Linux-\/\+Driver\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=240pt]{group___linux-_driver}
\end{center}
\end{figure}
\subsection*{Strutture dati}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}
\begin{DoxyCompactList}\small\item\em Stuttura per l'astrazione di un device my\+G\+P\+I\+O in kernel-\/mode. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Definizioni}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group___linux-_driver_ga543e17293942b7cf7936a5e095ddc7ef}{my\+G\+P\+I\+O\+K\+\_\+\+M\+O\+D\+E\+\_\+\+O\+F\+F\+S\+E\+T}~0x00\+U
\begin{DoxyCompactList}\small\item\em Offset, rispetto all'indirizzo base, del registro \char`\"{}mode\char`\"{} per il device my\+G\+P\+I\+O. \end{DoxyCompactList}\item 
\#define \hyperlink{group___linux-_driver_gac165a5d828f3df41e78bb02d4ef38327}{my\+G\+P\+I\+O\+K\+\_\+\+W\+R\+I\+T\+E\+\_\+\+O\+F\+F\+S\+E\+T}~0x04\+U
\begin{DoxyCompactList}\small\item\em Offset, rispetto all'indirizzo base, del registro \char`\"{}write\char`\"{} per il device my\+G\+P\+I\+O. \end{DoxyCompactList}\item 
\#define \hyperlink{group___linux-_driver_gabdb25f3ecdfbf053f4ca207930a56599}{my\+G\+P\+I\+O\+K\+\_\+\+R\+E\+A\+D\+\_\+\+O\+F\+F\+S\+E\+T}~0x08\+U
\begin{DoxyCompactList}\small\item\em Offset, rispetto all'indirizzo base, del registro \char`\"{}read\char`\"{} per il device my\+G\+P\+I\+O. \end{DoxyCompactList}\item 
\#define \hyperlink{group___linux-_driver_ga0da2526ca3cd1a94ebcecf96778ea2e5}{my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T}~0x0\+C\+U
\begin{DoxyCompactList}\small\item\em Offset, rispetto all'indirizzo base, del registro \char`\"{}gies\char`\"{} per il device my\+G\+P\+I\+O. \end{DoxyCompactList}\item 
\#define \hyperlink{group___linux-_driver_ga2ed7646e6f910f5803477e51b7fe26e3}{my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T}~0x10\+U
\begin{DoxyCompactList}\small\item\em Offset, rispetto all'indirizzo base, del registro \char`\"{}pie\char`\"{} per il device my\+G\+P\+I\+O. \end{DoxyCompactList}\item 
\#define \hyperlink{group___linux-_driver_ga37ee502d1ba364dfde9261c4f7a537a6}{my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T}~0x14\+U
\begin{DoxyCompactList}\small\item\em Offset, rispetto all'indirizzo base, del registro \char`\"{}irq\char`\"{} per il device my\+G\+P\+I\+O. \end{DoxyCompactList}\item 
\#define \hyperlink{group___linux-_driver_gac72408c288009c213c0231973b3fe761}{my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T}~0x18\+U
\begin{DoxyCompactList}\small\item\em Offset, rispetto all'indirizzo base, del registro \char`\"{}iack\char`\"{} per il device my\+G\+P\+I\+O. \end{DoxyCompactList}\item 
\#define \hyperlink{group___linux-_driver_ga78d3a23bb3381a43eaba8bbf8b1cc750}{my\+G\+P\+I\+O\+K\+\_\+\+U\+S\+E\+D\+\_\+\+I\+N\+T}~0x\+F\+F\+F\+F\+F\+F\+F\+F\+U
\begin{DoxyCompactList}\small\item\em Maschea di abilitazione degli interrupt per i singoli pin. \end{DoxyCompactList}\item 
\#define \hyperlink{group___linux-_driver_ga25634d21648ca7fb7a2aca614bafaaeb}{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}~\char`\"{}my\+G\+P\+I\+O\+K\char`\"{}
\begin{DoxyCompactList}\small\item\em Nome identificativo del device-\/driver. D\+E\+V\+E corrispondere al valore del campo \char`\"{}compatible\char`\"{} nel device tree source. \end{DoxyCompactList}\item 
\#define \hyperlink{group___linux-_driver_gad32bf20eb64878cb958ca6ac9c96c21d}{M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+O\+F\+\_\+\+D\+E\+V\+I\+C\+E\+S}~1
\begin{DoxyCompactList}\small\item\em Numero di minor-\/number richiesti dal driver, corrispondera' al numero massimo di device gestibili. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Funzioni}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{group___linux-_driver_gae40973a06d72f7c41a9af07513a62307}{my\+G\+P\+I\+O\+K\+\_\+probe} (struct platform\+\_\+device $\ast$op)
\begin{DoxyCompactList}\small\item\em Viene chiamata quando il modulo viene inserito. \end{DoxyCompactList}\item 
static int \hyperlink{group___linux-_driver_ga59fddfaa36dea357f4bbdfceb0f47f8c}{my\+G\+P\+I\+O\+K\+\_\+remove} (struct platform\+\_\+device $\ast$op)
\item 
static int \hyperlink{group___linux-_driver_gad013759c18fbf6ea96005b9b3bfa5b4e}{my\+G\+P\+I\+O\+K\+\_\+open} (struct inode $\ast$inode, struct file $\ast$file\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Invocata all'apertura del file corrispondente al device. \end{DoxyCompactList}\item 
static int \hyperlink{group___linux-_driver_ga17ce7f574723246c790b70b06e3e7103}{my\+G\+P\+I\+O\+K\+\_\+release} (struct inode $\ast$inode, struct file $\ast$file\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Invocata alla chiusura del file corrispondente al device. \end{DoxyCompactList}\item 
static loff\+\_\+t \hyperlink{group___linux-_driver_ga66e7f726b72320a272b633ecbaecefff}{my\+G\+P\+I\+O\+K\+\_\+llseek} (struct file $\ast$file\+\_\+ptr, loff\+\_\+t off, int whence)
\begin{DoxyCompactList}\small\item\em Implementa le system-\/call lseek() e llseek(). \end{DoxyCompactList}\item 
static unsigned int \hyperlink{group___linux-_driver_gaba935e8a8215c2ebce9a7147fd4f5147}{my\+G\+P\+I\+O\+K\+\_\+poll} (struct file $\ast$file\+\_\+ptr, struct poll\+\_\+table\+\_\+struct $\ast$wait)
\begin{DoxyCompactList}\small\item\em Verifica che le operazioni di lettura/scrittura risultino non-\/bloccanti. \end{DoxyCompactList}\item 
static ssize\+\_\+t \hyperlink{group___linux-_driver_ga90ac339df9c02ae5f11a2a7727adc923}{my\+G\+P\+I\+O\+K\+\_\+read} (struct file $\ast$file\+\_\+ptr, char $\ast$buf, size\+\_\+t count, loff\+\_\+t $\ast$off)
\begin{DoxyCompactList}\small\item\em Legge dati dal device. \end{DoxyCompactList}\item 
static ssize\+\_\+t \hyperlink{group___linux-_driver_ga1eea0f6c86e8966ba9b701da57502aad}{my\+G\+P\+I\+O\+K\+\_\+write} (struct file $\ast$file\+\_\+ptr, const char $\ast$buf, size\+\_\+t size, loff\+\_\+t $\ast$off)
\begin{DoxyCompactList}\small\item\em Invia dati al device. \end{DoxyCompactList}\item 
static irqreturn\+\_\+t \hyperlink{group___linux-_driver_ga2fc230a12a97aa63e43b2dc4aec73511}{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler} (int irq, struct pt\+\_\+regs $\ast$regs)
\begin{DoxyCompactList}\small\item\em Interrupt-\/handler. \end{DoxyCompactList}\item 
static void \hyperlink{group___linux-_driver_gabd22e9dc7675ba815f1dd8840b39b2bf}{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable} (void $\ast$base\+Address)
\begin{DoxyCompactList}\small\item\em Abilita gli interrupt globali;. \end{DoxyCompactList}\item 
static void \hyperlink{group___linux-_driver_ga941f5d329dffbf6e45cecd70bbc72b63}{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable} (void $\ast$base\+Address)
\begin{DoxyCompactList}\small\item\em Disabilita gli interrupt globali;. \end{DoxyCompactList}\item 
static void \hyperlink{group___linux-_driver_ga15ddb23be51d3e2dbb00278af7e9ce31}{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable} (void $\ast$base\+Address, unsigned mask)
\begin{DoxyCompactList}\small\item\em Abilita gli interrupt per i singoli pin del device. \end{DoxyCompactList}\item 
static void \hyperlink{group___linux-_driver_ga57efe4a8be5e162cfd2e98f61d195087}{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable} (void $\ast$base\+Address, unsigned mask)
\begin{DoxyCompactList}\small\item\em Disabilita gli interrupt per i singoli pin del device. \end{DoxyCompactList}\item 
static unsigned \hyperlink{group___linux-_driver_ga6019e1ca45d7a093e1e7fc546b16f773}{my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt} (void $\ast$base\+Address)
\begin{DoxyCompactList}\small\item\em Consente di ottenere una maschera che indichi quali interrupt non siano stati ancora serviti;. \end{DoxyCompactList}\item 
static void \hyperlink{group___linux-_driver_ga105156c3db48f9dd40300218e7d8e144}{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack} (void $\ast$base\+Address, unsigned mask)
\begin{DoxyCompactList}\small\item\em Invia al device notifica di servizio di un interrupt;. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variabili}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$ \hyperlink{group___linux-_driver_gae370dfc26b06b6cc24a7bcc152f4969e}{my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr} = N\+U\+L\+L
\begin{DoxyCompactList}\small\item\em Puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, contenente tutti i dati necessari al device driver. \end{DoxyCompactList}\item 
static dev\+\_\+t \hyperlink{group___linux-_driver_ga434e034e4625b1949f0c626823870a39}{my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number}
\begin{DoxyCompactList}\small\item\em Major e minor number per il device driver. \end{DoxyCompactList}\item 
static struct class $\ast$ \hyperlink{group___linux-_driver_gaaf8d1bce7d6389684a037e94381c275c}{my\+G\+P\+I\+O\+K\+\_\+class} = N\+U\+L\+L
\item 
static struct device $\ast$ \hyperlink{group___linux-_driver_ga2d345c792760e3103059b6b6e0bfdaee}{my\+G\+P\+I\+O\+K\+\_\+device} = N\+U\+L\+L
\item 
static struct of\+\_\+device\+\_\+id \hyperlink{group___linux-_driver_ga91f28437e0a553effa546d16fa44f03a}{my\+G\+P\+I\+Ok\+\_\+match} \mbox{[}$\,$\mbox{]}
\begin{DoxyCompactList}\small\item\em Identifica il device all'interno del device tree. \end{DoxyCompactList}\item 
static struct platform\+\_\+driver \hyperlink{group___linux-_driver_ga8dba1541b58fa63f8208232ffce4fc47}{my\+G\+P\+I\+O\+K\+\_\+driver}
\begin{DoxyCompactList}\small\item\em Definisce quali funzioni probe() e remove() chiamare quando viene caricato un driver. \end{DoxyCompactList}\item 
static struct file\+\_\+operations \hyperlink{group___linux-_driver_ga9f31111fdb3b4a5944e18d45045e0f01}{my\+G\+P\+I\+O\+\_\+fops}
\begin{DoxyCompactList}\small\item\em mantiene puntatori a funzioni che definiscono il gli operatori che agiscono su un file/device. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Descrizione dettagliata}
Device-\/driver in kernel-\/mode per my\+G\+P\+I\+O. 

\begin{DoxyWarning}{Avvertimento}
Se nel device tree source non viene indicato \begin{center}compatible = \char`\"{}my\+G\+P\+I\+O\+K\char`\"{};\end{center}  tra i driver compatibili con il device, il driver my\+G\+P\+I\+O\+K non viene correttamente istanziato ed il programma userspace non funzionera'.
\end{DoxyWarning}
\subsubsection*{Descrizione generale del driver}

Il modulo driver implementa definisce il tipo \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} ed implementa le seguenti funzioni\+:
\begin{DoxyItemize}
\item \hyperlink{group___linux-_driver_gae40973a06d72f7c41a9af07513a62307}{my\+G\+P\+I\+O\+K\+\_\+probe()}\+: richiamata quando il modulo, o un device compatibile col modulo, viene inserito\+:
\item \hyperlink{group___linux-_driver_ga59fddfaa36dea357f4bbdfceb0f47f8c}{my\+G\+P\+I\+O\+K\+\_\+remove()}\+: richiamata quando il modulo, o un device compatibile, viene rimosso;
\item \hyperlink{group___linux-_driver_gad013759c18fbf6ea96005b9b3bfa5b4e}{my\+G\+P\+I\+O\+K\+\_\+open()}\+: implementa la system call open();
\item \hyperlink{group___linux-_driver_ga66e7f726b72320a272b633ecbaecefff}{my\+G\+P\+I\+O\+K\+\_\+llseek()}\+: implementa la system call seek();
\item \hyperlink{group___linux-_driver_ga1eea0f6c86e8966ba9b701da57502aad}{my\+G\+P\+I\+O\+K\+\_\+write()}\+: implementa la system call seek();
\item \hyperlink{group___linux-_driver_ga2fc230a12a97aa63e43b2dc4aec73511}{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler()}\+: implementa la I\+S\+R dedicata alla gestione delle interruzioni provenienti dal device;
\item \hyperlink{group___linux-_driver_gaba935e8a8215c2ebce9a7147fd4f5147}{my\+G\+P\+I\+O\+K\+\_\+poll()} \+: implementa il back-\/end di tre diverse system-\/calls (poll, epoll e select)
\item \hyperlink{group___linux-_driver_ga90ac339df9c02ae5f11a2a7727adc923}{my\+G\+P\+I\+O\+K\+\_\+read()} \+: implementa la system call read.
\end{DoxyItemize}

Nel seguito viene presentato un breve escursus su tutto cio' che c'e' da sapere per comprendere come funziona un device-\/driver e come poterne scrivere uno. Dopo aver letto il seguito, si consiglia, in ordine, di leggere, in ordine, la documentazione della struttura my\+G\+P\+I\+O\+K-\/t, poi quella delle funzioni
\begin{DoxyItemize}
\item \hyperlink{group___linux-_driver_gae40973a06d72f7c41a9af07513a62307}{my\+G\+P\+I\+O\+K\+\_\+probe()};
\item \hyperlink{group___linux-_driver_gad013759c18fbf6ea96005b9b3bfa5b4e}{my\+G\+P\+I\+O\+K\+\_\+open()};
\item \hyperlink{group___linux-_driver_ga66e7f726b72320a272b633ecbaecefff}{my\+G\+P\+I\+O\+K\+\_\+llseek()};
\item \hyperlink{group___linux-_driver_ga1eea0f6c86e8966ba9b701da57502aad}{my\+G\+P\+I\+O\+K\+\_\+write()};
\item \hyperlink{group___linux-_driver_ga90ac339df9c02ae5f11a2a7727adc923}{my\+G\+P\+I\+O\+K\+\_\+read()};
\item \hyperlink{group___linux-_driver_ga2fc230a12a97aa63e43b2dc4aec73511}{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler()};
\end{DoxyItemize}

\paragraph*{Platform-\/device}

I device driver, anche se sono moduli kernel, non si scrivono come normali moduli Kernel. I \char`\"{}platform-\/device\char`\"{} sono device che non possono annunciarsi al software (non possono dire \char`\"{}\+Hey,
sono qui'!\char`\"{} al sistema operativo), quindi sono intrinsecamente \char`\"{}non-\/scopribili\char`\"{}, nel senso che il sistema, al boot, deve sapere che ci sono, ma non e' in grado di scoprirli. A differenza dei device P\+C\+I o U\+S\+B, che non sono platform-\/device, un device I²\+C non viene enumerato a livello hardware, per cui e' necessario che il sistema operativo sappia, a tempo di \char`\"{}compilazione\char`\"{}, cioe' prima del boot -\/ quale device sia connesso al bus I²\+C. I non-\/discoverable devices stanno proliferando molto velocemente nel mondo embedded, per cui il Kernel Linux offre ancora la possibilita' di specificare quale hardware sia presente nel sistema. Bisogna distinguere in\+:
\begin{DoxyItemize}
\item Platform Driver
\item Platform Device
\end{DoxyItemize}

Per quanto riguarda la parte driver, il kernel Linux kernel definisce un insieme di operazioni standard che possono essere effettuate su un platform-\/device. Un riferimento pue' essere \href{http://lxr.free-electrons.com/source/include/linux/platform_device.h#L173}{\tt http\+://lxr.\+free-\/electrons.\+com/source/include/linux/platform\+\_\+device.\+h\#\+L173}. Le callbacks probe() e remove() costituiscono l'insieme minimo di operazioni che devono essere implementate. Tali funzioni devono avere gli stessi parametri delle due seguenti, ma possono avere nome qualsiasi.


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keywordtype}{int} sample\_drv\_probe(\textcolor{keyword}{struct} platform\_device *pdev) \{
        \textcolor{comment}{//Empty Probe function.}
\}

\textcolor{keyword}{static} \textcolor{keywordtype}{int} sample\_drv\_remove(\textcolor{keyword}{struct} platform\_device *pdev) \{
        \textcolor{comment}{//Empty remove function.}
\}
\end{DoxyCode}


La definizione di quali funzioni probe() e remove() chiamare quando viene caricato un driver viene effettuato attraverso la seguente struttura e la chiamata alla macro module\+\_\+platform\+\_\+driver(), la quale prende in input la struttura seguente ed implementa, al posto nostro, le funzioni module\+\_\+init() e module\+\_\+close() standard, chiamate quando il modulo viene caricato o rimosso dal kernel.


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keyword}{struct }platform\_driver sample\_pldriver = \{
    .probe  = sample\_drv\_probe,
    .remove = sample\_drv\_remove,
    .driver = \{
        .name  = \hyperlink{group___linux-_driver_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME},
    \},
\};

module\_platform\_driver(sample\_pldriver);
\end{DoxyCode}


Si noti D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E\+: deve essere identica alla stringa indicata, nel device-\/tree, al campo \char`\"{}compatible\char`\"{}.

Affinche' il driver possa essere caricato a caldo, e' necessario aggiungere alla struttura di cui sopra qualche informazione in piu'. Tutti i device-\/driver devono esporre un I\+D. A tempo di compilazione, il processo di build estrae queste informazioni dai driver per la preparazione di una tabella. Quando si \char`\"{}inserisce\char`\"{} il device, la tabella viene riferita dal kernel e, se viene trovata una entry corrispondente al driver per quel device, il driver viene caricato ed inizializzato.

Usando la struttura


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keyword}{struct }of\_device\_id device\_match[] = \{
        \{.compatible = \hyperlink{group___linux-_driver_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME}\},
        \{\},
\};

MODULE\_DEVICE\_TABLE(of, device\_match);
\end{DoxyCode}


si identifica un particolare device. La macro M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+L\+E() viene usata per inserire una nuova entry nella tabella accennata precedentemente. Alla struttura platform\+\_\+driver possono essere aggiunte anche queste informazioni, per cui essa si presentera' come riportato di seguito.


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keyword}{struct }platform\_driver sample\_pldriver = \{
    .probe  = sample\_drv\_probe,
    .remove = sample\_drv\_remove,
    .driver = \{
        .name  = \hyperlink{group___linux-_driver_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME},
        .owner = THIS\_MODULE,
        .of\_match\_table = device\_match,
    \},
\};
\end{DoxyCode}
 

\subsection{Documentazione delle definizioni}
\hypertarget{group___linux-_driver_ga25634d21648ca7fb7a2aca614bafaaeb}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E@{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}}
\index{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E@{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E~\char`\"{}my\+G\+P\+I\+O\+K\char`\"{}}}\label{group___linux-_driver_ga25634d21648ca7fb7a2aca614bafaaeb}


Nome identificativo del device-\/driver. D\+E\+V\+E corrispondere al valore del campo \char`\"{}compatible\char`\"{} nel device tree source. 

\hypertarget{group___linux-_driver_gad32bf20eb64878cb958ca6ac9c96c21d}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+O\+F\+\_\+\+D\+E\+V\+I\+C\+E\+S@{M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+O\+F\+\_\+\+D\+E\+V\+I\+C\+E\+S}}
\index{M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+O\+F\+\_\+\+D\+E\+V\+I\+C\+E\+S@{M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+O\+F\+\_\+\+D\+E\+V\+I\+C\+E\+S}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+O\+F\+\_\+\+D\+E\+V\+I\+C\+E\+S}]{\setlength{\rightskip}{0pt plus 5cm}\#define M\+A\+X\+\_\+\+N\+U\+M\+\_\+\+O\+F\+\_\+\+D\+E\+V\+I\+C\+E\+S~1}}\label{group___linux-_driver_gad32bf20eb64878cb958ca6ac9c96c21d}


Numero di minor-\/number richiesti dal driver, corrispondera' al numero massimo di device gestibili. 

\hypertarget{group___linux-_driver_ga0da2526ca3cd1a94ebcecf96778ea2e5}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T~0x0\+C\+U}}\label{group___linux-_driver_ga0da2526ca3cd1a94ebcecf96778ea2e5}


Offset, rispetto all'indirizzo base, del registro \char`\"{}gies\char`\"{} per il device my\+G\+P\+I\+O. 

\hypertarget{group___linux-_driver_gac72408c288009c213c0231973b3fe761}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T~0x18\+U}}\label{group___linux-_driver_gac72408c288009c213c0231973b3fe761}


Offset, rispetto all'indirizzo base, del registro \char`\"{}iack\char`\"{} per il device my\+G\+P\+I\+O. 

\hypertarget{group___linux-_driver_ga37ee502d1ba364dfde9261c4f7a537a6}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T~0x14\+U}}\label{group___linux-_driver_ga37ee502d1ba364dfde9261c4f7a537a6}


Offset, rispetto all'indirizzo base, del registro \char`\"{}irq\char`\"{} per il device my\+G\+P\+I\+O. 

\hypertarget{group___linux-_driver_ga543e17293942b7cf7936a5e095ddc7ef}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+M\+O\+D\+E\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+M\+O\+D\+E\+\_\+\+O\+F\+F\+S\+E\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+M\+O\+D\+E\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+M\+O\+D\+E\+\_\+\+O\+F\+F\+S\+E\+T}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+M\+O\+D\+E\+\_\+\+O\+F\+F\+S\+E\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+M\+O\+D\+E\+\_\+\+O\+F\+F\+S\+E\+T~0x00\+U}}\label{group___linux-_driver_ga543e17293942b7cf7936a5e095ddc7ef}


Offset, rispetto all'indirizzo base, del registro \char`\"{}mode\char`\"{} per il device my\+G\+P\+I\+O. 

\hypertarget{group___linux-_driver_ga2ed7646e6f910f5803477e51b7fe26e3}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T~0x10\+U}}\label{group___linux-_driver_ga2ed7646e6f910f5803477e51b7fe26e3}


Offset, rispetto all'indirizzo base, del registro \char`\"{}pie\char`\"{} per il device my\+G\+P\+I\+O. 

\hypertarget{group___linux-_driver_gabdb25f3ecdfbf053f4ca207930a56599}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+R\+E\+A\+D\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+R\+E\+A\+D\+\_\+\+O\+F\+F\+S\+E\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+R\+E\+A\+D\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+R\+E\+A\+D\+\_\+\+O\+F\+F\+S\+E\+T}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+R\+E\+A\+D\+\_\+\+O\+F\+F\+S\+E\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+R\+E\+A\+D\+\_\+\+O\+F\+F\+S\+E\+T~0x08\+U}}\label{group___linux-_driver_gabdb25f3ecdfbf053f4ca207930a56599}


Offset, rispetto all'indirizzo base, del registro \char`\"{}read\char`\"{} per il device my\+G\+P\+I\+O. 

\hypertarget{group___linux-_driver_ga78d3a23bb3381a43eaba8bbf8b1cc750}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+U\+S\+E\+D\+\_\+\+I\+N\+T@{my\+G\+P\+I\+O\+K\+\_\+\+U\+S\+E\+D\+\_\+\+I\+N\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+U\+S\+E\+D\+\_\+\+I\+N\+T@{my\+G\+P\+I\+O\+K\+\_\+\+U\+S\+E\+D\+\_\+\+I\+N\+T}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+U\+S\+E\+D\+\_\+\+I\+N\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+U\+S\+E\+D\+\_\+\+I\+N\+T~0x\+F\+F\+F\+F\+F\+F\+F\+F\+U}}\label{group___linux-_driver_ga78d3a23bb3381a43eaba8bbf8b1cc750}


Maschea di abilitazione degli interrupt per i singoli pin. 

\hypertarget{group___linux-_driver_gac165a5d828f3df41e78bb02d4ef38327}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+W\+R\+I\+T\+E\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+W\+R\+I\+T\+E\+\_\+\+O\+F\+F\+S\+E\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+W\+R\+I\+T\+E\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+W\+R\+I\+T\+E\+\_\+\+O\+F\+F\+S\+E\+T}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+W\+R\+I\+T\+E\+\_\+\+O\+F\+F\+S\+E\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+W\+R\+I\+T\+E\+\_\+\+O\+F\+F\+S\+E\+T~0x04\+U}}\label{group___linux-_driver_gac165a5d828f3df41e78bb02d4ef38327}


Offset, rispetto all'indirizzo base, del registro \char`\"{}write\char`\"{} per il device my\+G\+P\+I\+O. 



\subsection{Documentazione delle funzioni}
\hypertarget{group___linux-_driver_ga941f5d329dffbf6e45cecd70bbc72b63}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable@{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable@{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable}]{\setlength{\rightskip}{0pt plus 5cm}static void my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{base\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga941f5d329dffbf6e45cecd70bbc72b63}


Disabilita gli interrupt globali;. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em base\+Address} & indirizzo virtuale del device \\
\hline
\end{DoxyParams}
\hypertarget{group___linux-_driver_gabd22e9dc7675ba815f1dd8840b39b2bf}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable@{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable@{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable}]{\setlength{\rightskip}{0pt plus 5cm}static void my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{base\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_gabd22e9dc7675ba815f1dd8840b39b2bf}


Abilita gli interrupt globali;. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em base\+Address} & indirizzo virtuale del device \\
\hline
\end{DoxyParams}
\hypertarget{group___linux-_driver_ga2fc230a12a97aa63e43b2dc4aec73511}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler@{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler}}
\index{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler@{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler}]{\setlength{\rightskip}{0pt plus 5cm}static irqreturn\+\_\+t my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler (
\begin{DoxyParamCaption}
\item[{int}]{irq, }
\item[{struct pt\+\_\+regs $\ast$}]{regs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga2fc230a12a97aa63e43b2dc4aec73511}


Interrupt-\/handler. 


\begin{DoxyParams}{Parametri}
{\em irq} & \\
\hline
{\em regs} & \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Valori di ritorno}
{\em I\+R\+Q\+\_\+\+H\+A\+N\+D\+L\+E\+D} & dopo aver servito l'interruzione\\
\hline
\end{DoxyRetVals}
Gestisce il manifestarsi di un evento interrompente proveniente dalla periferica. Viene registrata dalla funzione \hyperlink{group___linux-_driver_gae40973a06d72f7c41a9af07513a62307}{my\+G\+P\+I\+O\+K\+\_\+probe()} affinche' venga richiamata al manifestarsi di un interrupt sulla linea cui e' connesso il device \subparagraph*{Disabilitazione delle interruzioni della periferica}

Prima di servire l'interruzione, gli interrupt della periferica vengono disabilitati. Se si tratta di un G\+P\+I\+O Xilinx, vengono disabilitati sia gli interrupt globali che quelli generati dal secondo canale. Se, invece, si tratta di un device G\+P\+I\+O custom my\+G\+P\+I\+O, vengono disabilitati solo gli interrupt globali.

\subparagraph*{Setting del valore del flag \char`\"{}interrupt occurred\char`\"{}}

Dopo aver disabilitato gli interrupt della periferica, occorre settare in modo appropriato il flag \char`\"{}interrupt occurred\char`\"{}, in modo che i processi in attesa possano essere risvegliati in modo sicuro. Per prevenire race condition, tale operazione viene effettuata mutua esclusione. I semafori sono uno strumento potentissimo per per l'implementazione di sezioni critiche, ma non possono essere usati in codice non interrompibile. Gli spilock sono come i semafori, ma possono essere usati anche in codice non interrompibile, come puo' esserlo un modulo kernel. Sostanzialmente se uno spinlock e' gia' stato acquisito da qualcun altro, si entra in un hot-\/loop dal quale si esce solo quando chi possiede lo spinlock lo rilascia. Trattandosi di moduli kernel, e' di vitale importanza che la sezione critica sia quanto piu' piccola possibile. Ovviamente l'implementazione e' \char`\"{}un po'\char`\"{} piu' complessa di come e' stata descritta, ma il concetto e' questo. Gli spinlock sono definiti in $<$linux/spinlock.\+h$>$. Esistono diversi modi per acquisire uno spinlock. Nel seguito viene usata la funzione 
\begin{DoxyCode}
1 void spin\_lock\_irqsave(spinlock\_t *lock, unsigned long flags);
\end{DoxyCode}
 la quale disabilita gli interrupt sul processore locale prima di acquisire lo spinlock, per poi ripristinarlo quando lo spinlock viene rilasciato, usando 
\begin{DoxyCode}
1 void spin\_unlock\_irqrestore(spinlock\_t *lock, unsigned long flags);
\end{DoxyCode}


\subparagraph*{Incremento del numero totale di interrupt}

Dopo aver settato il flag, viene incrementato il valore degli interrupt totali. Anche questa operazione viene effettuata in mutua esclusione.

\subparagraph*{Wakeup dei processi sleeping}

La I\+S\+R deve chiamare esplicitamente wakeup() per risvegliare i processi messi in sleeping in attesa che un particolare evento si manifestasse. La funzione 
\begin{DoxyCode}
1 void wake\_up\_interruptible(wait\_queue\_head\_t *queue);
\end{DoxyCode}
 risveglia tutti i processi posti in una determinata coda (risvegliando solo quelli che, in precedenza, hanno effettuato una chiamata a wait\+\_\+event\+\_\+interruptible()). Se due processi vengono risvegliati contemporaneamente potrebbero originarsi race-\/condition.\hypertarget{group___linux-_driver_ga66e7f726b72320a272b633ecbaecefff}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+llseek@{my\+G\+P\+I\+O\+K\+\_\+llseek}}
\index{my\+G\+P\+I\+O\+K\+\_\+llseek@{my\+G\+P\+I\+O\+K\+\_\+llseek}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+llseek}]{\setlength{\rightskip}{0pt plus 5cm}static loff\+\_\+t my\+G\+P\+I\+O\+K\+\_\+llseek (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file\+\_\+ptr, }
\item[{loff\+\_\+t}]{off, }
\item[{int}]{whence}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga66e7f726b72320a272b633ecbaecefff}


Implementa le system-\/call lseek() e llseek(). 

\begin{DoxyWarning}{Avvertimento}
L'implementazione di read() e write() non sposta la testina di lettura/scrittura!
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in,out}  & {\em file\+\_\+ptr} & \\
\hline
\mbox{\tt in}  & {\em off} & \\
\hline
\mbox{\tt in}  & {\em whence} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
Nuova posizione della \char`\"{}testina\char`\"{} di lettura/scrittura 
\end{DoxyReturn}
\hypertarget{group___linux-_driver_gad013759c18fbf6ea96005b9b3bfa5b4e}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+open@{my\+G\+P\+I\+O\+K\+\_\+open}}
\index{my\+G\+P\+I\+O\+K\+\_\+open@{my\+G\+P\+I\+O\+K\+\_\+open}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+open}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+open (
\begin{DoxyParamCaption}
\item[{struct inode $\ast$}]{inode, }
\item[{struct file $\ast$}]{file\+\_\+ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_gad013759c18fbf6ea96005b9b3bfa5b4e}


Invocata all'apertura del file corrispondente al device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em inode} & \\
\hline
\mbox{\tt in,out}  & {\em file} & \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Valori di ritorno}
{\em 0} & se non si verifica nessun errore\\
\hline
\end{DoxyRetVals}
\subparagraph*{Il metodo open()}

Il metodo open di un device driver viene fornito per effettuare ogni inizializzazione necessaria ad operazioni successive. Effettua le seguenti operazioni\+:
\begin{DoxyItemize}
\item verifica che non si siano manifestati errori;
\item inizializza il device
\item aggiorna il puntatore f\+\_\+op, se necessario;
\item alloca e popola ogni struttura dati necessaria, ponendola successivamente nel campo private\+\_\+data della struttura dati file.
\end{DoxyItemize}

In primo luogo e' necessario identificare il device che sta per essere aperto. Tenendo presente che il prototipo di qualunque metodo open e'


\begin{DoxyCode}
1 int (*open)(struct inode *inode, struct file *filp);
\end{DoxyCode}
 \paragraph*{Identificare il particolare device associato al file}

Il parametro inode contiene tutte le informazioni necessarie all'interno del campo i\+\_\+cdev, il quale contiene la struttura cdev inizializzata precedentemente dalla funzione di probe(). Il problema e' che non abbiamo bisogno della sola struttura cdev, ma della struttura che la contiene, in questo caso della struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}. Fortunatamente i programmatori del kernel hanno reso la vita semplice agli altri, predisponendo la macro container\+\_\+if() definita in $<$linux/kernel.\+h$>$. 
\begin{DoxyCode}
1 container\_of(pointer, container\_type, container\_field);
\end{DoxyCode}
 La macro prende in ingresso un puntatore ad un campo di tipo container\+\_\+field, di una struttura container\+\_\+type, restituendo il puntatore alla struttura che la contiene.\hypertarget{group___linux-_driver_ga6019e1ca45d7a093e1e7fc546b16f773}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt@{my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt@{my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt}]{\setlength{\rightskip}{0pt plus 5cm}static unsigned my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{base\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga6019e1ca45d7a093e1e7fc546b16f773}


Consente di ottenere una maschera che indichi quali interrupt non siano stati ancora serviti;. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em base\+Address} & indirizzo virtuale del device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
maschera che riporta i pin per i quali gli interrupt non sono stati ancora serviti; 
\end{DoxyReturn}
\hypertarget{group___linux-_driver_ga105156c3db48f9dd40300218e7d8e144}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack}]{\setlength{\rightskip}{0pt plus 5cm}static void my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{base\+Address, }
\item[{unsigned}]{mask}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga105156c3db48f9dd40300218e7d8e144}


Invia al device notifica di servizio di un interrupt;. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em base\+Address} & indirizzo virtuale del device \\
\hline
\mbox{\tt in}  & {\em mask} & mask maschera di selezione degli interrupt da notificare; quelli non selezionati non vengono notificati; \\
\hline
\end{DoxyParams}
\hypertarget{group___linux-_driver_ga57efe4a8be5e162cfd2e98f61d195087}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable}]{\setlength{\rightskip}{0pt plus 5cm}static void my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{base\+Address, }
\item[{unsigned}]{mask}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga57efe4a8be5e162cfd2e98f61d195087}


Disabilita gli interrupt per i singoli pin del device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em base\+Address} & indirizzo virtuale del device \\
\hline
\mbox{\tt in}  & {\em mask} & maschera di selezione degli interrupt da disabilitare; quelli non selezionati non vengono disabilitati; \\
\hline
\end{DoxyParams}
\hypertarget{group___linux-_driver_ga15ddb23be51d3e2dbb00278af7e9ce31}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable}]{\setlength{\rightskip}{0pt plus 5cm}static void my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{base\+Address, }
\item[{unsigned}]{mask}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga15ddb23be51d3e2dbb00278af7e9ce31}


Abilita gli interrupt per i singoli pin del device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em base\+Address} & indirizzo virtuale del device \\
\hline
\mbox{\tt in}  & {\em mask} & maschera di selezione degli interrupt da abilitare; quelli non selezionati non vengono abilitati; \\
\hline
\end{DoxyParams}
\hypertarget{group___linux-_driver_gaba935e8a8215c2ebce9a7147fd4f5147}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+poll@{my\+G\+P\+I\+O\+K\+\_\+poll}}
\index{my\+G\+P\+I\+O\+K\+\_\+poll@{my\+G\+P\+I\+O\+K\+\_\+poll}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+poll}]{\setlength{\rightskip}{0pt plus 5cm}static unsigned int my\+G\+P\+I\+O\+K\+\_\+poll (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file\+\_\+ptr, }
\item[{struct poll\+\_\+table\+\_\+struct $\ast$}]{wait}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_gaba935e8a8215c2ebce9a7147fd4f5147}


Verifica che le operazioni di lettura/scrittura risultino non-\/bloccanti. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in,out}  & {\em file} & \\
\hline
\mbox{\tt in,out}  & {\em wait} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
restituisce una maschera di bit che indica se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili.
\end{DoxyReturn}
Questo metodo e' il back-\/end di tre diverse system-\/calls\+: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno. \hypertarget{group___linux-_driver_gae40973a06d72f7c41a9af07513a62307}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+probe@{my\+G\+P\+I\+O\+K\+\_\+probe}}
\index{my\+G\+P\+I\+O\+K\+\_\+probe@{my\+G\+P\+I\+O\+K\+\_\+probe}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+probe}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+probe (
\begin{DoxyParamCaption}
\item[{struct platform\+\_\+device $\ast$}]{op}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_gae40973a06d72f7c41a9af07513a62307}


Viene chiamata quando il modulo viene inserito. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in,out}  & {\em op} & \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Valori di ritorno}
{\em 0} & nel caso in cui non si sia verificato nessun errore; \\
\hline
{\em -\/\+E\+N\+O\+M\+E\+M} & nel caso in cui non sia possibile allocare memoria; \\
\hline
{\em $<$0} & per altri errori\\
\hline
\end{DoxyRetVals}
\paragraph*{Inizializzazione del driver}

Il device G\+P\+I\+O viene gestito come un character-\/device, ossia un device su cui e' possibile leggere e/o scrivere byte. Il kernel usa, internamente, una struttura cdev per rappresentare i device a caratteri. Prima che il kernel invochi le funzioni definite dal driver per il device, bisogna allocare e registrare uno, o piu', oggetti cdev. Per farlo e' necessario includere $<$linux/cdev.\+h$>$, che definisce tale struttura e le relative funzioni. \subparagraph*{Major-\/number e Minor-\/number}

Ai device drivers sono associati un major-\/number ed un minor-\/number. Il major-\/number viene usato dal kernel per identificare il driver corretto corrispondente ad uno specifico device, quando si effettuano operazioni su di esso. Il ruolo del minor number dipende dal device e viene gestito internamente dal driver. Il driver scritto per G\+P\+I\+O non usera' minor-\/number. La registrazione di un device driver puo' essere effettuata chiamando {\bfseries alloc\+\_\+chrdev\+\_\+region()}, la quale alloca un char-\/device numbers. Il major number viene scelto dinamicamente e restituito dalla funzione attraverso il parametro dev. La funzione restituisce un valore negativo nel caso in cui si verifichino errori, 0 altrimenti. 
\begin{DoxyCode}
1 int alloc\_chrdev\_region (dev\_t * dev, unsigned baseminor, unsigned count, const char *name);
\end{DoxyCode}

\begin{DoxyItemize}
\item dev\+: major e minor number
\item baseminor\+: primo dei minor number richiesti
\item count\+: numero di minornumber richiesti
\item name\+: nome del device driver
\end{DoxyItemize}

\subparagraph*{Device Class}

Ai device-\/drivers viene associata una classe ed un device-\/name. Per creare ed associare una classe ad un device driver si puo' usare la seguente. 
\begin{DoxyCode}
1 struct class * class\_create(struct module * owner, const char * name);
\end{DoxyCode}

\begin{DoxyItemize}
\item owner\+: puntatore al modulo che \char`\"{}possiede\char`\"{} la classe, T\+H\+I\+S\+\_\+\+M\+O\+D\+U\+L\+E
\item name\+: puntatore alla stringa identificativa (il nome) del device driver, D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E
\end{DoxyItemize}

\subparagraph*{Operatori}

Essendo un device \char`\"{}visto\char`\"{} come un file, ogni device driver deve implementare tutte le system-\/call previste per l'interfacciamento con un file. La corrispondenza tra la system-\/call e la funzione fornita dal driver viene stabilita attraverso la struttura file\+\_\+operations. La struttura dati file\+\_\+operations, definita in $<$linux/fs.\+h$>$ mantiene puntatori a funzioni definite dal driver che consentono di definire il comportamento degli operatori che agiscono su un file.


\begin{DoxyCode}
1 static struct file\_operations myGPIO\_fops = \{
2     .owner      = THIS\_MODULE,
3     .llseek     = driver\_seek,
4     .read       = driver\_read,
5     .write      = driver\_write,
6     .poll       = driver\_poll,
7     .open       = driver\_open,
8     .release    = driver\_release
9 \};
\end{DoxyCode}


Ogni campo della struttura deve puntare ad una funzione del driver che implementa uno specifico \char`\"{}operatore\char`\"{} su file, oppure impostata a N\+U\+L\+L se l'operatore non e' supportato. L'esatto comportamento del kernel, quando uno dei puntatori e' N\+U\+L\+L, varia da funzione a funzione. La lista seguente introduce tutti gli operatori che un'applicazione puo' invocare su un device. La lista e' stata mantenuta snella, includendo solo i campi strettamente necessari.


\begin{DoxyItemize}
\item {\itshape struct module $\ast$owner} \+:~\newline
 il primo campo della struttura non e' un operatore, ma un puntatore al modulo che \char`\"{}possiede\char`\"{} la struttura. Il campo ha lo scopo di evitare che il modulo venga rimosso dal kernel quando uno degli operatori e' in uso. Viene inizializzato usando la macro T\+H\+I\+S\+\_\+\+M\+O\+D\+U\+L\+E, definita in $<$linux/module.\+h$>$.
\item {\itshape loff\+\_\+t ($\ast$llseek) (struct file $\ast$, loff\+\_\+t, int)} \+: il campo llseek e' usato per cambiare la posizione della \char`\"{}testina\char`\"{} di lettura/ scrittura in un file. La funzione restituisce la nuova posizione della testina. loff\+\_\+t e' un intero a 64 bit (anche su architetture a 32 bit). Eventuali errori vengono segnalati con un valore di ritorno negativo. Se questo campo e' posto a N\+U\+L\+L, eventuali chiamate a seek modifigheranno la posizione della testina in un modo impredicibile.
\item {\itshape ssize\+\_\+t ($\ast$read) (struct file $\ast$, char \+\_\+ \+\_\+user $\ast$, size\+\_\+t, loff\+\_\+t $\ast$)} \+:~\newline
 usata per leggere dati dal device. Se lasciato a N\+U\+L\+L, ogni chiamata a read fallira' e non sara' possibile leggere dal device. La funzione restituisce il numero di byte letti con successo ma, nel caso si verifichi un errore, restituisce un numero intero negativo.
\item {\itshape ssize\+\_\+t ($\ast$write) (struct file $\ast$, const char \+\_\+ \+\_\+user $\ast$, size\+\_\+t, loff\+\_\+t $\ast$)} \+:~\newline
 invia dati al device. Se N\+U\+L\+L ogni chiamata alla system-\/call write causera' un errore. Il valore di ritorno, se non negativo, rappresenta il numero di byte correttamente scritti.
\item {\itshape unsigned int ($\ast$poll) (struct file $\ast$, struct poll\+\_\+table\+\_\+struct $\ast$)} \+:~\newline
 questo metodo e' il back-\/end di tre diverse system-\/calls\+: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno. La funzione dovrebbe restituire una maschera che indichi se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili. Se viene lasciata N\+U\+L\+L si intende che le operazioni di lettura/scrittura sul device siano sempre non-\/bloccanti.
\item {\itshape int ($\ast$open) (struct inode $\ast$, struct file $\ast$)} \+:~\newline
 Anche se, di solito, e' la prima operazione che si effettua su un file, non e' strettamente necessaria la sua implementazione. Se lasciata N\+U\+L\+L, l'apertura del device andra' comunque a buon fine, ma al driver non verra' inviata alcuna notifica.
\item {\itshape int ($\ast$release) (struct inode $\ast$, struct file $\ast$)} \+:~\newline
 questo operatore viene invocato quando il file viene rilasciato. Come open, puo' essere lasciato N\+U\+L\+L.
\end{DoxyItemize}

L'inizializzazione di un device a caratteri passa anche attraverso la definizione di questo tipo di operatori. Essi possono essere impostati attraverso l'uso della funzione 
\begin{DoxyCode}
1 void cdev\_init (struct cdev *cdev, const struct file\_operations *fops);
\end{DoxyCode}
 la quale prende, come parametri
\begin{DoxyItemize}
\item cdev\+: puntatore a struttura cdev da inizializzare;
\item fops\+: puntatore a struttura file\+\_\+operation con cui inizializzare il device.
\end{DoxyItemize}

\subparagraph*{Aggiunta del device}

Il driver, a questo punto, e' pronto per essere aggiunto. E' possibile aggiungere il driver usando 
\begin{DoxyCode}
1 int cdev\_add (struct cdev *p, dev\_t dev, unsigned count);
\end{DoxyCode}
 La quale accetta come parametri
\begin{DoxyItemize}
\item p\+: puntatore a struttura cdev structure per il device
\item dev\+: device number (precedentemente inizializzato usando la funzione {\itshape alloc\+\_\+chrdev\+\_\+region()})
\item count\+: numero di minor-\/numbers richiesti per il device
\end{DoxyItemize}

La funzione restituisce un numero negativo in caso di errore.

\subparagraph*{Creazione del device}

Il passo successivo e' la registrazione del device e la sua aggiunta al filesystem. Tale operazione puo' essere effettuata chiamando 
\begin{DoxyCode}
1 struct device * device\_create( struct class *class, struct device *parent, dev\_t devt, const char *fmt,
       ...)
\end{DoxyCode}

\begin{DoxyItemize}
\item class\+: puntatore alla struttura class alla quale il device deve essere registrato
\item parent\+: puntatore ad eventuale device parent
\item devt\+: tmajor number
\item fmt\+: nome del device.
\end{DoxyItemize}

La funzione pu' essere usata solo sulla classe dei device a caratteri. Crea un device all'interno del filesystem, associandogli il major number preventivamente inizializzato. La funzione restituisce il puntatore alla struttura device creata all'interno del filesystem. Si noti che il puntatre alla struttura classes D\+E\+V\+E essere stato precedentemente creato attraverso una chiamata alla funzione {\itshape class\+\_\+create()}.

\subparagraph*{Accedere al segmento di memoria a cui la periferica e' mappata}

Un driver, tipicamente, prende possesso del segmento di memoria cui e' mappato il device con la funzione di probe. Il problema e' che il device e' mappato ad un indirizzo di memoria fisico ed il Kernel, così come qualsiasi altro programma, lavora su indirizzi di memoria virtuali. La funzione


\begin{DoxyCode}
1 int of\_address\_to\_resource(struct device\_node *node, int index, struct resource *r);
\end{DoxyCode}


popola una struttura resource con l'indirizzo di memoria cui e' mapato il device usando le informazioni contenute all'interno del device tree. Ad esempio, se il device tree contiene 
\begin{DoxyCode}
1 reg = <0x41200000 0x10000>;
\end{DoxyCode}
 signidifa che l'indirizzo fisico associato al device e' l'indirizzo 0x41200000, che al device sono riservati 0x10000 bytes. of\+\_\+address\+\_\+to\+\_\+resource() settera' res.\+start = 0x41200000 e res.\+end = 0x4120ffff.

\subparagraph*{Allocazione della memoria del device}

Le regioni di memoria per di I/\+O vanno allocate prima di poter essere usate. 
\begin{DoxyCode}
1 struct resource *request\_mem\_region(unsigned long start, unsigned long len, char *name);
\end{DoxyCode}
 Questa funzione alloca una regione di memoria di len byte a partire da start restituendone l'indirizzo, mentre nel caso in cui si verifichi un errore viene restituito N\+U\+L\+L. La funzione viene chiamata per ottenere l'accesso esclusivo della regione di memoria, per evitare che driver diversi tentino di accedere allo stesso spazio di memoria.

\subparagraph*{Remapping}

L'allocazione dello spazio di memoria non e' l'unico step da eseguire prima che tale memoria possa essere usata. E' necessario fare in modo che sia resa accessibile al kernel attraverso un mapping, usando la funzione. 
\begin{DoxyCode}
1 void *ioremap(unsigned long phys\_addr, unsigned long size);
\end{DoxyCode}


\subparagraph*{Registrazione di un interrupt-\/handler}

Il modulo deve registrare un handler per gli interrupt. L'handler deve essere compatibile con il tipo puntatore a funzione irq\+\_\+handler\+\_\+t, così definito. 
\begin{DoxyCode}
1 struct irqreturn\_t (*irq\_handler\_t)(int irq, struct pt\_regs * regs);
\end{DoxyCode}
 Il modulo definisce la funzione \hyperlink{group___linux-_driver_ga2fc230a12a97aa63e43b2dc4aec73511}{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler()}. L'handler puo' essere registrato usando 
\begin{DoxyCode}
1 int request\_irq(    unsigned int irqNumber,
2                     irqreturn\_t (*handler)(int, void *, struct pt\_regs *),
3                     unsigned long irqflags,
4                     const char *devname,
5                     void *dev\_id);
\end{DoxyCode}
 I\+L parametro irq\+Number puo' essere determinato automaticamente usando la funzione 
\begin{DoxyCode}
1 unsigned int irq\_of\_parse\_and\_map(struct device\_node *node, int index);
\end{DoxyCode}
 La funzione irq\+\_\+of\+\_\+parse\+\_\+and\+\_\+map() effettua un looks-\/up nella specifica degli interrupt all'interno del device tree e restituisce un irq number cosi' come de lo aspetta request\+\_\+irq() (cioe' compaci con l'enumerazione in /proc/interrupts). Il secondo argomento della funzione e', tipicamente, zero, ad indicare che, all'interno del device tree, verra' preso in considerazione soltanto il primo degli interrupt specificate. Il device tree, nella sezione dedicata al gpio,reca 
\begin{DoxyCode}
1 interrupts = <0 29 4>;
\end{DoxyCode}
 Il primo numero (0) e' un flag che indica se l'interrupt sia connesso ad una line S\+P\+I (shared peripheral interrupt). Un valore diverso da zero indica che la linea e' S\+P\+I. Il secondo numero si riferisce all'interrupt number. Per farla breve, quando si definisce la parte hardware, in questo specifico esempio il device G\+P\+I\+O e' connesso alla linea 61 del G\+I\+C. Sottraendo 32 si orriene 29. Il terzo numero si riferisce alla tipologia dell'interrupt. Sono possibili tre valori\+:
\begin{DoxyItemize}
\item 0 \+: power-\/up default
\item 1 \+: rising-\/edge
\item 4 \+: a livelli, active alto
\end{DoxyItemize}

\subparagraph*{Inizializzazione della wait-\/queue per la system-\/call read() e poll()}

In linux una wait queue viene implementata da una struttura dati wait\+\_\+queue\+\_\+head\+\_\+t, definita in $<$linux/wait.\+h$>$. Il driver in questione prevede due wait-\/queue differenti\+: una per la system-\/call read() ed una per la system-\/call poll(). Entrambe le code vengono inizializzate dalla funzione \hyperlink{group___linux-_driver_gae40973a06d72f7c41a9af07513a62307}{my\+G\+P\+I\+O\+K\+\_\+probe()}. 
\begin{DoxyCode}
1 init\_waitqueue\_head(&my\_queue);
\end{DoxyCode}
 Si veda la documentazione della funzione \hyperlink{group___linux-_driver_ga90ac339df9c02ae5f11a2a7727adc923}{my\+G\+P\+I\+O\+K\+\_\+read()} per dettagli ulteriori.

\subparagraph*{Inizializzazione degli spinlock}

I semafori sono uno strumento potentissimo per per l'implementazione di sezioni critiche, ma non possono essere usati in codice non interrompibile. Gli spilock sono come i semafori, ma possono essere usati anche in codice non interrompibile, come puo' esserlo un modulo kernel. Sostanzialmente se uno spinlock e' gia' stato acquisito da qualcun altro, si entra in un hot-\/loop dal quale si esce solo quando chi possiede lo spinlock lo rilascia. Trattandosi di moduli kernel, e' di vitale importanza che la sezione critica sia quanto piu' piccola possibile. Ovviamente l'implementazione e' \char`\"{}un po'\char`\"{} piu' complessa di come e' stata descritta, ma il concetto e' questo. Gli spinlock sono definiti in $<$linux/spinlock.\+h$>$. L'inizializzazione di uno spinlock avviene usando la funzione 
\begin{DoxyCode}
1 void spin\_lock\_init(spinlock\_t *lock);
\end{DoxyCode}


\subparagraph*{Abilitazione degli interrupt del device}

A seconda del valore C\+F\+L\+A\+G\+S\+\_\+my\+G\+P\+I\+O\+K.\+o (si veda il Makefile a corredo), vengono abilitati gli interrupt della periferica. Se si tratta del G\+P\+I\+O Xilinx vengono abilitati gli interrupt globali e gli interrupt sul canale due. Se si tratta del device G\+P\+I\+O custom, essendo esso parecchio piu' semplice, e' necessario abilitare solo gli interrupt globali.\hypertarget{group___linux-_driver_ga90ac339df9c02ae5f11a2a7727adc923}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+read@{my\+G\+P\+I\+O\+K\+\_\+read}}
\index{my\+G\+P\+I\+O\+K\+\_\+read@{my\+G\+P\+I\+O\+K\+\_\+read}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+read}]{\setlength{\rightskip}{0pt plus 5cm}static ssize\+\_\+t my\+G\+P\+I\+O\+K\+\_\+read (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file\+\_\+ptr, }
\item[{char $\ast$}]{buf, }
\item[{size\+\_\+t}]{count, }
\item[{loff\+\_\+t $\ast$}]{off}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga90ac339df9c02ae5f11a2a7727adc923}


Legge dati dal device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em file} & \\
\hline
\mbox{\tt out}  & {\em buf} & \\
\hline
\mbox{\tt in}  & {\em count} & \\
\hline
\mbox{\tt in}  & {\em off} & \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Avvertimento}
L'offset viene diviso per quattro prima di essere aggiunto all'indirizzo base del device.
\end{DoxyWarning}
\begin{DoxyReturn}{Restituisce}
restituisce un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte scritti con successo.
\end{DoxyReturn}
\paragraph*{Operazioni di lettura e scrittura}

I metodi read() e write() effettuano operazioni simili, ossia copiare dati da/verso il device. Il loro prototipo e' molto simile. 
\begin{DoxyCode}
1 ssize\_t read(struct file *filp, char \_\_user *buff, size\_t count, loff\_t *offp);
2 ssize\_t write(struct file *filp, const char \_\_user *buff, size\_t count, loff\_t *offp);
\end{DoxyCode}
 Per entrambi i metodi filep e' il puntatore al file che rapresenta il device, count e' la dimensione dei dati da trasferire, buff e' il puntatore al buffer contenente i dati (da scrivere per la write() o letti per la read()). Infine offp e' il puntatore ad un oggetto \char`\"{}long offset type\char`\"{} che indica la posizione alla quale si sta effettuando l'accesso.

\subparagraph*{I/\+O bloccante}

Nel paragrafo precedente e' stato ignorato un problema importante\+: come comportarsi quando il driver non e' in grado di servire immegiatamente una richiesta? Una chiamata a read() potrebbe arrivare quando i dati non sono disponibili, ma potrebbero esserlo in futuro, oppure, una chiamata a write() potrebbe avvenire quando il device non e' in grado di accettare altri dati (perche' il suo buffer di ingresso potrebbe essere pieno). Il processo chiamante e' totalmente all'oscuro di queste dinamiche, anzi potrebbe non avere la minima conoscenza delle dinamiche interne del device\+: chiama le funzioni read() o write() e si aspetta che facciano cio' che devono fare, per cui, nell'impossibilita' di servire la richiesta, il driver bloccare il processo e metterlo tra i processi \char`\"{}sleeping\char`\"{}, fin quando la richiesta non puo' essere servita. Il codice (la I\+S\+R) che dovra' risvegliare il processo quado potra' servire la sua richiesta, deve essere a conoscenza dell'evento \char`\"{}risvegliante\char`\"{} e deve essere in grado di \char`\"{}trovare\char`\"{} i processi in attesa per quel particolare evento. Per questo motivo, tutti i processi in attesa di un particolare evento vengono posti all'interno della stessa wait queue. Il codice della I\+S\+R deve effettuare una chiamata a wakeup() per risvegliare i processi in attesa di un evento quando questo si e' manifestato. Si veda la documentazione della funzione \hyperlink{group___linux-_driver_ga2fc230a12a97aa63e43b2dc4aec73511}{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler()} per dettagli ulteriori. \subparagraph*{I/\+O non-\/bloccante}

Esistono casi in cui il processo chiamante non vuole essere bloccato in attesa di un evento. Questa evenienza viene esplicitamente indicata attraverso il flag O\+\_\+\+N\+O\+N\+B\+L\+O\+C\+K flag in filp-\/$>$f\+\_\+flags. Il flag viene definito in $<$linux/fcntl.\+h$>$ il quale e' incluso in$<$linux/fs.\+h$>$.

\subparagraph*{Porre un processo nello stato sleeping}

Quando un processo viene messo nello stato sleep, lo si fa aspettandosi che una condizione diventi vera in futuro. Al risveglio, pero', non c'e' nessuna garanzia che quella particolare condizione sia ancora vera, per cui essa va nuovamente testata. Il modo piu' semplice per potte un processo nello stato sleeping e' chiamare la macro wait\+\_\+event(), o una delle sue varianti\+: essa combina la gestione della messa in sleeping del processo ed il check della condizione che il processo si aspetta diventi vera. 
\begin{DoxyCode}
1 wait\_event\_interruptible(queue, condition);
\end{DoxyCode}
 Il parametro queue e' la coda di attesa mentre condition e' la condizione che, valutata true, causa la messa in sleep del processo. La condizione viene valutata sia prima che il processo sia messo in sleeping che al suo risveglio. Lo sleep in cui il processo viene messo chiamando wait\+\_\+event\+\_\+interruptible() puo' essere interrotto anche da un segnale, per cui la macro restituisce un intero che, se diverso da zero, indica che il processo e' stato risvegliato da un segnale.

La condizione sulla quale i processi vengono bloccati riguarda il flag \char`\"{}interrupt occurred\char`\"{}. Fin quando questo flag, posto in and con la maschera M\+Y\+G\+P\+I\+O\+K\+\_\+\+S\+R\+E\+A\+D, e' zero, il processo deve restare bloccato, per cui i processi che effettuano read() bloccante restano bloccati finche' int\+\_\+occurred \& M\+Y\+G\+P\+I\+O\+\_\+\+S\+R\+E\+A\+D == 0. Quando tale uguaglianza non sara' piu' valida, perche' il valore di int\+\_\+occurred viene settato dalla funzione \hyperlink{group___linux-_driver_ga2fc230a12a97aa63e43b2dc4aec73511}{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler()}, allora il processo verra' risvegliato.

\subparagraph*{Reset del flag \char`\"{}interrupt occurred\char`\"{} per read() bloccanti}

Nel momento in cui il processo viene risvegliato e la condizione della quale era in attesa e' tale che esso puo' continuare la sua esecuzione, e' necessario resettare tale flag. Questa operazione va effettuata per prevenire race-\/condition dovute al risveglio di piu' processi in attesa del manifestarsi dello stesso evento. Il reset del flag va, pertanto, effettuato in mutua esclusione.

I semafori sono uno strumento potentissimo per per l'implementazione di sezioni critiche, ma non possono essere usati in codice non interrompibile. Gli spilock sono come i semafori, ma possono essere usati anche in codice non interrompibile, come puo' esserlo un modulo kernel. Sostanzialmente se uno spinlock e' gia' stato acquisito da qualcun altro, si entra in un hot-\/loop dal quale si esce solo quando chi possiede lo spinlock lo rilascia. Trattandosi di moduli kernel, e' di vitale importanza che la sezione critica sia quanto piu' piccola possibile. Ovviamente l'implementazione e' \char`\"{}un po'\char`\"{} piu' complessa di come e' stata descritta, ma il concetto e' questo. Gli spinlock sono definiti in $<$linux/spinlock.\+h$>$. Esistono diversi modi per acquisire uno spinlock. Nel seguito viene usata la funzione 
\begin{DoxyCode}
1 void spin\_lock(spinlock\_t *lock);
\end{DoxyCode}
 per rilasciare uno spinlock, invece, verra' usata 
\begin{DoxyCode}
1 void spin\_unlock(spinlock\_t *lock);
\end{DoxyCode}


\subparagraph*{Accesso ai registri del device}

Si potrebbe senrire la tentazione di usare il puntatore restituito da ioremap() dereferenziandolo per accedere alla memoria. Questo modo di procedere non e' portabile ed e' prono ad errori. Il modo corretto di accedere alla memoria e' attraverso l'uso delle funzioni per il memory-\/mapped I/\+O, definite in $<$asm/io.\+h$>$. Per leggere dalla memoria vengono usate le seguenti\+: 
\begin{DoxyCode}
1 unsigned int ioread8(void *addr);
2 unsigned int ioread16(void *addr);
3 unsigned int ioread32(void *addr);
\end{DoxyCode}
 addr e' l'indirizzo di memoria virtuale del device, ottenuto mediante chiamata a ioremap(), a cui viene, eventualmente, aggiunto un offset. Il valore restituito dalle funzioni e' quello letto dalla particolare locazione di memoria a cui viene effettuato accesso. Per scrivere nella memoria vengono usate le seguenti\+: 
\begin{DoxyCode}
1 void iowrite8(u8 value, void *addr);
2 void iowrite16(u16 value, void *addr);
3 void iowrite32(u32 value, void *addr);
\end{DoxyCode}


\subparagraph*{Accesso alla memoria userspace}

Buff e' un puntatore appartenente allo spazio di indirizzamento del programma user-\/space che utilizza il modulo kernel. Il modulo, quindi, non puo' accedere direttamente ad esso, dereferenziandolo, per diverse ragioni, tra le quali\+:
\begin{DoxyItemize}
\item a seconda dell'architettura sulla quale il driver e' in esecuzione e di come il kernel e' stato configurato, il puntatore userspace potrebbe non essere valido mentre il modulo kernel viene eseguito;
\item la memoria user-\/space e' paginata e potrebbe non essere presente in R\+A\+M quando la system-\/call viene effettuata, per cui dereferenziando il puntatore potrebbe originarsi un page-\/fault con conseguente terminazione del processo che ha effettuato la system-\/call;
\item il puntatore in questione potrebbe essere stato fornito da un programma user-\/space buggato o malizioso, motivo per cui dereferenziandolo verrebbe a crearsi un punto di accesso attraverso il quale il programma userspace puo' modificare la memoria senza costrizioni.
\end{DoxyItemize}

Ovviamente il driver deve essere in grado di poter accedere al buffer userspace, per cui tale accesso va fatto solo ed esclusivamente attraverso delle funzioni fornite dal kernel stesso, e definite in $<$asm/uaccess.\+h$>$ 
\begin{DoxyCode}
1 unsigned long copy\_to\_user(void \_\_user *to, const void *from, unsigned long count);
2 unsigned long copy\_from\_user(void *to, const void \_\_user *from, unsigned long count);
\end{DoxyCode}
 Queste due funzioni non si limitano a copiare dati da/verso userspacem\+: verificano, infatti, anche che il puntatore al buffer userspace sia valido. Se il puntatore non risultasse valido la copia non viene effettuata. Sia il metodo read() che il metodo write() restituiscono un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte trasferiti con successo.

\subparagraph*{Piccola nota sull'endianess}

Il processore Zynq e' little endian. Per questo motivo e' possibile convertire char$\ast$ in uint32\+\_\+t$\ast$ mediante un semplice casting, senza invertire manualmente l'ordine dei byte.

\subparagraph*{Debouncing}

Sebbene normalmente non necessario, in questo caso si e' preferito inserire un hot-\/loop, in modo da attendere che il device di input venga riportato allo stato di riposo prima di continuare l'esecuzione della funzione. Questo piccolo espediente serve a fare in modo che, nel nostro caso, non vengano generate interruzioni spurie. Il ciclo va rimosso in qualsiasi applicazione che non riguardi la pressione di un tasto.

\subparagraph*{Ack degli interrupt della periferica}

Viene inviato l'Ack alla periferica, per segnalargli che l'interrupt e' stato servito, solo dopo che la lettura sia stata effettuata.

\subparagraph*{Abilitazione degli interrupt della periferica}

Dopo aver inviato notifica di servizio dell'interruzione al device, vengono nuovamente abilitati gli interrupt.\hypertarget{group___linux-_driver_ga17ce7f574723246c790b70b06e3e7103}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+release@{my\+G\+P\+I\+O\+K\+\_\+release}}
\index{my\+G\+P\+I\+O\+K\+\_\+release@{my\+G\+P\+I\+O\+K\+\_\+release}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+release}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+release (
\begin{DoxyParamCaption}
\item[{struct inode $\ast$}]{inode, }
\item[{struct file $\ast$}]{file\+\_\+ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga17ce7f574723246c790b70b06e3e7103}


Invocata alla chiusura del file corrispondente al device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em inode} & \\
\hline
\mbox{\tt in}  & {\em file} & \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Valori di ritorno}
{\em 0} & se non si verifica nessun errore \\
\hline
\end{DoxyRetVals}
\hypertarget{group___linux-_driver_ga59fddfaa36dea357f4bbdfceb0f47f8c}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+remove@{my\+G\+P\+I\+O\+K\+\_\+remove}}
\index{my\+G\+P\+I\+O\+K\+\_\+remove@{my\+G\+P\+I\+O\+K\+\_\+remove}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+remove}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+remove (
\begin{DoxyParamCaption}
\item[{struct platform\+\_\+device $\ast$}]{op}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga59fddfaa36dea357f4bbdfceb0f47f8c}
Viene chiamata automaticamente alla rimozione del mosulo.


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in,out}  & {\em op} & \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Valori di ritorno}
{\em 0} & se non si verifica nessun errore\\
\hline
\end{DoxyRetVals}
Dealloca tutta la memoria utilizzata dal driver, de-\/inizializzando il device e disattivando gli interrupt per il device, effettuando tutte le operazioni inverse della funzione \hyperlink{group___linux-_driver_gae40973a06d72f7c41a9af07513a62307}{my\+G\+P\+I\+O\+K\+\_\+probe()}. \hypertarget{group___linux-_driver_ga1eea0f6c86e8966ba9b701da57502aad}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+write@{my\+G\+P\+I\+O\+K\+\_\+write}}
\index{my\+G\+P\+I\+O\+K\+\_\+write@{my\+G\+P\+I\+O\+K\+\_\+write}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+write}]{\setlength{\rightskip}{0pt plus 5cm}static ssize\+\_\+t my\+G\+P\+I\+O\+K\+\_\+write (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file\+\_\+ptr, }
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{size, }
\item[{loff\+\_\+t $\ast$}]{off}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga1eea0f6c86e8966ba9b701da57502aad}


Invia dati al device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em file} & \\
\hline
\mbox{\tt in}  & {\em buf} & \\
\hline
\mbox{\tt in}  & {\em size} & \\
\hline
\mbox{\tt in}  & {\em off} & \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Avvertimento}
L'offset viene diviso per quattro prima di essere aggiunto all'indirizzo base del device.
\end{DoxyWarning}
\begin{DoxyReturn}{Restituisce}
restituisce un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte scritti con successo.
\end{DoxyReturn}
\paragraph*{Operazioni di lettura e scrittura}

I metodi read() e write() effettuano operazioni simili, ossia copiare dati da/verso il device. Il loro prototipo e' molto simile.


\begin{DoxyCode}
1 ssize\_t read(struct file *filp, char \_\_user *buff, size\_t count, loff\_t *offp);
2 ssize\_t write(struct file *filp, const char \_\_user *buff, size\_t count, loff\_t *offp);
\end{DoxyCode}


Per entrambi i metodi filep e' il puntatore al file che rapresenta il device, count e' la dimensione dei dati da trasferire, buff e' il puntatore al buffer contenente i dati (da scrivere per la write() o letti per la read()). Infine offp e' il puntatore ad un oggetto \char`\"{}long offset type\char`\"{} che indica la posizione alla quale si sta effettuando l'accesso. \subparagraph*{Accesso alla memoria userspace}

Buff e' un puntatore appartenente allo spazio di indirizzamento del programma user-\/space che utilizza il modulo kernel. Il modulo, quindi, non puo' accedere direttamente ad esso, dereferenziandolo, per diverse ragioni, tra le quali\+:
\begin{DoxyItemize}
\item a seconda dell'architettura sulla quale il driver e' in esecuzione e di come il kernel e' stato configurato, il puntatore userspace potrebbe non essere valido mentre il modulo kernel viene eseguito;
\item la memoria user-\/space e' paginata e potrebbe non essere presente in R\+A\+M quando la system-\/call viene effettuata, per cui dereferenziando il puntatore potrebbe originarsi un page-\/fault con conseguente terminazione del processo che ha effettuato la system-\/call;
\item il puntatore in questione potrebbe essere stato fornito da un programma user-\/space buggato o malizioso, motivo per cui dereferenziandolo verrebbe a crearsi un punto di accesso attraverso il quale il programma userspace puo' modificare la memoria senza costrizioni.
\end{DoxyItemize}

Ovviamente il driver deve essere in grado di poter accedere al buffer userspace, per cui tale accesso va fatto solo ed esclusivamente attraverso delle funzioni fornite dal kernel stesso, e definite in $<$asm/uaccess.\+h$>$ 
\begin{DoxyCode}
1 unsigned long copy\_to\_user(void \_\_user *to, const void *from, unsigned long count);
2 unsigned long copy\_from\_user(void *to, const void \_\_user *from, unsigned long count);
\end{DoxyCode}
 Queste due funzioni non si limitano a copiare dati da/verso userspacem\+: verificano, infatti, anche che il puntatore al buffer userspace sia valido. Se il puntatore non risultasse valido la copia non viene effettuata. Sia il metodo read() che il metodo write() restituiscono un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte trasferiti con successo.

\subparagraph*{Piccola nota sull'endianess}

Il processore Zynq e' little endian. Per questo motivo e' possibile convertire char$\ast$ in uint32\+\_\+t$\ast$ mediante un semplice casting, senza invertire manualmente l'ordine dei byte.

\subparagraph*{Accesso ai registri del device}

Si potrebbe senrire la tentazione di usare il puntatore restituito da ioremap() dereferenziandolo per accedere alla memoria. Questo modo di procedere non e' portabile ed e' prono ad errori. Il modo corretto di accedere alla memoria e' attraverso l'uso delle funzioni per il memory-\/mapped I/\+O, definite in $<$asm/io.\+h$>$.

Per leggere dalla memoria vengono usate le seguenti\+:


\begin{DoxyCode}
1 unsigned int ioread8(void *addr);
2 unsigned int ioread16(void *addr);
3 unsigned int ioread32(void *addr);
\end{DoxyCode}


addr e' l'indirizzo di memoria virtuale del device, ottenuto mediante chiamata a ioremap(), a cui viene, eventualmente, aggiunto un offset. Il valore restituito dalle funzioni e' quello letto dalla particolare locazione di memoria a cui viene effettuato accesso.

Per scrivere nella memoria vengono usate le seguenti\+:


\begin{DoxyCode}
1 void iowrite8(u8 value, void *addr);
2 void iowrite16(u16 value, void *addr);
3 void iowrite32(u32 value, void *addr);
\end{DoxyCode}


\subsection{Documentazione delle variabili}
\hypertarget{group___linux-_driver_ga9f31111fdb3b4a5944e18d45045e0f01}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+\_\+fops@{my\+G\+P\+I\+O\+\_\+fops}}
\index{my\+G\+P\+I\+O\+\_\+fops@{my\+G\+P\+I\+O\+\_\+fops}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+\_\+fops}]{\setlength{\rightskip}{0pt plus 5cm}struct file\+\_\+operations my\+G\+P\+I\+O\+\_\+fops\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga9f31111fdb3b4a5944e18d45045e0f01}
{\bfseries Valore iniziale\+:}
\begin{DoxyCode}
= \{
        .owner      = THIS\_MODULE,
        .llseek     = \hyperlink{group___linux-_driver_ga66e7f726b72320a272b633ecbaecefff}{myGPIOK\_llseek},
        .read       = \hyperlink{group___linux-_driver_ga90ac339df9c02ae5f11a2a7727adc923}{myGPIOK\_read},
        .write      = \hyperlink{group___linux-_driver_ga1eea0f6c86e8966ba9b701da57502aad}{myGPIOK\_write},
        .poll       = \hyperlink{group___linux-_driver_gaba935e8a8215c2ebce9a7147fd4f5147}{myGPIOK\_poll},
        .open       = \hyperlink{group___linux-_driver_gad013759c18fbf6ea96005b9b3bfa5b4e}{myGPIOK\_open},
        .release    = \hyperlink{group___linux-_driver_ga17ce7f574723246c790b70b06e3e7103}{myGPIOK\_release}
\}
\end{DoxyCode}


mantiene puntatori a funzioni che definiscono il gli operatori che agiscono su un file/device. 

Essendo un device \char`\"{}visto\char`\"{} come un file, ogni device driver deve implementare tutte le system-\/call previste per l'interfacciamento con un file. La corrispondenza tra la system-\/call e la funzione fornita dal driver viene stabilita attraverso tale struttura. La struttura dati file\+\_\+operations, definita in $<$linux/fs.\+h$>$ mantiene puntatori a funzioni definite dal driver che consentono di definire il comportamento degli operatori che agiscono su un file. \hypertarget{group___linux-_driver_gaaf8d1bce7d6389684a037e94381c275c}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+class@{my\+G\+P\+I\+O\+K\+\_\+class}}
\index{my\+G\+P\+I\+O\+K\+\_\+class@{my\+G\+P\+I\+O\+K\+\_\+class}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+class}]{\setlength{\rightskip}{0pt plus 5cm}struct class$\ast$ my\+G\+P\+I\+O\+K\+\_\+class = N\+U\+L\+L\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_gaaf8d1bce7d6389684a037e94381c275c}
\hypertarget{group___linux-_driver_gae370dfc26b06b6cc24a7bcc152f4969e}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr@{my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr}}
\index{my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr@{my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf my\+G\+P\+I\+O\+K\+\_\+t}$\ast$ my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr = N\+U\+L\+L}}\label{group___linux-_driver_gae370dfc26b06b6cc24a7bcc152f4969e}


Puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, contenente tutti i dati necessari al device driver. 

\hypertarget{group___linux-_driver_ga2d345c792760e3103059b6b6e0bfdaee}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+device@{my\+G\+P\+I\+O\+K\+\_\+device}}
\index{my\+G\+P\+I\+O\+K\+\_\+device@{my\+G\+P\+I\+O\+K\+\_\+device}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+device}]{\setlength{\rightskip}{0pt plus 5cm}struct device$\ast$ my\+G\+P\+I\+O\+K\+\_\+device = N\+U\+L\+L\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga2d345c792760e3103059b6b6e0bfdaee}
\hypertarget{group___linux-_driver_ga8dba1541b58fa63f8208232ffce4fc47}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+driver@{my\+G\+P\+I\+O\+K\+\_\+driver}}
\index{my\+G\+P\+I\+O\+K\+\_\+driver@{my\+G\+P\+I\+O\+K\+\_\+driver}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+driver}]{\setlength{\rightskip}{0pt plus 5cm}struct platform\+\_\+driver my\+G\+P\+I\+O\+K\+\_\+driver\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga8dba1541b58fa63f8208232ffce4fc47}
{\bfseries Valore iniziale\+:}
\begin{DoxyCode}
= \{
        .probe = \hyperlink{group___linux-_driver_gae40973a06d72f7c41a9af07513a62307}{myGPIOK\_probe},
        .remove = \hyperlink{group___linux-_driver_ga59fddfaa36dea357f4bbdfceb0f47f8c}{myGPIOK\_remove},
        .driver = \{
                .name = \hyperlink{group___linux-_driver_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME},
                .owner = THIS\_MODULE,
                .of\_match\_table = \hyperlink{group___linux-_driver_ga91f28437e0a553effa546d16fa44f03a}{myGPIOk\_match},
        \},
\}
\end{DoxyCode}


Definisce quali funzioni probe() e remove() chiamare quando viene caricato un driver. 

\hypertarget{group___linux-_driver_ga91f28437e0a553effa546d16fa44f03a}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+Ok\+\_\+match@{my\+G\+P\+I\+Ok\+\_\+match}}
\index{my\+G\+P\+I\+Ok\+\_\+match@{my\+G\+P\+I\+Ok\+\_\+match}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+Ok\+\_\+match}]{\setlength{\rightskip}{0pt plus 5cm}struct of\+\_\+device\+\_\+id my\+G\+P\+I\+Ok\+\_\+match\mbox{[}$\,$\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga91f28437e0a553effa546d16fa44f03a}
{\bfseries Valore iniziale\+:}
\begin{DoxyCode}
= \{
        \{.compatible = \hyperlink{group___linux-_driver_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME}\},
        \{\},
\}
\end{DoxyCode}


Identifica il device all'interno del device tree. 

Tutti i device-\/driver devono esporre un I\+D. A tempo di compilazione, il processo di build estrae queste informazioni dai driver per la preparazione di una tabella. Quando si \char`\"{}inserisce\char`\"{} il device, la tabella viene riferita dal kernel e, se viene trovata una entry corrispondente al driver per quel device, il driver viene caricato ed inizializzato. \hypertarget{group___linux-_driver_ga434e034e4625b1949f0c626823870a39}{\index{Linux-\/\+Driver@{Linux-\/\+Driver}!my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number@{my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number@{my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number}!Linux-\/\+Driver@{Linux-\/\+Driver}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number}]{\setlength{\rightskip}{0pt plus 5cm}dev\+\_\+t my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number\hspace{0.3cm}{\ttfamily [static]}}}\label{group___linux-_driver_ga434e034e4625b1949f0c626823870a39}


Major e minor number per il device driver. 

