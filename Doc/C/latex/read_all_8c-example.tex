\hypertarget{read_all_8c-example}{\section{read\+All.\+c}
}
Programma di test/debug. Legge tutti i registri della periferica direttamente dal file /dev/mem \begin{DoxyAuthor}{Autore}
Salvatore Barone \href{mailto:salvator.barone@gmail.com}{\tt salvator.\+barone@gmail.\+com} 
\end{DoxyAuthor}
\begin{DoxyDate}{Data}
19 06 2017
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
Copyright 2017 Salvatore Barone \href{mailto:salvator.barone@gmail.com}{\tt salvator.\+barone@gmail.\+com}
\end{DoxyCopyright}
This file is part of Zynq7000\+Driver\+Pack

Zynq7000\+Driver\+Pack is free software; you can redistribute it and/or modify it under the terms of the G\+N\+U General Public License as published by the Free Software Foundation; either version 3 of the License, or any later version.

Zynq7000\+Driver\+Pack is distributed in the hope that it will be useful, but W\+I\+T\+H\+O\+U\+T A\+N\+Y W\+A\+R\+R\+A\+N\+T\+Y; without even the implied warranty of M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+T\+Y or F\+I\+T\+N\+E\+S\+S F\+O\+R A P\+A\+R\+T\+I\+C\+U\+L\+A\+R P\+U\+R\+P\+O\+S\+E. See the G\+N\+U General Public License for more details.

You should have received a copy of the G\+N\+U General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, M\+A 02110-\/1301, U\+S\+A.


\begin{DoxyCodeInclude}

\textcolor{preprocessor}{#include <inttypes.h>}
\textcolor{preprocessor}{#include <stdio.h>}
\textcolor{preprocessor}{#include <stdlib.h>}
\textcolor{preprocessor}{#include <unistd.h>}
\textcolor{preprocessor}{#include <sys/mman.h>}
\textcolor{preprocessor}{#include <fcntl.h>}

\textcolor{keywordtype}{void} \hyperlink{read_all_8c_a05909651fa170a63e98e3f8e13451b7b}{howto}(\textcolor{keywordtype}{void}) \{
    printf(\textcolor{stringliteral}{"Uso:\(\backslash\)n"});
    printf(\textcolor{stringliteral}{"noDriver -a <gpio\_phisycal\_address> -o <max-offset>\(\backslash\)n"});
    printf(\textcolor{stringliteral}{"-a <gpio\_phisycal\_address>: indirizzo fisico del device GPIO\(\backslash\)n"});
    printf(\textcolor{stringliteral}{"\(\backslash\)t-o <max-offset>: offsett dell'ultimo registro letto\(\backslash\)n"});
\}

\textcolor{keywordtype}{int} \hyperlink{read_all_8c_a87c1177178432113628b0885b0cff1b2}{parse\_args}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv, uint32\_t    *gpio\_address, uint32\_t *max\_offset) \{
    \textcolor{keywordtype}{int} par;

    \textcolor{keywordflow}{while}((par = getopt(argc, argv, \textcolor{stringliteral}{"a:o:"})) != -1) \{
        \textcolor{keywordflow}{switch} (par) \{
        \textcolor{keywordflow}{case} \textcolor{charliteral}{'a'} :
            *gpio\_address = strtoul(optarg, NULL, 0);
            \textcolor{keywordflow}{break};
        \textcolor{keywordflow}{case} \textcolor{charliteral}{'o'} :
            *max\_offset = strtoul(optarg, NULL, 0);
            \textcolor{keywordflow}{break};
        \textcolor{keywordflow}{default} :
            printf(\textcolor{stringliteral}{"%c: parametro sconosciuto.\(\backslash\)n"}, par);
            \hyperlink{read_all_8c_a05909651fa170a63e98e3f8e13451b7b}{howto}();
            \textcolor{keywordflow}{return} -1;
        \}
    \}
    \textcolor{keywordflow}{return} 0;
\}

\textcolor{keywordtype}{int} \hyperlink{read_all_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv) \{
    uint32\_t gpio\_addr = 0;
    uint32\_t max\_offset = 16;

    \textcolor{keywordflow}{if} (\hyperlink{read_all_8c_a87c1177178432113628b0885b0cff1b2}{parse\_args}(argc, argv, &gpio\_addr, &max\_offset) == -1)
        \textcolor{keywordflow}{return} -1;

    \textcolor{keywordflow}{if} (gpio\_addr == 0) \{
        printf(\textcolor{stringliteral}{"è necessario specificare l'indirizzo di memoria del device.\(\backslash\)n"});
        \hyperlink{read_all_8c_a05909651fa170a63e98e3f8e13451b7b}{howto}();
        \textcolor{keywordflow}{return} -1;
    \}

    \textcolor{keywordtype}{int} descriptor = open (\textcolor{stringliteral}{"/dev/mem"}, O\_RDWR);
    \textcolor{keywordflow}{if} (descriptor < 1) \{
        perror(argv[0]);
        \textcolor{keywordflow}{return} -1;
    \}

    uint32\_t page\_size = sysconf(\_SC\_PAGESIZE);     \textcolor{comment}{// dimensione della pagina}
    uint32\_t page\_mask = ~(page\_size-1);            \textcolor{comment}{// maschera di conversione indirizzo -> indirizzo
       pagina}
    uint32\_t page\_addr = gpio\_addr & page\_mask;     \textcolor{comment}{// indirizzo della "pagina fisica" a cui è mappato il
       device}
    uint32\_t offset = gpio\_addr - page\_addr;        \textcolor{comment}{// offset del device rispetto all'indirizzo della
       pagina}
    \textcolor{comment}{// conversione dell'indirizzo fisico in indirizzo virtuale}
    \textcolor{keywordtype}{void}* vrt\_page\_addr = mmap(NULL, page\_size, PROT\_READ | PROT\_WRITE, MAP\_SHARED, descriptor, page\_addr);

    \textcolor{keywordflow}{if} (vrt\_page\_addr == MAP\_FAILED) \{
        printf(\textcolor{stringliteral}{"Mapping indirizzo fisico - indirizzo virtuale FALLITO!\(\backslash\)n"});
        \textcolor{keywordflow}{return} -1;
    \}

    \textcolor{keywordtype}{void}* vrt\_gpio\_addr = vrt\_page\_addr + offset;   \textcolor{comment}{// indirizzo virtuale del device gpio}

    printf(\textcolor{stringliteral}{"base address : %08X\(\backslash\)n"}, (uint32\_t) vrt\_gpio\_addr);
    uint32\_t read\_value = 0;
    uint32\_t i;
    \textcolor{keywordflow}{for} (i=0; i<=max\_offset; i+=4) \{
        read\_value = *((uint32\_t*)(vrt\_gpio\_addr+i));
        printf(\textcolor{stringliteral}{"\(\backslash\)toffset : %08X => %08X\(\backslash\)n"}, i, read\_value);
    \}

    munmap(vrt\_page\_addr, page\_size);
    close(descriptor);

    \textcolor{keywordflow}{return} 0;
\}

\end{DoxyCodeInclude}
 