\hypertarget{group__my_g_p_i_o_k__t}{\section{My\+G\+P\+I\+O\+K\+\_\+t}
\label{group__my_g_p_i_o_k__t}\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
}


Definisce l'oggetto \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che rappresenta un device my\+G\+P\+I\+O a livello kernel.  


Diagramma di collaborazione per My\+G\+P\+I\+O\+K\+\_\+t\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{group__my_g_p_i_o_k__t}
\end{center}
\end{figure}
\subsection*{Strutture dati}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}
\begin{DoxyCompactList}\small\item\em Stuttura per l'astrazione di un device my\+G\+P\+I\+O in kernel-\/mode. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Definizioni}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group__my_g_p_i_o_k__t_ga0da2526ca3cd1a94ebcecf96778ea2e5}{my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T}~0x0\+C\+U
\begin{DoxyCompactList}\small\item\em Offset, rispetto all'indirizzo base, del registro \char`\"{}\+G\+I\+E\+S\char`\"{}. \end{DoxyCompactList}\item 
\#define \hyperlink{group__my_g_p_i_o_k__t_ga2ed7646e6f910f5803477e51b7fe26e3}{my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T}~0x10\+U
\begin{DoxyCompactList}\small\item\em Offset, rispetto all'indirizzo base, del registro \char`\"{}\+P\+I\+E\char`\"{}. \end{DoxyCompactList}\item 
\#define \hyperlink{group__my_g_p_i_o_k__t_ga37ee502d1ba364dfde9261c4f7a537a6}{my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T}~0x14\+U
\begin{DoxyCompactList}\small\item\em Offset, rispetto all'indirizzo base, del registro \char`\"{}\+I\+R\+Q\char`\"{}. \end{DoxyCompactList}\item 
\#define \hyperlink{group__my_g_p_i_o_k__t_gac72408c288009c213c0231973b3fe761}{my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T}~0x18\+U
\begin{DoxyCompactList}\small\item\em Offset, rispetto all'indirizzo base, del registro \char`\"{}\+I\+A\+C\+K\char`\"{}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Funzioni}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{group__my_g_p_i_o_k__t_ga64afb2eff1f990814d792349842c522d}{my\+G\+P\+I\+O\+K\+\_\+\+Init} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$my\+G\+P\+I\+O\+K\+\_\+device, struct module $\ast$owner, struct platform\+\_\+device $\ast$op, struct class $\ast$class, const char $\ast$driver\+\_\+name, const char $\ast$device\+\_\+name, uint32\+\_\+t serial, struct file\+\_\+operations $\ast$f\+\_\+ops, irq\+\_\+handler\+\_\+t irq\+\_\+handler, uint32\+\_\+t irq\+\_\+mask)
\begin{DoxyCompactList}\small\item\em Inizializza una struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} e configura il device corrispondente. \end{DoxyCompactList}\item 
void \hyperlink{group__my_g_p_i_o_k__t_ga24255b79dd8549aa655cf28c1f9a65d5}{my\+G\+P\+I\+O\+K\+\_\+\+Destroy} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$device)
\begin{DoxyCompactList}\small\item\em Deinizializza un device, rimuovendo le strutture kernel allocate per il suo funzionamento. \end{DoxyCompactList}\item 
void \hyperlink{group__my_g_p_i_o_k__t_gad82c1051e6acb335b1b26ab0c459453b}{my\+G\+P\+I\+O\+K\+\_\+\+Set\+Can\+Read} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$device)
\begin{DoxyCompactList}\small\item\em Set del flag \char`\"{}interrupt occurred\char`\"{} (can\+Read) \end{DoxyCompactList}\item 
void \hyperlink{group__my_g_p_i_o_k__t_ga6dc0ec06b388522ffc524e5fd14d8b72}{my\+G\+P\+I\+O\+K\+\_\+\+Reset\+Can\+Read} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$device)
\begin{DoxyCompactList}\small\item\em Reset del flag \char`\"{}interrupt occurred\char`\"{} (can\+Read) \end{DoxyCompactList}\item 
void \hyperlink{group__my_g_p_i_o_k__t_gaf1b6f35c097c46361d675a42f122828e}{my\+G\+P\+I\+O\+K\+\_\+\+Test\+Can\+Read\+And\+Sleep} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$device)
\begin{DoxyCompactList}\small\item\em Testa la condizione \char`\"{}interrupt occurred\char`\"{}, mettendo in attesa il processo, se necessario. \end{DoxyCompactList}\item 
unsigned \hyperlink{group__my_g_p_i_o_k__t_gae428f50a6da69e3cf89348b8ba9401b1}{my\+G\+P\+I\+O\+K\+\_\+\+Get\+Poll\+Mask} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$device, struct file $\ast$file\+\_\+ptr, struct poll\+\_\+table\+\_\+struct $\ast$wait)
\begin{DoxyCompactList}\small\item\em Verifica che le operazioni di lettura/scrittura risultino non-\/bloccanti. \end{DoxyCompactList}\item 
void \hyperlink{group__my_g_p_i_o_k__t_ga5a7df448de9de94620ce1baf7ec388c9}{my\+G\+P\+I\+O\+K\+\_\+\+Increment\+Total} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$device)
\begin{DoxyCompactList}\small\item\em Incrementa il contatore degli interrupt per un particolare device. \end{DoxyCompactList}\item 
void \hyperlink{group__my_g_p_i_o_k__t_gae182aa943af08c102a05795ae8526192}{my\+G\+P\+I\+O\+K\+\_\+\+Wake\+Up} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$device)
\begin{DoxyCompactList}\small\item\em Risveglia i process in attesa sulle code di read e poll. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{group__my_g_p_i_o_k__t_ga565ffd4946b330b29e1166dfc9851b11}{my\+G\+P\+I\+O\+K\+\_\+\+Get\+Device\+Address} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$device)
\begin{DoxyCompactList}\small\item\em Restituisce l'indirizzo virtuale di memoria cui è mappato un device. \end{DoxyCompactList}\item 
void \hyperlink{group__my_g_p_i_o_k__t_ga00a24f28b49c71aaa91f66be71a3895b}{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$my\+G\+P\+I\+O\+K\+\_\+device)
\begin{DoxyCompactList}\small\item\em Abilita gli interrupt globali;. \end{DoxyCompactList}\item 
void \hyperlink{group__my_g_p_i_o_k__t_gace0d81f5ec65978f22118a3f1fc8b222}{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$my\+G\+P\+I\+O\+K\+\_\+device)
\begin{DoxyCompactList}\small\item\em Disabilita gli interrupt globali;. \end{DoxyCompactList}\item 
void \hyperlink{group__my_g_p_i_o_k__t_ga179c20f5f62e8ce1593cbedff2f00533}{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$my\+G\+P\+I\+O\+K\+\_\+device, unsigned mask)
\begin{DoxyCompactList}\small\item\em Abilita gli interrupt per i singoli pin del device. \end{DoxyCompactList}\item 
void \hyperlink{group__my_g_p_i_o_k__t_gabfd91641f98a4725aec779c8834ca92d}{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$my\+G\+P\+I\+O\+K\+\_\+device, unsigned mask)
\begin{DoxyCompactList}\small\item\em Disabilita gli interrupt per i singoli pin del device. \end{DoxyCompactList}\item 
unsigned \hyperlink{group__my_g_p_i_o_k__t_ga1b3ad44b9198f537493180d748de0b6c}{my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$my\+G\+P\+I\+O\+K\+\_\+device)
\begin{DoxyCompactList}\small\item\em Consente di ottenere una maschera che indichi quali interrupt non siano stati ancora serviti;. \end{DoxyCompactList}\item 
void \hyperlink{group__my_g_p_i_o_k__t_ga8eaf8f1b21aa6f772c395faf457144f9}{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack} (\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$my\+G\+P\+I\+O\+K\+\_\+device, unsigned mask)
\begin{DoxyCompactList}\small\item\em Invia al device notifica di servizio di un interrupt;. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Descrizione dettagliata}
Definisce l'oggetto \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che rappresenta un device my\+G\+P\+I\+O a livello kernel. 



\subsection{Documentazione delle definizioni}
\hypertarget{group__my_g_p_i_o_k__t_ga0da2526ca3cd1a94ebcecf96778ea2e5}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+G\+I\+E\+S\+\_\+\+O\+F\+F\+S\+E\+T~0x0\+C\+U}}\label{group__my_g_p_i_o_k__t_ga0da2526ca3cd1a94ebcecf96778ea2e5}


Offset, rispetto all'indirizzo base, del registro \char`\"{}\+G\+I\+E\+S\char`\"{}. 

\hypertarget{group__my_g_p_i_o_k__t_gac72408c288009c213c0231973b3fe761}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+I\+A\+C\+K\+\_\+\+O\+F\+F\+S\+E\+T~0x18\+U}}\label{group__my_g_p_i_o_k__t_gac72408c288009c213c0231973b3fe761}


Offset, rispetto all'indirizzo base, del registro \char`\"{}\+I\+A\+C\+K\char`\"{}. 

\hypertarget{group__my_g_p_i_o_k__t_ga37ee502d1ba364dfde9261c4f7a537a6}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+I\+R\+Q\+\_\+\+O\+F\+F\+S\+E\+T~0x14\+U}}\label{group__my_g_p_i_o_k__t_ga37ee502d1ba364dfde9261c4f7a537a6}


Offset, rispetto all'indirizzo base, del registro \char`\"{}\+I\+R\+Q\char`\"{}. 

\hypertarget{group__my_g_p_i_o_k__t_ga2ed7646e6f910f5803477e51b7fe26e3}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T@{my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define my\+G\+P\+I\+O\+K\+\_\+\+P\+I\+E\+\_\+\+O\+F\+F\+S\+E\+T~0x10\+U}}\label{group__my_g_p_i_o_k__t_ga2ed7646e6f910f5803477e51b7fe26e3}


Offset, rispetto all'indirizzo base, del registro \char`\"{}\+P\+I\+E\char`\"{}. 



\subsection{Documentazione delle funzioni}
\hypertarget{group__my_g_p_i_o_k__t_ga24255b79dd8549aa655cf28c1f9a65d5}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Destroy@{my\+G\+P\+I\+O\+K\+\_\+\+Destroy}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Destroy@{my\+G\+P\+I\+O\+K\+\_\+\+Destroy}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Destroy}]{\setlength{\rightskip}{0pt plus 5cm}void my\+G\+P\+I\+O\+K\+\_\+\+Destroy (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_ga24255b79dd8549aa655cf28c1f9a65d5}


Deinizializza un device, rimuovendo le strutture kernel allocate per il suo funzionamento. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, specifica il particolare device su cui agire \\
\hline
\end{DoxyParams}
\hypertarget{group__my_g_p_i_o_k__t_ga565ffd4946b330b29e1166dfc9851b11}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Get\+Device\+Address@{my\+G\+P\+I\+O\+K\+\_\+\+Get\+Device\+Address}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Get\+Device\+Address@{my\+G\+P\+I\+O\+K\+\_\+\+Get\+Device\+Address}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Get\+Device\+Address}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ my\+G\+P\+I\+O\+K\+\_\+\+Get\+Device\+Address (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_ga565ffd4946b330b29e1166dfc9851b11}


Restituisce l'indirizzo virtuale di memoria cui è mappato un device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare \\
\hline
\end{DoxyParams}
\hypertarget{group__my_g_p_i_o_k__t_gae428f50a6da69e3cf89348b8ba9401b1}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Get\+Poll\+Mask@{my\+G\+P\+I\+O\+K\+\_\+\+Get\+Poll\+Mask}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Get\+Poll\+Mask@{my\+G\+P\+I\+O\+K\+\_\+\+Get\+Poll\+Mask}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Get\+Poll\+Mask}]{\setlength{\rightskip}{0pt plus 5cm}unsigned my\+G\+P\+I\+O\+K\+\_\+\+Get\+Poll\+Mask (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device, }
\item[{struct file $\ast$}]{file\+\_\+ptr, }
\item[{struct poll\+\_\+table\+\_\+struct $\ast$}]{wait}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_gae428f50a6da69e3cf89348b8ba9401b1}


Verifica che le operazioni di lettura/scrittura risultino non-\/bloccanti. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare \\
\hline
\mbox{\tt in,out}  & {\em file} & \\
\hline
\mbox{\tt in,out}  & {\em wait} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
restituisce una maschera di bit che indica se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili.
\end{DoxyReturn}
Questo metodo è il back-\/end di tre diverse system-\/calls\+: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno. \hypertarget{group__my_g_p_i_o_k__t_gace0d81f5ec65978f22118a3f1fc8b222}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable@{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable@{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable}]{\setlength{\rightskip}{0pt plus 5cm}void my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Disable (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_gace0d81f5ec65978f22118a3f1fc8b222}


Disabilita gli interrupt globali;. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare \\
\hline
\end{DoxyParams}
\hypertarget{group__my_g_p_i_o_k__t_ga00a24f28b49c71aaa91f66be71a3895b}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable@{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable@{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable}]{\setlength{\rightskip}{0pt plus 5cm}void my\+G\+P\+I\+O\+K\+\_\+\+Global\+Interrupt\+Enable (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_ga00a24f28b49c71aaa91f66be71a3895b}


Abilita gli interrupt globali;. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare \\
\hline
\end{DoxyParams}
\hypertarget{group__my_g_p_i_o_k__t_ga5a7df448de9de94620ce1baf7ec388c9}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Increment\+Total@{my\+G\+P\+I\+O\+K\+\_\+\+Increment\+Total}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Increment\+Total@{my\+G\+P\+I\+O\+K\+\_\+\+Increment\+Total}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Increment\+Total}]{\setlength{\rightskip}{0pt plus 5cm}void my\+G\+P\+I\+O\+K\+\_\+\+Increment\+Total (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_ga5a7df448de9de94620ce1baf7ec388c9}


Incrementa il contatore degli interrupt per un particolare device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare\\
\hline
\end{DoxyParams}
\subparagraph*{Incremento del numero totale di interrupt}

Dopo aver settato il flag, viene incrementato il valore degli interrupt totali. Anche questa operazione viene effettuata in mutua esclusione. \hypertarget{group__my_g_p_i_o_k__t_ga64afb2eff1f990814d792349842c522d}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Init@{my\+G\+P\+I\+O\+K\+\_\+\+Init}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Init@{my\+G\+P\+I\+O\+K\+\_\+\+Init}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Init}]{\setlength{\rightskip}{0pt plus 5cm}int my\+G\+P\+I\+O\+K\+\_\+\+Init (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{my\+G\+P\+I\+O\+K\+\_\+device, }
\item[{struct module $\ast$}]{owner, }
\item[{struct platform\+\_\+device $\ast$}]{op, }
\item[{struct class $\ast$}]{class, }
\item[{const char $\ast$}]{driver\+\_\+name, }
\item[{const char $\ast$}]{device\+\_\+name, }
\item[{uint32\+\_\+t}]{serial, }
\item[{struct file\+\_\+operations $\ast$}]{f\+\_\+ops, }
\item[{irq\+\_\+handler\+\_\+t}]{irq\+\_\+handler, }
\item[{uint32\+\_\+t}]{irq\+\_\+mask}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_ga64afb2eff1f990814d792349842c522d}


Inizializza una struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} e configura il device corrispondente. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em my\+G\+P\+I\+O\+K\+\_\+device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare \\
\hline
\mbox{\tt in}  & {\em owner} & puntatore a struttura struct module, proprietario del device (T\+H\+I\+S\+\_\+\+M\+O\+D\+U\+L\+E) \\
\hline
\mbox{\tt in}  & {\em op} & puntatore a struct platform\+\_\+device, costituito dal parametro \char`\"{}op\char`\"{} con cui viene invocata probe() o la remove() \\
\hline
\mbox{\tt in}  & {\em class} & puntatore a struct class, classe del device, deve essere stata precedentemente creata con class\+\_\+create() \\
\hline
\mbox{\tt in}  & {\em driver\+\_\+name} & nome del driver \\
\hline
\mbox{\tt in}  & {\em device\+\_\+name} & nome del device \\
\hline
\mbox{\tt in}  & {\em serial} & numero seriale del device \\
\hline
\mbox{\tt in}  & {\em f\+\_\+ops} & puntatore a struttura struct file\+\_\+operations, specifica le funzioni che agiscono sul device \\
\hline
\mbox{\tt in}  & {\em irq\+\_\+handler} & puntatore irq\+\_\+handler\+\_\+t alla funzione che gestirà gli interrupt generati dal device \\
\hline
\mbox{\tt in}  & {\em irq\+\_\+mask} & maschera delle interruzioni del device\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Valori di ritorno}
{\em 0} & se non si è verificato nessun errore \\
\hline
\end{DoxyRetVals}
\subparagraph*{Major-\/number e Minor-\/number}

Ai device drivers sono associati un major-\/number ed un minor-\/number. Il major-\/number viene usato dal kernel per identificare il driver corretto corrispondente ad uno specifico device, quando si effettuano operazioni su di esso. Il ruolo del minor number dipende dal device e viene gestito internamente dal driver. Questo driver, così come molti altri, usa il Major ed il minor number per distinguere le diverse istanze di device my\+G\+P\+I\+O che usano il device-\/driver my\+G\+P\+I\+O\+K. La registrazione di un device driver può essere effettuata chiamando {\bfseries alloc\+\_\+chrdev\+\_\+region()}, la quale alloca un char-\/device numbers. Il major number viene scelto dinamicamente e restituito dalla funzione attraverso il parametro dev. La funzione restituisce un valore negativo nel caso in cui si verifichino errori, 0 altrimenti. 
\begin{DoxyCode}
1 int alloc\_chrdev\_region (dev\_t * dev, unsigned baseminor, unsigned count, const char *name);
\end{DoxyCode}

\begin{DoxyItemize}
\item dev\+: major e minor number
\item baseminor\+: primo dei minor number richiesti
\item count\+: numero di minornumber richiesti
\item name\+: nome del device
\end{DoxyItemize}

\subparagraph*{Operatori}

Essendo un device \char`\"{}visto\char`\"{} come un file, ogni device driver deve implementare tutte le system-\/call previste per l'interfacciamento con un file. La corrispondenza tra la system-\/call e la funzione fornita dal driver viene stabilita attraverso la struttura file\+\_\+operations. La struttura dati file\+\_\+operations, definita in $<$linux/fs.\+h$>$ mantiene puntatori a funzioni definite dal driver che consentono di definire il comportamento degli operatori che agiscono su un file. 
\begin{DoxyCode}
1 static struct file\_operations myGPIO\_fops = \{
2     .owner      = THIS\_MODULE,
3     .llseek     = driver\_seek,
4     .read       = driver\_read,
5     .write      = driver\_write,
6     .poll       = driver\_poll,
7     .open       = driver\_open,
8     .release    = driver\_release
9 \};
\end{DoxyCode}
 Ogni campo della struttura deve puntare ad una funzione del driver che implementa uno specifico \char`\"{}operatore\char`\"{} su file, oppure impostata a N\+U\+L\+L se l'operatore non è supportato. L'esatto comportamento del kernel, quando uno dei puntatori è N\+U\+L\+L, varia da funzione a funzione. La lista seguente introduce tutti gli operatori che un'applicazione può invocare su un device. La lista è stata mantenuta snella, includendo solo i campi strettamente necessari.


\begin{DoxyItemize}
\item {\itshape struct module $\ast$owner} \+:~\newline
 il primo campo della struttura non è un operatore, ma un puntatore al modulo che \char`\"{}possiede\char`\"{} la struttura. Il campo ha lo scopo di evitare che il modulo venga rimosso dal kernel quando uno degli operatori è in uso. Viene inizializzato usando la macro T\+H\+I\+S\+\_\+\+M\+O\+D\+U\+L\+E, definita in $<$linux/module.\+h$>$.
\item {\itshape loff\+\_\+t ($\ast$llseek) (struct file $\ast$, loff\+\_\+t, int)} \+: il campo llseek è usato per cambiare la posizione della \char`\"{}testina\char`\"{} di lettura/ scrittura in un file. La funzione restituisce la nuova posizione della testina. loff\+\_\+t è un intero a 64 bit (anche su architetture a 32 bit). Eventuali errori vengono segnalati con un valore di ritorno negativo. Se questo campo è posto a N\+U\+L\+L, eventuali chiamate a seek modifigheranno la posizione della testina in un modo impredicibile.
\item {\itshape ssize\+\_\+t ($\ast$read) (struct file $\ast$, char \+\_\+ \+\_\+user $\ast$, size\+\_\+t, loff\+\_\+t $\ast$)} \+:~\newline
 usata per leggere dati dal device. Se lasciato a N\+U\+L\+L, ogni chiamata a read fallirà e non sarà possibile leggere dal device. La funzione restituisce il numero di byte letti con successo ma, nel caso si verifichi un errore, restituisce un numero intero negativo.
\item {\itshape ssize\+\_\+t ($\ast$write) (struct file $\ast$, const char \+\_\+ \+\_\+user $\ast$, size\+\_\+t, loff\+\_\+t $\ast$)} \+:~\newline
 invia dati al device. Se N\+U\+L\+L ogni chiamata alla system-\/call write causerà un errore. Il valore di ritorno, se non negativo, rappresenta il numero di byte correttamente scritti.
\item {\itshape unsigned int ($\ast$poll) (struct file $\ast$, struct poll\+\_\+table\+\_\+struct $\ast$)} \+:~\newline
 questo metodo è il back-\/end di tre diverse system-\/calls\+: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno. La funzione dovrebbe restituire una maschera che indichi se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili. Se viene lasciata N\+U\+L\+L si intende che le operazioni di lettura/scrittura sul device siano sempre non-\/bloccanti.
\item {\itshape int ($\ast$open) (struct inode $\ast$, struct file $\ast$)} \+:~\newline
 Anche se, di solito, è la prima operazione che si effettua su un file, non è strettamente necessaria la sua implementazione. Se lasciata N\+U\+L\+L, l'apertura del device andrà comunque a buon fine, ma al driver non verrà inviata alcuna notifica.
\item {\itshape int ($\ast$release) (struct inode $\ast$, struct file $\ast$)} \+:~\newline
 questo operatore viene invocato quando il file viene rilasciato. Come open, può essere lasciato N\+U\+L\+L.
\end{DoxyItemize}

L'inizializzazione di un device a caratteri passa anche attraverso la definizione di questo tipo di operatori. Essi possono essere impostati attraverso l'uso della funzione 
\begin{DoxyCode}
1 void cdev\_init (struct cdev *cdev, const struct file\_operations *fops);
\end{DoxyCode}
 la quale prende, come parametri
\begin{DoxyItemize}
\item cdev\+: puntatore a struttura cdev da inizializzare;
\item fops\+: puntatore a struttura file\+\_\+operation con cui inizializzare il device.
\end{DoxyItemize}

\subparagraph*{Creazione del device}

Il passo successivo è la registrazione del device e la sua aggiunta al filesystem. Tale operazione può essere effettuata chiamando 
\begin{DoxyCode}
1 struct device * device\_create( struct class *class, struct device *parent, dev\_t devt, const char *fmt,
       ...)
\end{DoxyCode}

\begin{DoxyItemize}
\item class\+: puntatore alla struttura class alla quale il device deve essere registrato
\item parent\+: puntatore ad eventuale device parent
\item devt\+: tmajor number
\item fmt\+: nome del device.
\end{DoxyItemize}

La funzione pù essere usata solo sulla classe dei device a caratteri. Crea un device all'interno del filesystem, associandogli il major number preventivamente inizializzato. La funzione restituisce il puntatore alla struttura device creata all'interno del filesystem. Si noti che il puntatre alla struttura classes D\+E\+V\+E essere stato precedentemente creato attraverso una chiamata alla funzione {\itshape class\+\_\+create()}.

\subparagraph*{Aggiunta del device}

Il driver, a questo punto, è pronto per essere aggiunto. è possibile aggiungere il driver usando 
\begin{DoxyCode}
1 int cdev\_add (struct cdev *p, dev\_t dev, unsigned count);
\end{DoxyCode}
 La quale accetta come parametri
\begin{DoxyItemize}
\item p\+: puntatore a struttura cdev structure per il device
\item dev\+: device number (precedentemente inizializzato usando la funzione {\itshape alloc\+\_\+chrdev\+\_\+region()})
\item count\+: numero di minor-\/numbers richiesti per il device
\end{DoxyItemize}

La funzione restituisce un numero negativo in caso di errore.

\subparagraph*{Accedere al segmento di memoria a cui la periferica è mappata}

Un driver, tipicamente, prende possesso del segmento di memoria cui è mappato il device con la funzione di probe. Il problema è che il device è mappato ad un indirizzo di memoria fisico ed il Kernel, così come qualsiasi altro programma, lavora su indirizzi di memoria virtuali. La funzione


\begin{DoxyCode}
1 int of\_address\_to\_resource(struct device\_node *node, int index, struct resource *r);
\end{DoxyCode}


popola una struttura resource con l'indirizzo di memoria cui è mapato il device usando le informazioni contenute all'interno del device tree. Ad esempio, se il device tree contiene 
\begin{DoxyCode}
1 reg = <0x41200000 0x10000>;
\end{DoxyCode}
 signidifa che l'indirizzo fisico associato al device è l'indirizzo 0x41200000, che al device sono riservati 0x10000 bytes. of\+\_\+address\+\_\+to\+\_\+resource() setterà res.\+start = 0x41200000 e res.\+end = 0x4120ffff.

\subparagraph*{Allocazione della memoria del device}

Le regioni di memoria per di I/\+O vanno allocate prima di poter essere usate. 
\begin{DoxyCode}
1 struct resource *request\_mem\_region(unsigned long start, unsigned long len, char *name);
\end{DoxyCode}
 Questa funzione alloca una regione di memoria di len byte a partire da start restituendone l'indirizzo, mentre nel caso in cui si verifichi un errore viene restituito N\+U\+L\+L. La funzione viene chiamata per ottenere l'accesso esclusivo della regione di memoria, per evitare che driver diversi tentino di accedere allo stesso spazio di memoria.

\subparagraph*{Remapping}

L'allocazione dello spazio di memoria non è l'unico step da eseguire prima che tale memoria possa essere usata. è necessario fare in modo che sia resa accessibile al kernel attraverso un mapping, usando la funzione. 
\begin{DoxyCode}
1 void *ioremap(unsigned long phys\_addr, unsigned long size);
\end{DoxyCode}


\subparagraph*{Registrazione di un interrupt-\/handler}

Il modulo deve registrare un handler per gli interrupt. L'handler deve essere compatibile con il tipo puntatore a funzione irq\+\_\+handler\+\_\+t, così definito. 
\begin{DoxyCode}
1 struct irqreturn\_t (*irq\_handler\_t)(int irq, struct pt\_regs * regs);
\end{DoxyCode}
 Il modulo definisce la funzione \hyperlink{group___linux-_driver_ga2fc230a12a97aa63e43b2dc4aec73511}{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler()}. L'handler può essere registrato usando 
\begin{DoxyCode}
1 int request\_irq(    unsigned int irqNumber,
2                     irqreturn\_t (*handler)(int, void *, struct pt\_regs *),
3                     unsigned long irqflags,
4                     const char *devname,
5                     void *dev\_id);
\end{DoxyCode}
 I\+L parametro irq\+Number può essere determinato automaticamente usando la funzione 
\begin{DoxyCode}
1 unsigned int irq\_of\_parse\_and\_map(struct device\_node *node, int index);
\end{DoxyCode}
 La funzione irq\+\_\+of\+\_\+parse\+\_\+and\+\_\+map() effettua un looks-\/up nella specifica degli interrupt all'interno del device tree e restituisce un irq number così come de lo aspetta request\+\_\+irq() (cioè compaci con l'enumerazione in /proc/interrupts). Il secondo argomento della funzione è, tipicamente, zero, ad indicare che, all'interno del device tree, verrà preso in considerazione soltanto il primo degli interrupt specificate. Il device tree, nella sezione dedicata al gpio,reca 
\begin{DoxyCode}
1 interrupts = <0 29 4>;
\end{DoxyCode}
 Il primo numero (0) è un flag che indica se l'interrupt sia connesso ad una line S\+P\+I (shared peripheral interrupt). Un valore diverso da zero indica che la linea è S\+P\+I. Il secondo numero si riferisce all'interrupt number. Per farla breve, quando si definisce la parte hardware, in questo specifico esempio il device G\+P\+I\+O è connesso alla linea 61 del G\+I\+C. Sottraendo 32 si orriene 29. Il terzo numero si riferisce alla tipologia dell'interrupt. Sono possibili tre valori\+:
\begin{DoxyItemize}
\item 0 \+: power-\/up default
\item 1 \+: rising-\/edge
\item 4 \+: a livelli, active alto
\end{DoxyItemize}

\subparagraph*{Inizializzazione della wait-\/queue per la system-\/call read() e poll()}

In linux una wait queue viene implementata da una struttura dati wait\+\_\+queue\+\_\+head\+\_\+t, definita in $<$linux/wait.\+h$>$. Il driver in questione prevede due wait-\/queue differenti\+: una per la system-\/call read() ed una per la system-\/call poll(). Entrambe le code vengono inizializzate dalla funzione \hyperlink{group___linux-_driver_gae40973a06d72f7c41a9af07513a62307}{my\+G\+P\+I\+O\+K\+\_\+probe()}. 
\begin{DoxyCode}
1 init\_waitqueue\_head(&my\_queue);
\end{DoxyCode}
 Si veda la documentazione della funzione \hyperlink{group___linux-_driver_ga90ac339df9c02ae5f11a2a7727adc923}{my\+G\+P\+I\+O\+K\+\_\+read()} per dettagli ulteriori.

\subparagraph*{Inizializzazione degli spinlock}

I semafori sono uno strumento potentissimo per per l'implementazione di sezioni critiche, ma non possono essere usati in codice non interrompibile. Gli spilock sono come i semafori, ma possono essere usati anche in codice non interrompibile, come può esserlo un modulo kernel. Sostanzialmente se uno spinlock è già stato acquisito da qualcun altro, si entra in un hot-\/loop dal quale si esce solo quando chi possiede lo spinlock lo rilascia. Trattandosi di moduli kernel, è di vitale importanza che la sezione critica sia quanto più piccola possibile. Ovviamente l'implementazione è \char`\"{}un pò\char`\"{} più complessa di come è stata descritta, ma il concetto è questo. Gli spinlock sono definiti in $<$linux/spinlock.\+h$>$. L'inizializzazione di uno spinlock avviene usando la funzione 
\begin{DoxyCode}
1 void spin\_lock\_init(spinlock\_t *lock);
\end{DoxyCode}


\subparagraph*{Abilitazione degli interrupt del device}

A seconda del valore C\+F\+L\+A\+G\+S\+\_\+my\+G\+P\+I\+O\+K.\+o (si veda il Makefile a corredo), vengono abilitati gli interrupt della periferica. Se si tratta del G\+P\+I\+O Xilinx vengono abilitati gli interrupt globali e gli interrupt sul canale due. Se si tratta del device G\+P\+I\+O custom, essendo esso parecchio più semplice, è necessario abilitare solo gli interrupt globali.\hypertarget{group__my_g_p_i_o_k__t_ga1b3ad44b9198f537493180d748de0b6c}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt@{my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt@{my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt}]{\setlength{\rightskip}{0pt plus 5cm}unsigned my\+G\+P\+I\+O\+K\+\_\+\+Pending\+Pin\+Interrupt (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_ga1b3ad44b9198f537493180d748de0b6c}


Consente di ottenere una maschera che indichi quali interrupt non siano stati ancora serviti;. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
maschera che riporta i pin per i quali gli interrupt non sono stati ancora serviti; 
\end{DoxyReturn}
\hypertarget{group__my_g_p_i_o_k__t_ga8eaf8f1b21aa6f772c395faf457144f9}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack}]{\setlength{\rightskip}{0pt plus 5cm}void my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Ack (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device, }
\item[{unsigned}]{mask}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_ga8eaf8f1b21aa6f772c395faf457144f9}


Invia al device notifica di servizio di un interrupt;. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare\\
\hline
\mbox{\tt in}  & {\em mask} & mask maschera di selezione degli interrupt da notificare; quelli non selezionati non vengono notificati; \\
\hline
\end{DoxyParams}
\hypertarget{group__my_g_p_i_o_k__t_gabfd91641f98a4725aec779c8834ca92d}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable}]{\setlength{\rightskip}{0pt plus 5cm}void my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Disable (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device, }
\item[{unsigned}]{mask}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_gabfd91641f98a4725aec779c8834ca92d}


Disabilita gli interrupt per i singoli pin del device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare\\
\hline
\mbox{\tt in}  & {\em mask} & maschera di selezione degli interrupt da disabilitare; quelli non selezionati non vengono disabilitati; \\
\hline
\end{DoxyParams}
\hypertarget{group__my_g_p_i_o_k__t_ga179c20f5f62e8ce1593cbedff2f00533}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable@{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable}]{\setlength{\rightskip}{0pt plus 5cm}void my\+G\+P\+I\+O\+K\+\_\+\+Pin\+Interrupt\+Enable (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device, }
\item[{unsigned}]{mask}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_ga179c20f5f62e8ce1593cbedff2f00533}


Abilita gli interrupt per i singoli pin del device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare \\
\hline
\mbox{\tt in}  & {\em mask} & maschera di selezione degli interrupt da abilitare; quelli non selezionati non vengono abilitati; \\
\hline
\end{DoxyParams}
\hypertarget{group__my_g_p_i_o_k__t_ga6dc0ec06b388522ffc524e5fd14d8b72}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Reset\+Can\+Read@{my\+G\+P\+I\+O\+K\+\_\+\+Reset\+Can\+Read}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Reset\+Can\+Read@{my\+G\+P\+I\+O\+K\+\_\+\+Reset\+Can\+Read}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Reset\+Can\+Read}]{\setlength{\rightskip}{0pt plus 5cm}void my\+G\+P\+I\+O\+K\+\_\+\+Reset\+Can\+Read (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_ga6dc0ec06b388522ffc524e5fd14d8b72}


Reset del flag \char`\"{}interrupt occurred\char`\"{} (can\+Read) 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare\\
\hline
\end{DoxyParams}
\subparagraph*{Reset del flag \char`\"{}interrupt occurred\char`\"{} per read() bloccanti}

Nel momento in cui il processo viene risvegliato e la condizione della quale era in attesa è tale che esso può continuare la sua esecuzione, è necessario resettare tale flag. Questa operazione va effettuata per prevenire race-\/condition dovute al risveglio di più processi in attesa del manifestarsi dello stesso evento. Il reset del flag va, pertanto, effettuato in mutua esclusione.

I semafori sono uno strumento potentissimo per per l'implementazione di sezioni critiche, ma non possono essere usati in codice non interrompibile. Gli spilock sono come i semafori, ma possono essere usati anche in codice non interrompibile, come può esserlo un modulo kernel. Sostanzialmente se uno spinlock è già stato acquisito da qualcun altro, si entra in un hot-\/loop dal quale si esce solo quando chi possiede lo spinlock lo rilascia. Trattandosi di moduli kernel, è di vitale importanza che la sezione critica sia quanto più piccola possibile. Ovviamente l'implementazione è \char`\"{}un pò\char`\"{} più complessa di come è stata descritta, ma il concetto è questo. Gli spinlock sono definiti in $<$linux/spinlock.\+h$>$. Esistono diversi modi per acquisire uno spinlock. Nel seguito viene usata la funzione 
\begin{DoxyCode}
1 void spin\_lock(spinlock\_t *lock);
\end{DoxyCode}
 per rilasciare uno spinlock, invece, verrà usata 
\begin{DoxyCode}
1 void spin\_unlock(spinlock\_t *lock);
\end{DoxyCode}
 \hypertarget{group__my_g_p_i_o_k__t_gad82c1051e6acb335b1b26ab0c459453b}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Set\+Can\+Read@{my\+G\+P\+I\+O\+K\+\_\+\+Set\+Can\+Read}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Set\+Can\+Read@{my\+G\+P\+I\+O\+K\+\_\+\+Set\+Can\+Read}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Set\+Can\+Read}]{\setlength{\rightskip}{0pt plus 5cm}void my\+G\+P\+I\+O\+K\+\_\+\+Set\+Can\+Read (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_gad82c1051e6acb335b1b26ab0c459453b}


Set del flag \char`\"{}interrupt occurred\char`\"{} (can\+Read) 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare\\
\hline
\end{DoxyParams}
\subparagraph*{Setting del valore del flag \char`\"{}interrupt occurred\char`\"{}}

Dopo aver disabilitato gli interrupt della periferica, occorre settare in modo appropriato il flag \char`\"{}interrupt occurred\char`\"{}, in modo che i processi in attesa possano essere risvegliati in modo sicuro. Per prevenire race condition, tale operazione viene effettuata mutua esclusione. I semafori sono uno strumento potentissimo per per l'implementazione di sezioni critiche, ma non possono essere usati in codice non interrompibile. Gli spilock sono come i semafori, ma possono essere usati anche in codice non interrompibile, come può esserlo un modulo kernel. Sostanzialmente se uno spinlock è già stato acquisito da qualcun altro, si entra in un hot-\/loop dal quale si esce solo quando chi possiede lo spinlock lo rilascia. Trattandosi di moduli kernel, è di vitale importanza che la sezione critica sia quanto più piccola possibile. Ovviamente l'implementazione è \char`\"{}un pò\char`\"{} più complessa di come è stata descritta, ma il concetto è questo. Gli spinlock sono definiti in $<$linux/spinlock.\+h$>$. Esistono diversi modi per acquisire uno spinlock. Nel seguito viene usata la funzione 
\begin{DoxyCode}
1 void spin\_lock\_irqsave(spinlock\_t *lock, unsigned long flags);
\end{DoxyCode}
 la quale disabilita gli interrupt sul processore locale prima di acquisire lo spinlock, per poi ripristinarlo quando lo spinlock viene rilasciato, usando 
\begin{DoxyCode}
1 void spin\_unlock\_irqrestore(spinlock\_t *lock, unsigned long flags);
\end{DoxyCode}
 \hypertarget{group__my_g_p_i_o_k__t_gaf1b6f35c097c46361d675a42f122828e}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Test\+Can\+Read\+And\+Sleep@{my\+G\+P\+I\+O\+K\+\_\+\+Test\+Can\+Read\+And\+Sleep}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Test\+Can\+Read\+And\+Sleep@{my\+G\+P\+I\+O\+K\+\_\+\+Test\+Can\+Read\+And\+Sleep}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Test\+Can\+Read\+And\+Sleep}]{\setlength{\rightskip}{0pt plus 5cm}void my\+G\+P\+I\+O\+K\+\_\+\+Test\+Can\+Read\+And\+Sleep (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_gaf1b6f35c097c46361d675a42f122828e}


Testa la condizione \char`\"{}interrupt occurred\char`\"{}, mettendo in attesa il processo, se necessario. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare\\
\hline
\end{DoxyParams}
\subparagraph*{Porre un processo nello stato sleeping}

Quando un processo viene messo nello stato sleep, lo si fa aspettandosi che una condizione diventi vera in futuro. Al risveglio, però, non c'è nessuna garanzia che quella particolare condizione sia ancora vera, per cui essa va nuovamente testata. Il modo più semplice per potte un processo nello stato sleeping è chiamare la macro wait\+\_\+event(), o una delle sue varianti\+: essa combina la gestione della messa in sleeping del processo ed il check della condizione che il processo si aspetta diventi vera. 
\begin{DoxyCode}
1 wait\_event\_interruptible(queue, condition);
\end{DoxyCode}
 Il parametro queue è la coda di attesa mentre condition è la condizione che, valutata true, causa la messa in sleep del processo. La condizione viene valutata sia prima che il processo sia messo in sleeping che al suo risveglio. Lo sleep in cui il processo viene messo chiamando wait\+\_\+event\+\_\+interruptible() può essere interrotto anche da un segnale, per cui la macro restituisce un intero che, se diverso da zero, indica che il processo è stato risvegliato da un segnale.

La condizione sulla quale i processi vengono bloccati riguarda il flag \char`\"{}interrupt occurred\char`\"{}. Fin quando questo flag, posto in and con la maschera M\+Y\+G\+P\+I\+O\+K\+\_\+\+S\+R\+E\+A\+D, è zero, il processo deve restare bloccato, per cui i processi che effettuano read() bloccante restano bloccati finché int\+\_\+occurred \& M\+Y\+G\+P\+I\+O\+\_\+\+S\+R\+E\+A\+D == 0. Quando tale uguaglianza non sarà più valida, perché il valore di int\+\_\+occurred viene settato dalla funzione \hyperlink{group___linux-_driver_ga2fc230a12a97aa63e43b2dc4aec73511}{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler()}, allora il processo verrà risvegliato. \hypertarget{group__my_g_p_i_o_k__t_gae182aa943af08c102a05795ae8526192}{\index{My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}!my\+G\+P\+I\+O\+K\+\_\+\+Wake\+Up@{my\+G\+P\+I\+O\+K\+\_\+\+Wake\+Up}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Wake\+Up@{my\+G\+P\+I\+O\+K\+\_\+\+Wake\+Up}!My\+G\+P\+I\+O\+K\+\_\+t@{My\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Wake\+Up}]{\setlength{\rightskip}{0pt plus 5cm}void my\+G\+P\+I\+O\+K\+\_\+\+Wake\+Up (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+t} $\ast$}]{device}
\end{DoxyParamCaption}
)}}\label{group__my_g_p_i_o_k__t_gae182aa943af08c102a05795ae8526192}


Risveglia i process in attesa sulle code di read e poll. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em device} & puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che si riferisce al device su cui operare\\
\hline
\end{DoxyParams}
\subparagraph*{Wakeup dei processi sleeping}

La I\+S\+R deve chiamare esplicitamente wakeup() per risvegliare i processi messi in sleeping in attesa che un particolare evento si manifestasse. La funzione 
\begin{DoxyCode}
1 void wake\_up\_interruptible(wait\_queue\_head\_t *queue);
\end{DoxyCode}
 risveglia tutti i processi posti in una determinata coda (risvegliando solo quelli che, in precedenza, hanno effettuato una chiamata a wait\+\_\+event\+\_\+interruptible()). Se due processi vengono risvegliati contemporaneamente potrebbero originarsi race-\/condition. 