<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Zynq-7000 Driver Pack: MyGPIOK_t</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Zynq-7000 Driver Pack
   &#160;<span id="projectnumber">3.2</span>
   </div>
   <div id="projectbrief">Implementazione C di device-driver per Xilinx Zynq-7000</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Cerca');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Pagina&#160;Principale</span></a></li>
      <li><a href="modules.html"><span>Moduli</span></a></li>
      <li><a href="annotated.html"><span>Strutture&#160;dati</span></a></li>
      <li><a href="files.html"><span>File</span></a></li>
      <li><a href="examples.html"><span>Esempi</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Cerca" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__my_g_p_i_o_k__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Tutto</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Strutture dati</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>File</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Funzioni</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variabili</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Tipi enumerati (enum)</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Valori del tipo enumerato</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Definizioni</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Gruppi</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Strutture dati</a> &#124;
<a href="#define-members">Definizioni</a> &#124;
<a href="#func-members">Funzioni</a>  </div>
  <div class="headertitle">
<div class="title">MyGPIOK_t<div class="ingroups"><a class="el" href="group__my_g_p_i_o.html">MyGPIO</a> &raquo; <a class="el" href="group___linux-_driver.html">Linux-Driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Definisce l'oggetto <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che rappresenta un device myGPIO a livello kernel.  
<a href="#details">Continua...</a></p>
<div class="dynheader">
Diagramma di collaborazione per MyGPIOK_t:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__my_g_p_i_o_k__t.png" border="0" alt="" usemap="#group____my__g__p__i__o__k____t"/>
<map name="group____my__g__p__i__o__k____t" id="group____my__g__p__i__o__k____t">
<area shape="rect" id="node1" href="group___linux-_driver.html" title="Device&#45;driver in kernel&#45;mode per myGPIO. " alt="" coords="5,5,97,32"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Strutture dati</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stuttura per l'astrazione di un device myGPIO in kernel-mode.  <a href="structmy_g_p_i_o_k__t.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Definizioni</h2></td></tr>
<tr class="memitem:ga0da2526ca3cd1a94ebcecf96778ea2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga0da2526ca3cd1a94ebcecf96778ea2e5">myGPIOK_GIES_OFFSET</a>&#160;&#160;&#160;0x0CU</td></tr>
<tr class="memdesc:ga0da2526ca3cd1a94ebcecf96778ea2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset, rispetto all'indirizzo base, del registro "GIES".  <a href="#ga0da2526ca3cd1a94ebcecf96778ea2e5">Continua...</a><br /></td></tr>
<tr class="separator:ga0da2526ca3cd1a94ebcecf96778ea2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed7646e6f910f5803477e51b7fe26e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga2ed7646e6f910f5803477e51b7fe26e3">myGPIOK_PIE_OFFSET</a>&#160;&#160;&#160;0x10U</td></tr>
<tr class="memdesc:ga2ed7646e6f910f5803477e51b7fe26e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset, rispetto all'indirizzo base, del registro "PIE".  <a href="#ga2ed7646e6f910f5803477e51b7fe26e3">Continua...</a><br /></td></tr>
<tr class="separator:ga2ed7646e6f910f5803477e51b7fe26e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ee502d1ba364dfde9261c4f7a537a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga37ee502d1ba364dfde9261c4f7a537a6">myGPIOK_IRQ_OFFSET</a>&#160;&#160;&#160;0x14U</td></tr>
<tr class="memdesc:ga37ee502d1ba364dfde9261c4f7a537a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset, rispetto all'indirizzo base, del registro "IRQ".  <a href="#ga37ee502d1ba364dfde9261c4f7a537a6">Continua...</a><br /></td></tr>
<tr class="separator:ga37ee502d1ba364dfde9261c4f7a537a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac72408c288009c213c0231973b3fe761"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#gac72408c288009c213c0231973b3fe761">myGPIOK_IACK_OFFSET</a>&#160;&#160;&#160;0x18U</td></tr>
<tr class="memdesc:gac72408c288009c213c0231973b3fe761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset, rispetto all'indirizzo base, del registro "IACK".  <a href="#gac72408c288009c213c0231973b3fe761">Continua...</a><br /></td></tr>
<tr class="separator:gac72408c288009c213c0231973b3fe761"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funzioni</h2></td></tr>
<tr class="memitem:ga64afb2eff1f990814d792349842c522d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga64afb2eff1f990814d792349842c522d">myGPIOK_Init</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *myGPIOK_device, struct module *owner, struct platform_device *op, struct class *class, const char *driver_name, const char *device_name, uint32_t serial, struct file_operations *f_ops, irq_handler_t irq_handler, uint32_t irq_mask)</td></tr>
<tr class="memdesc:ga64afb2eff1f990814d792349842c522d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inizializza una struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a> e configura il device corrispondente.  <a href="#ga64afb2eff1f990814d792349842c522d">Continua...</a><br /></td></tr>
<tr class="separator:ga64afb2eff1f990814d792349842c522d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24255b79dd8549aa655cf28c1f9a65d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga24255b79dd8549aa655cf28c1f9a65d5">myGPIOK_Destroy</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *device)</td></tr>
<tr class="memdesc:ga24255b79dd8549aa655cf28c1f9a65d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinizializza un device, rimuovendo le strutture kernel allocate per il suo funzionamento.  <a href="#ga24255b79dd8549aa655cf28c1f9a65d5">Continua...</a><br /></td></tr>
<tr class="separator:ga24255b79dd8549aa655cf28c1f9a65d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82c1051e6acb335b1b26ab0c459453b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#gad82c1051e6acb335b1b26ab0c459453b">myGPIOK_SetCanRead</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *device)</td></tr>
<tr class="memdesc:gad82c1051e6acb335b1b26ab0c459453b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set del flag "interrupt occurred" (canRead)  <a href="#gad82c1051e6acb335b1b26ab0c459453b">Continua...</a><br /></td></tr>
<tr class="separator:gad82c1051e6acb335b1b26ab0c459453b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc0ec06b388522ffc524e5fd14d8b72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga6dc0ec06b388522ffc524e5fd14d8b72">myGPIOK_ResetCanRead</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *device)</td></tr>
<tr class="memdesc:ga6dc0ec06b388522ffc524e5fd14d8b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset del flag "interrupt occurred" (canRead)  <a href="#ga6dc0ec06b388522ffc524e5fd14d8b72">Continua...</a><br /></td></tr>
<tr class="separator:ga6dc0ec06b388522ffc524e5fd14d8b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b6f35c097c46361d675a42f122828e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#gaf1b6f35c097c46361d675a42f122828e">myGPIOK_TestCanReadAndSleep</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *device)</td></tr>
<tr class="memdesc:gaf1b6f35c097c46361d675a42f122828e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Testa la condizione "interrupt occurred", mettendo in attesa il processo, se necessario.  <a href="#gaf1b6f35c097c46361d675a42f122828e">Continua...</a><br /></td></tr>
<tr class="separator:gaf1b6f35c097c46361d675a42f122828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae428f50a6da69e3cf89348b8ba9401b1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#gae428f50a6da69e3cf89348b8ba9401b1">myGPIOK_GetPollMask</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *device, struct file *file_ptr, struct poll_table_struct *wait)</td></tr>
<tr class="memdesc:gae428f50a6da69e3cf89348b8ba9401b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica che le operazioni di lettura/scrittura risultino non-bloccanti.  <a href="#gae428f50a6da69e3cf89348b8ba9401b1">Continua...</a><br /></td></tr>
<tr class="separator:gae428f50a6da69e3cf89348b8ba9401b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7df448de9de94620ce1baf7ec388c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga5a7df448de9de94620ce1baf7ec388c9">myGPIOK_IncrementTotal</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *device)</td></tr>
<tr class="memdesc:ga5a7df448de9de94620ce1baf7ec388c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incrementa il contatore degli interrupt per un particolare device.  <a href="#ga5a7df448de9de94620ce1baf7ec388c9">Continua...</a><br /></td></tr>
<tr class="separator:ga5a7df448de9de94620ce1baf7ec388c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae182aa943af08c102a05795ae8526192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#gae182aa943af08c102a05795ae8526192">myGPIOK_WakeUp</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *device)</td></tr>
<tr class="memdesc:gae182aa943af08c102a05795ae8526192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Risveglia i process in attesa sulle code di read e poll.  <a href="#gae182aa943af08c102a05795ae8526192">Continua...</a><br /></td></tr>
<tr class="separator:gae182aa943af08c102a05795ae8526192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga565ffd4946b330b29e1166dfc9851b11"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga565ffd4946b330b29e1166dfc9851b11">myGPIOK_GetDeviceAddress</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *device)</td></tr>
<tr class="memdesc:ga565ffd4946b330b29e1166dfc9851b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce l'indirizzo virtuale di memoria cui è mappato un device.  <a href="#ga565ffd4946b330b29e1166dfc9851b11">Continua...</a><br /></td></tr>
<tr class="separator:ga565ffd4946b330b29e1166dfc9851b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a24f28b49c71aaa91f66be71a3895b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga00a24f28b49c71aaa91f66be71a3895b">myGPIOK_GlobalInterruptEnable</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *myGPIOK_device)</td></tr>
<tr class="memdesc:ga00a24f28b49c71aaa91f66be71a3895b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abilita gli interrupt globali;.  <a href="#ga00a24f28b49c71aaa91f66be71a3895b">Continua...</a><br /></td></tr>
<tr class="separator:ga00a24f28b49c71aaa91f66be71a3895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0d81f5ec65978f22118a3f1fc8b222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#gace0d81f5ec65978f22118a3f1fc8b222">myGPIOK_GlobalInterruptDisable</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *myGPIOK_device)</td></tr>
<tr class="memdesc:gace0d81f5ec65978f22118a3f1fc8b222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disabilita gli interrupt globali;.  <a href="#gace0d81f5ec65978f22118a3f1fc8b222">Continua...</a><br /></td></tr>
<tr class="separator:gace0d81f5ec65978f22118a3f1fc8b222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga179c20f5f62e8ce1593cbedff2f00533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga179c20f5f62e8ce1593cbedff2f00533">myGPIOK_PinInterruptEnable</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *myGPIOK_device, unsigned mask)</td></tr>
<tr class="memdesc:ga179c20f5f62e8ce1593cbedff2f00533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abilita gli interrupt per i singoli pin del device.  <a href="#ga179c20f5f62e8ce1593cbedff2f00533">Continua...</a><br /></td></tr>
<tr class="separator:ga179c20f5f62e8ce1593cbedff2f00533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfd91641f98a4725aec779c8834ca92d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#gabfd91641f98a4725aec779c8834ca92d">myGPIOK_PinInterruptDisable</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *myGPIOK_device, unsigned mask)</td></tr>
<tr class="memdesc:gabfd91641f98a4725aec779c8834ca92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disabilita gli interrupt per i singoli pin del device.  <a href="#gabfd91641f98a4725aec779c8834ca92d">Continua...</a><br /></td></tr>
<tr class="separator:gabfd91641f98a4725aec779c8834ca92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b3ad44b9198f537493180d748de0b6c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga1b3ad44b9198f537493180d748de0b6c">myGPIOK_PendingPinInterrupt</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *myGPIOK_device)</td></tr>
<tr class="memdesc:ga1b3ad44b9198f537493180d748de0b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consente di ottenere una maschera che indichi quali interrupt non siano stati ancora serviti;.  <a href="#ga1b3ad44b9198f537493180d748de0b6c">Continua...</a><br /></td></tr>
<tr class="separator:ga1b3ad44b9198f537493180d748de0b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eaf8f1b21aa6f772c395faf457144f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__my_g_p_i_o_k__t.html#ga8eaf8f1b21aa6f772c395faf457144f9">myGPIOK_PinInterruptAck</a> (<a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *myGPIOK_device, unsigned mask)</td></tr>
<tr class="memdesc:ga8eaf8f1b21aa6f772c395faf457144f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invia al device notifica di servizio di un interrupt;.  <a href="#ga8eaf8f1b21aa6f772c395faf457144f9">Continua...</a><br /></td></tr>
<tr class="separator:ga8eaf8f1b21aa6f772c395faf457144f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrizione dettagliata</h2>
<p>Definisce l'oggetto <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che rappresenta un device myGPIO a livello kernel. </p>
<h2 class="groupheader">Documentazione delle definizioni</h2>
<a class="anchor" id="ga0da2526ca3cd1a94ebcecf96778ea2e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define myGPIOK_GIES_OFFSET&#160;&#160;&#160;0x0CU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset, rispetto all'indirizzo base, del registro "GIES". </p>

</div>
</div>
<a class="anchor" id="gac72408c288009c213c0231973b3fe761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define myGPIOK_IACK_OFFSET&#160;&#160;&#160;0x18U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset, rispetto all'indirizzo base, del registro "IACK". </p>

</div>
</div>
<a class="anchor" id="ga37ee502d1ba364dfde9261c4f7a537a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define myGPIOK_IRQ_OFFSET&#160;&#160;&#160;0x14U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset, rispetto all'indirizzo base, del registro "IRQ". </p>

</div>
</div>
<a class="anchor" id="ga2ed7646e6f910f5803477e51b7fe26e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define myGPIOK_PIE_OFFSET&#160;&#160;&#160;0x10U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset, rispetto all'indirizzo base, del registro "PIE". </p>

</div>
</div>
<h2 class="groupheader">Documentazione delle funzioni</h2>
<a class="anchor" id="ga24255b79dd8549aa655cf28c1f9a65d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myGPIOK_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinizializza un device, rimuovendo le strutture kernel allocate per il suo funzionamento. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, specifica il particolare device su cui agire </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga565ffd4946b330b29e1166dfc9851b11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* myGPIOK_GetDeviceAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restituisce l'indirizzo virtuale di memoria cui è mappato un device. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae428f50a6da69e3cf89348b8ba9401b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned myGPIOK_GetPollMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct poll_table_struct *&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifica che le operazioni di lettura/scrittura risultino non-bloccanti. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wait</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>restituisce una maschera di bit che indica se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili.</dd></dl>
<p>Questo metodo è il back-end di tre diverse system-calls: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno. </p>

</div>
</div>
<a class="anchor" id="gace0d81f5ec65978f22118a3f1fc8b222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myGPIOK_GlobalInterruptDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disabilita gli interrupt globali;. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00a24f28b49c71aaa91f66be71a3895b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myGPIOK_GlobalInterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abilita gli interrupt globali;. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5a7df448de9de94620ce1baf7ec388c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myGPIOK_IncrementTotal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incrementa il contatore degli interrupt per un particolare device. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare</td></tr>
  </table>
  </dd>
</dl>
<h5>Incremento del numero totale di interrupt</h5>
<p>Dopo aver settato il flag, viene incrementato il valore degli interrupt totali. Anche questa operazione viene effettuata in mutua esclusione. </p>

</div>
</div>
<a class="anchor" id="ga64afb2eff1f990814d792349842c522d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int myGPIOK_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>myGPIOK_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct module *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct platform_device *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct class *&#160;</td>
          <td class="paramname"><em>class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>driver_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>device_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct file_operations *&#160;</td>
          <td class="paramname"><em>f_ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irq_handler_t&#160;</td>
          <td class="paramname"><em>irq_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>irq_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inizializza una struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a> e configura il device corrispondente. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">myGPIOK_device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">owner</td><td>puntatore a struttura struct module, proprietario del device (THIS_MODULE) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>puntatore a struct platform_device, costituito dal parametro "op" con cui viene invocata probe() o la remove() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">class</td><td>puntatore a struct class, classe del device, deve essere stata precedentemente creata con class_create() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">driver_name</td><td>nome del driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device_name</td><td>nome del device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serial</td><td>numero seriale del device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_ops</td><td>puntatore a struttura struct file_operations, specifica le funzioni che agiscono sul device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">irq_handler</td><td>puntatore irq_handler_t alla funzione che gestirà gli interrupt generati dal device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">irq_mask</td><td>maschera delle interruzioni del device</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Valori di ritorno</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>se non si è verificato nessun errore </td></tr>
  </table>
  </dd>
</dl>
<h5>Major-number e Minor-number</h5>
<p>Ai device drivers sono associati un major-number ed un minor-number. Il major-number viene usato dal kernel per identificare il driver corretto corrispondente ad uno specifico device, quando si effettuano operazioni su di esso. Il ruolo del minor number dipende dal device e viene gestito internamente dal driver. Questo driver, così come molti altri, usa il Major ed il minor number per distinguere le diverse istanze di device myGPIO che usano il device-driver myGPIOK. La registrazione di un device driver può essere effettuata chiamando <b>alloc_chrdev_region()</b>, la quale alloca un char-device numbers. Il major number viene scelto dinamicamente e restituito dalla funzione attraverso il parametro dev. La funzione restituisce un valore negativo nel caso in cui si verifichino errori, 0 altrimenti. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int alloc_chrdev_region (dev_t * dev, unsigned baseminor, unsigned count, const char *name);</div>
</div><!-- fragment --><ul>
<li>dev: major e minor number</li>
<li>baseminor: primo dei minor number richiesti</li>
<li>count: numero di minornumber richiesti</li>
<li>name: nome del device</li>
</ul>
<h5>Operatori</h5>
<p>Essendo un device "visto" come un file, ogni device driver deve implementare tutte le system-call previste per l'interfacciamento con un file. La corrispondenza tra la system-call e la funzione fornita dal driver viene stabilita attraverso la struttura file_operations. La struttura dati file_operations, definita in &lt;linux/fs.h&gt; mantiene puntatori a funzioni definite dal driver che consentono di definire il comportamento degli operatori che agiscono su un file. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;static struct file_operations myGPIO_fops = {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    .owner      = THIS_MODULE,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    .llseek     = driver_seek,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    .read       = driver_read,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    .write      = driver_write,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    .poll       = driver_poll,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    .open       = driver_open,</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    .release    = driver_release</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;};</div>
</div><!-- fragment --><p> Ogni campo della struttura deve puntare ad una funzione del driver che implementa uno specifico "operatore" su file, oppure impostata a NULL se l'operatore non è supportato. L'esatto comportamento del kernel, quando uno dei puntatori è NULL, varia da funzione a funzione. La lista seguente introduce tutti gli operatori che un'applicazione può invocare su un device. La lista è stata mantenuta snella, includendo solo i campi strettamente necessari.</p>
<ul>
<li><em>struct module *owner</em> :<br />
 il primo campo della struttura non è un operatore, ma un puntatore al modulo che "possiede" la struttura. Il campo ha lo scopo di evitare che il modulo venga rimosso dal kernel quando uno degli operatori è in uso. Viene inizializzato usando la macro THIS_MODULE, definita in &lt;linux/module.h&gt;.</li>
<li><em>loff_t (*llseek) (struct file *, loff_t, int)</em> : il campo llseek è usato per cambiare la posizione della "testina" di lettura/ scrittura in un file. La funzione restituisce la nuova posizione della testina. loff_t è un intero a 64 bit (anche su architetture a 32 bit). Eventuali errori vengono segnalati con un valore di ritorno negativo. Se questo campo è posto a NULL, eventuali chiamate a seek modifigheranno la posizione della testina in un modo impredicibile.</li>
<li><em>ssize_t (*read) (struct file *, char _ _user *, size_t, loff_t *)</em> :<br />
 usata per leggere dati dal device. Se lasciato a NULL, ogni chiamata a read fallirà e non sarà possibile leggere dal device. La funzione restituisce il numero di byte letti con successo ma, nel caso si verifichi un errore, restituisce un numero intero negativo.</li>
<li><em>ssize_t (*write) (struct file *, const char _ _user *, size_t, loff_t *)</em> :<br />
 invia dati al device. Se NULL ogni chiamata alla system-call write causerà un errore. Il valore di ritorno, se non negativo, rappresenta il numero di byte correttamente scritti.</li>
<li><em>unsigned int (*poll) (struct file *, struct poll_table_struct *)</em> :<br />
 questo metodo è il back-end di tre diverse system-calls: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno. La funzione dovrebbe restituire una maschera che indichi se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili. Se viene lasciata NULL si intende che le operazioni di lettura/scrittura sul device siano sempre non-bloccanti.</li>
<li><em>int (*open) (struct inode *, struct file *)</em> :<br />
 Anche se, di solito, è la prima operazione che si effettua su un file, non è strettamente necessaria la sua implementazione. Se lasciata NULL, l'apertura del device andrà comunque a buon fine, ma al driver non verrà inviata alcuna notifica.</li>
<li><em>int (*release) (struct inode *, struct file *)</em> :<br />
 questo operatore viene invocato quando il file viene rilasciato. Come open, può essere lasciato NULL.</li>
</ul>
<p>L'inizializzazione di un device a caratteri passa anche attraverso la definizione di questo tipo di operatori. Essi possono essere impostati attraverso l'uso della funzione </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void cdev_init (struct cdev *cdev, const struct file_operations *fops);</div>
</div><!-- fragment --><p> la quale prende, come parametri</p><ul>
<li>cdev: puntatore a struttura cdev da inizializzare;</li>
<li>fops: puntatore a struttura file_operation con cui inizializzare il device.</li>
</ul>
<h5>Creazione del device</h5>
<p>Il passo successivo è la registrazione del device e la sua aggiunta al filesystem. Tale operazione può essere effettuata chiamando </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct device * device_create( struct class *class, struct device *parent, dev_t devt, const char *fmt, ...)</div>
</div><!-- fragment --><ul>
<li>class: puntatore alla struttura class alla quale il device deve essere registrato</li>
<li>parent: puntatore ad eventuale device parent</li>
<li>devt: tmajor number</li>
<li>fmt: nome del device.</li>
</ul>
<p>La funzione pù essere usata solo sulla classe dei device a caratteri. Crea un device all'interno del filesystem, associandogli il major number preventivamente inizializzato. La funzione restituisce il puntatore alla struttura device creata all'interno del filesystem. Si noti che il puntatre alla struttura classes DEVE essere stato precedentemente creato attraverso una chiamata alla funzione <em>class_create()</em>.</p>
<h5>Aggiunta del device</h5>
<p>Il driver, a questo punto, è pronto per essere aggiunto. è possibile aggiungere il driver usando </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int cdev_add (struct cdev *p, dev_t dev, unsigned count);</div>
</div><!-- fragment --><p> La quale accetta come parametri</p><ul>
<li>p: puntatore a struttura cdev structure per il device</li>
<li>dev: device number (precedentemente inizializzato usando la funzione <em>alloc_chrdev_region()</em>)</li>
<li>count: numero di minor-numbers richiesti per il device</li>
</ul>
<p>La funzione restituisce un numero negativo in caso di errore.</p>
<h5>Accedere al segmento di memoria a cui la periferica è mappata</h5>
<p>Un driver, tipicamente, prende possesso del segmento di memoria cui è mappato il device con la funzione di probe. Il problema è che il device è mappato ad un indirizzo di memoria fisico ed il Kernel, così come qualsiasi altro programma, lavora su indirizzi di memoria virtuali. La funzione</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int of_address_to_resource(struct device_node *node, int index, struct resource *r);</div>
</div><!-- fragment --><p>popola una struttura resource con l'indirizzo di memoria cui è mapato il device usando le informazioni contenute all'interno del device tree. Ad esempio, se il device tree contiene </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;reg = &lt;0x41200000 0x10000&gt;;</div>
</div><!-- fragment --><p> signidifa che l'indirizzo fisico associato al device è l'indirizzo 0x41200000, che al device sono riservati 0x10000 bytes. of_address_to_resource() setterà res.start = 0x41200000 e res.end = 0x4120ffff.</p>
<h5>Allocazione della memoria del device</h5>
<p>Le regioni di memoria per di I/O vanno allocate prima di poter essere usate. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct resource *request_mem_region(unsigned long start, unsigned long len, char *name);</div>
</div><!-- fragment --><p> Questa funzione alloca una regione di memoria di len byte a partire da start restituendone l'indirizzo, mentre nel caso in cui si verifichi un errore viene restituito NULL. La funzione viene chiamata per ottenere l'accesso esclusivo della regione di memoria, per evitare che driver diversi tentino di accedere allo stesso spazio di memoria.</p>
<h5>Remapping</h5>
<p>L'allocazione dello spazio di memoria non è l'unico step da eseguire prima che tale memoria possa essere usata. è necessario fare in modo che sia resa accessibile al kernel attraverso un mapping, usando la funzione. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void *ioremap(unsigned long phys_addr, unsigned long size);</div>
</div><!-- fragment --><h5>Registrazione di un interrupt-handler</h5>
<p>Il modulo deve registrare un handler per gli interrupt. L'handler deve essere compatibile con il tipo puntatore a funzione irq_handler_t, così definito. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct irqreturn_t (*irq_handler_t)(int irq, struct pt_regs * regs);</div>
</div><!-- fragment --><p> Il modulo definisce la funzione <a class="el" href="group___linux-_driver.html#ga2fc230a12a97aa63e43b2dc4aec73511" title="Interrupt-handler. ">myGPIOK_irq_handler()</a>. L'handler può essere registrato usando </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int request_irq(    unsigned int irqNumber,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;                    irqreturn_t (*handler)(int, void *, struct pt_regs *),</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;                    unsigned long irqflags,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;                    const char *devname,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;                    void *dev_id);</div>
</div><!-- fragment --><p> IL parametro irqNumber può essere determinato automaticamente usando la funzione </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;unsigned int irq_of_parse_and_map(struct device_node *node, int index);</div>
</div><!-- fragment --><p> La funzione irq_of_parse_and_map() effettua un looks-up nella specifica degli interrupt all'interno del device tree e restituisce un irq number così come de lo aspetta request_irq() (cioè compaci con l'enumerazione in /proc/interrupts). Il secondo argomento della funzione è, tipicamente, zero, ad indicare che, all'interno del device tree, verrà preso in considerazione soltanto il primo degli interrupt specificate. Il device tree, nella sezione dedicata al gpio,reca </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;interrupts = &lt;0 29 4&gt;;</div>
</div><!-- fragment --><p> Il primo numero (0) è un flag che indica se l'interrupt sia connesso ad una line SPI (shared peripheral interrupt). Un valore diverso da zero indica che la linea è SPI. Il secondo numero si riferisce all'interrupt number. Per farla breve, quando si definisce la parte hardware, in questo specifico esempio il device GPIO è connesso alla linea 61 del GIC. Sottraendo 32 si orriene 29. Il terzo numero si riferisce alla tipologia dell'interrupt. Sono possibili tre valori:</p><ul>
<li>0 : power-up default</li>
<li>1 : rising-edge</li>
<li>4 : a livelli, active alto</li>
</ul>
<h5>Inizializzazione della wait-queue per la system-call read() e poll()</h5>
<p>In linux una wait queue viene implementata da una struttura dati wait_queue_head_t, definita in &lt;linux/wait.h&gt;. Il driver in questione prevede due wait-queue differenti: una per la system-call read() ed una per la system-call poll(). Entrambe le code vengono inizializzate dalla funzione <a class="el" href="group___linux-_driver.html#gae40973a06d72f7c41a9af07513a62307" title="Viene chiamata quando il modulo viene inserito. ">myGPIOK_probe()</a>. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;init_waitqueue_head(&amp;my_queue);</div>
</div><!-- fragment --><p> Si veda la documentazione della funzione <a class="el" href="group___linux-_driver.html#ga90ac339df9c02ae5f11a2a7727adc923" title="Legge dati dal device. ">myGPIOK_read()</a> per dettagli ulteriori.</p>
<h5>Inizializzazione degli spinlock</h5>
<p>I semafori sono uno strumento potentissimo per per l'implementazione di sezioni critiche, ma non possono essere usati in codice non interrompibile. Gli spilock sono come i semafori, ma possono essere usati anche in codice non interrompibile, come può esserlo un modulo kernel. Sostanzialmente se uno spinlock è già stato acquisito da qualcun altro, si entra in un hot-loop dal quale si esce solo quando chi possiede lo spinlock lo rilascia. Trattandosi di moduli kernel, è di vitale importanza che la sezione critica sia quanto più piccola possibile. Ovviamente l'implementazione è "un pò" più complessa di come è stata descritta, ma il concetto è questo. Gli spinlock sono definiti in &lt;linux/spinlock.h&gt;. L'inizializzazione di uno spinlock avviene usando la funzione </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void spin_lock_init(spinlock_t *lock);</div>
</div><!-- fragment --><h5>Abilitazione degli interrupt del device</h5>
<p>A seconda del valore CFLAGS_myGPIOK.o (si veda il Makefile a corredo), vengono abilitati gli interrupt della periferica. Se si tratta del GPIO Xilinx vengono abilitati gli interrupt globali e gli interrupt sul canale due. Se si tratta del device GPIO custom, essendo esso parecchio più semplice, è necessario abilitare solo gli interrupt globali.</p>

</div>
</div>
<a class="anchor" id="ga1b3ad44b9198f537493180d748de0b6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned myGPIOK_PendingPinInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consente di ottenere una maschera che indichi quali interrupt non siano stati ancora serviti;. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>maschera che riporta i pin per i quali gli interrupt non sono stati ancora serviti; </dd></dl>

</div>
</div>
<a class="anchor" id="ga8eaf8f1b21aa6f772c395faf457144f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myGPIOK_PinInterruptAck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invia al device notifica di servizio di un interrupt;. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>mask maschera di selezione degli interrupt da notificare; quelli non selezionati non vengono notificati; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabfd91641f98a4725aec779c8834ca92d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myGPIOK_PinInterruptDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disabilita gli interrupt per i singoli pin del device. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>maschera di selezione degli interrupt da disabilitare; quelli non selezionati non vengono disabilitati; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga179c20f5f62e8ce1593cbedff2f00533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myGPIOK_PinInterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abilita gli interrupt per i singoli pin del device. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>maschera di selezione degli interrupt da abilitare; quelli non selezionati non vengono abilitati; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6dc0ec06b388522ffc524e5fd14d8b72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myGPIOK_ResetCanRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset del flag "interrupt occurred" (canRead) </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare</td></tr>
  </table>
  </dd>
</dl>
<h5>Reset del flag "interrupt occurred" per read() bloccanti</h5>
<p>Nel momento in cui il processo viene risvegliato e la condizione della quale era in attesa è tale che esso può continuare la sua esecuzione, è necessario resettare tale flag. Questa operazione va effettuata per prevenire race-condition dovute al risveglio di più processi in attesa del manifestarsi dello stesso evento. Il reset del flag va, pertanto, effettuato in mutua esclusione.</p>
<p>I semafori sono uno strumento potentissimo per per l'implementazione di sezioni critiche, ma non possono essere usati in codice non interrompibile. Gli spilock sono come i semafori, ma possono essere usati anche in codice non interrompibile, come può esserlo un modulo kernel. Sostanzialmente se uno spinlock è già stato acquisito da qualcun altro, si entra in un hot-loop dal quale si esce solo quando chi possiede lo spinlock lo rilascia. Trattandosi di moduli kernel, è di vitale importanza che la sezione critica sia quanto più piccola possibile. Ovviamente l'implementazione è "un pò" più complessa di come è stata descritta, ma il concetto è questo. Gli spinlock sono definiti in &lt;linux/spinlock.h&gt;. Esistono diversi modi per acquisire uno spinlock. Nel seguito viene usata la funzione </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void spin_lock(spinlock_t *lock);</div>
</div><!-- fragment --><p> per rilasciare uno spinlock, invece, verrà usata </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void spin_unlock(spinlock_t *lock);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad82c1051e6acb335b1b26ab0c459453b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myGPIOK_SetCanRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set del flag "interrupt occurred" (canRead) </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare</td></tr>
  </table>
  </dd>
</dl>
<h5>Setting del valore del flag "interrupt occurred"</h5>
<p>Dopo aver disabilitato gli interrupt della periferica, occorre settare in modo appropriato il flag "interrupt occurred", in modo che i processi in attesa possano essere risvegliati in modo sicuro. Per prevenire race condition, tale operazione viene effettuata mutua esclusione. I semafori sono uno strumento potentissimo per per l'implementazione di sezioni critiche, ma non possono essere usati in codice non interrompibile. Gli spilock sono come i semafori, ma possono essere usati anche in codice non interrompibile, come può esserlo un modulo kernel. Sostanzialmente se uno spinlock è già stato acquisito da qualcun altro, si entra in un hot-loop dal quale si esce solo quando chi possiede lo spinlock lo rilascia. Trattandosi di moduli kernel, è di vitale importanza che la sezione critica sia quanto più piccola possibile. Ovviamente l'implementazione è "un pò" più complessa di come è stata descritta, ma il concetto è questo. Gli spinlock sono definiti in &lt;linux/spinlock.h&gt;. Esistono diversi modi per acquisire uno spinlock. Nel seguito viene usata la funzione </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);</div>
</div><!-- fragment --><p> la quale disabilita gli interrupt sul processore locale prima di acquisire lo spinlock, per poi ripristinarlo quando lo spinlock viene rilasciato, usando </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaf1b6f35c097c46361d675a42f122828e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myGPIOK_TestCanReadAndSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Testa la condizione "interrupt occurred", mettendo in attesa il processo, se necessario. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare</td></tr>
  </table>
  </dd>
</dl>
<h5>Porre un processo nello stato sleeping</h5>
<p>Quando un processo viene messo nello stato sleep, lo si fa aspettandosi che una condizione diventi vera in futuro. Al risveglio, però, non c'è nessuna garanzia che quella particolare condizione sia ancora vera, per cui essa va nuovamente testata. Il modo più semplice per potte un processo nello stato sleeping è chiamare la macro wait_event(), o una delle sue varianti: essa combina la gestione della messa in sleeping del processo ed il check della condizione che il processo si aspetta diventi vera. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;wait_event_interruptible(queue, condition);</div>
</div><!-- fragment --><p> Il parametro queue è la coda di attesa mentre condition è la condizione che, valutata true, causa la messa in sleep del processo. La condizione viene valutata sia prima che il processo sia messo in sleeping che al suo risveglio. Lo sleep in cui il processo viene messo chiamando wait_event_interruptible() può essere interrotto anche da un segnale, per cui la macro restituisce un intero che, se diverso da zero, indica che il processo è stato risvegliato da un segnale.</p>
<p>La condizione sulla quale i processi vengono bloccati riguarda il flag "interrupt occurred". Fin quando questo flag, posto in and con la maschera MYGPIOK_SREAD, è zero, il processo deve restare bloccato, per cui i processi che effettuano read() bloccante restano bloccati finché int_occurred &amp; MYGPIO_SREAD == 0. Quando tale uguaglianza non sarà più valida, perché il valore di int_occurred viene settato dalla funzione <a class="el" href="group___linux-_driver.html#ga2fc230a12a97aa63e43b2dc4aec73511" title="Interrupt-handler. ">myGPIOK_irq_handler()</a>, allora il processo verrà risvegliato. </p>

</div>
</div>
<a class="anchor" id="gae182aa943af08c102a05795ae8526192"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myGPIOK_WakeUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Risveglia i process in attesa sulle code di read e poll. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a>, che si riferisce al device su cui operare</td></tr>
  </table>
  </dd>
</dl>
<h5>Wakeup dei processi sleeping</h5>
<p>La ISR deve chiamare esplicitamente wakeup() per risvegliare i processi messi in sleeping in attesa che un particolare evento si manifestasse. La funzione </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void wake_up_interruptible(wait_queue_head_t *queue);</div>
</div><!-- fragment --><p> risveglia tutti i processi posti in una determinata coda (risvegliando solo quelli che, in precedenza, hanno effettuato una chiamata a wait_event_interruptible()). Se due processi vengono risvegliati contemporaneamente potrebbero originarsi race-condition. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generato Mer 5 Lug 2017 11:48:31 per Zynq-7000 Driver Pack da
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
