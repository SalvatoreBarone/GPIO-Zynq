<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zynq-7000 Driver Pack: Riferimenti per il file Src/Examples/uio-int.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zynq-7000 Driver Pack
   &#160;<span id="projectnumber">3.2</span>
   </div>
   <div id="projectbrief">Implementazione C di device-driver per Xilinx Zynq-7000</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Cerca');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Cerca');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('uio-int_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Funzioni</a>  </div>
  <div class="headertitle">
<div class="title">Riferimenti per il file uio-int.c</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;sys/mman.h&gt;</code><br />
<code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &quot;<a class="el" href="my_g_p_i_o_8h_source.html">myGPIO.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="xil__gpio_8h_source.html">xil_gpio.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Grafo delle dipendenze di inclusione per uio-int.c:</div>
<div class="dyncontent">
<div class="center"><img src="uio-int_8c__incl.png" border="0" usemap="#_src_2_examples_2uio-int_8c" alt=""/></div>
<map name="_src_2_examples_2uio-int_8c" id="_src_2_examples_2uio-int_8c">
<area shape="rect" id="node8" href="my_g_p_i_o_8h.html" title="myGPIO.h" alt="" coords="499,80,583,107"/>
<area shape="rect" id="node9" href="xil__gpio_8h.html" title="xil_gpio.h" alt="" coords="608,80,685,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funzioni</h2></td></tr>
<tr class="memitem:a05909651fa170a63e98e3f8e13451b7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uio-int_8c.html#a05909651fa170a63e98e3f8e13451b7b">howto</a> (void)</td></tr>
<tr class="memdesc:a05909651fa170a63e98e3f8e13451b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stampa un messaggio che fornisce indicazioni sull'utilizzo del programma.  <a href="#a05909651fa170a63e98e3f8e13451b7b">Continua...</a><br /></td></tr>
<tr class="separator:a05909651fa170a63e98e3f8e13451b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b18eb1bf7bc996599c06dc6dad8f53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uio-int_8c.html#ab6b18eb1bf7bc996599c06dc6dad8f53">parse_args</a> (int argc, char **argv, char **uio, uint8_t *op_mode, uint32_t *mode_value, uint8_t *op_write, uint32_t *write_value, uint8_t *op_read)</td></tr>
<tr class="memdesc:ab6b18eb1bf7bc996599c06dc6dad8f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effettua il parsing dei parametri passati al programma.  <a href="#ab6b18eb1bf7bc996599c06dc6dad8f53">Continua...</a><br /></td></tr>
<tr class="separator:ab6b18eb1bf7bc996599c06dc6dad8f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b676750c5d08c316cad35ec3963c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uio-int_8c.html#a78b676750c5d08c316cad35ec3963c53">gpio_op</a> (void *vrt_gpio_addr, int uio_descriptor, uint8_t op_mode, uint32_t mode_value, uint8_t op_write, uint32_t write_value, uint8_t op_read)</td></tr>
<tr class="memdesc:a78b676750c5d08c316cad35ec3963c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effettua operazioni su un device.  <a href="#a78b676750c5d08c316cad35ec3963c53">Continua...</a><br /></td></tr>
<tr class="separator:a78b676750c5d08c316cad35ec3963c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uio-int_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a3c04138a5bfe5d72780bb7e82a18e627"><td class="mdescLeft">&#160;</td><td class="mdescRight">funzione <a class="el" href="uio-int_8c.html#a3c04138a5bfe5d72780bb7e82a18e627" title="funzione main(). ">main()</a>.  <a href="#a3c04138a5bfe5d72780bb7e82a18e627">Continua...</a><br /></td></tr>
<tr class="separator:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrizione dettagliata</h2>
<div class="textblock"><dl class="section author"><dt>Autore</dt><dd>Salvatore Barone <a href="#" onclick="location.href='mai'+'lto:'+'sal'+'va'+'tor'+'.b'+'aro'+'ne'+'@gm'+'ai'+'l.c'+'om'; return false;">salva<span style="display: none;">.nosp@m.</span>tor.<span style="display: none;">.nosp@m.</span>baron<span style="display: none;">.nosp@m.</span>e@gm<span style="display: none;">.nosp@m.</span>ail.c<span style="display: none;">.nosp@m.</span>om</a> </dd></dl>
<dl class="section date"><dt>Data</dt><dd>14 06 2017</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2017 Salvatore Barone <a href="#" onclick="location.href='mai'+'lto:'+'sal'+'va'+'tor'+'.b'+'aro'+'ne'+'@gm'+'ai'+'l.c'+'om'; return false;">salva<span style="display: none;">.nosp@m.</span>tor.<span style="display: none;">.nosp@m.</span>baron<span style="display: none;">.nosp@m.</span>e@gm<span style="display: none;">.nosp@m.</span>ail.c<span style="display: none;">.nosp@m.</span>om</a></dd></dl>
<p>This file is part of Zynq7000DriverPack</p>
<p>Zynq7000DriverPack is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or any later version.</p>
<p>Zynq7000DriverPack is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. </p>
</div><h2 class="groupheader">Documentazione delle funzioni</h2>
<a id="a78b676750c5d08c316cad35ec3963c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b676750c5d08c316cad35ec3963c53">&#9670;&nbsp;</a></span>gpio_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_op </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vrt_gpio_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>uio_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>op_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>op_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>write_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>op_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effettua operazioni su un device. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vrt_gpio_addr</td><td>indirizzo di memoria del device gpio </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uio_descriptor</td><td>descrittore del file /dev/uioX usato </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_mode</td><td>sarà impostato ad 1 se l'utente intende effettuare scrittuara su mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode_value</td><td>conterrà il valore che l'utente intende scrivere nel registro mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_write</td><td>sarà impostato ad 1 se l'utente intende effettuare scrittuara su write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_value</td><td>conterrà il valore che l'utente intende scrivere nel registro write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_read</td><td>sarà impostato ad 1 se l'utente intende effettuare lettura da read</td></tr>
  </table>
  </dd>
</dl>
<p>La funzione viene invocata dopo che sia stato eseguito il parsing dei parametri passati al programma quando esso viene invocato. è stata scritta per funzionare sia con il GPIO Xilinx che con il GPIO custom myGPIO. è possibile utilizzare il primo definendo la macro <b>XIL_GPIO</b>. Effettua, sul device, le operazioni impostate, in accordo con i parametri passati al programma alla sua invocazione. </p>
<h4>Impostazione della modalità di funzionamento</h4>
<p>Nel caso in cui si stia operando su un device GPIO Xilinx, le operazioni di impostazione della modalità di funzionamento del GPIO vengono effettuate scrivendo direttamente sul registro MODE del device. In caso contrario si è preferito utilizzare la funzioni myGPIO_setMode() (Si veda il modulo myGPIO). Funzionalmente non c'è differenza.</p>
<h4>Operazione di scrittura</h4>
<p>Nel caso in cui si stia operando su un device GPIO Xilinx, le operazioni di scrittura del valore dei pin del device GPIO vengono effettuate scrivendo direttamente sul registro WRITE del device. In caso contrario si è preferito utilizzare la funzioni myGPIO_setValue() (Si veda il modulo myGPIO). Funzionalmente non c'è differenza.</p>
<h4>Operazione di lettura con interrupt</h4>
<p>Nel caso in cui si stia operando su un device GPIO Xilinx, le operazioni di lettura del valore dei pin del device GPIO vengono effettuate leggendo direttamente dal registro READ del device. In caso contrario si è preferito utilizzare la funzioni myGPIO_getRead() (Si veda il modulo myGPIO). Funzionalmente non c'è differenza. <b>La lettura avviene usando il meccanismo delle interruzioni</b></p>
<p>NOTA: la parte di codice per il GPIO Xilinx è stata scritta per hardware configurato in modo che il channel 1 del gpio fosse connessi esclusivamente ai led,mentre switch e button fossero connessi al channel 2 dello stesso GPIO. Il channel 1 ha dimensione 4 bit, mentre il channel 2 è da 8 bit.</p>
<h4>Attesa dell'arrivo di una interruzione</h4>
<p>Gli interrupt sono gestiti effettuando una lettura bloccante su /dev/uioX. Una read() su /dev/uioX fa in modo che il processo venga sospeso ed inserito nella cosa dei processi in attesa di un evento su quel file. Appena l'interrupt si manifesta, il processo viene posto nella cosa dei processi pronti. La funzione read() consente di ottenere anche il numero totale di interrupt manifestatisi su quella particolare periferica. La read() restituisce il numero di interrupt che si sono manifestati. Quando un device possiede più di una sorgente di interrupt interna, ma non possiede maschere IRQ differenti o registri di stato differenti, potrebbe essere impossibile, per un programma in userspace, determinare quale sia la sorgente di interrupt se l'handler implementato nel kernel le disabilita scrivendo nei registri.</p>
<p><br />
 In questo caso è stato ritenuto opportuno, a titolo di esempio, mostrare come sia possibile bloccare il programma, dopo aver "servito" l'interruzione scatenata alla pressione di un tasto, fino a quando il tasto (o i tasti) premuti non siano riportati alla posizione di riposo. Lo stato del registro READ della periferica viene ripetutamente letto all'interno di un hot-loop, fino a quando non assume valore nullo. In tal caso si ha la certezza che i button o gli switch, in questo caso, siano stati riportati alla posizione di riposo. Si tenga presente che il device GPIO Xilinx generata una interruzione sia alla pressione che al rilascio di uno dei button o di uno degli switch</p>
<p><br />
 Dopo che button e switch siano stati riportati alla posizione di riposo, viene inviato l'ack al device, per segnalargli che l'interrupt è stato servito.</p>
<h4>Riabilitare gli interrupt UIO</h4>
<p>Per lasciare inalterati i registri della periferica il kernel deve disabilitare completamente le interruzioni per la linea di interrupt cui la periferica è connessa, in modo che il programma userspace possa determinare la causa scatenante l'interruzione. Una volta terminate le operazioni, però, il programma userspace non può riabilitare le interruzioni, motivo per cui il driver implementa anche una funzione write(). La funzione write(), chiamata su /dev/uioX, consente di riabilitare le interruzioni per quella specifica periferica, scrivendo 1.</p>
<dl><dt><b>Esempi: </b></dt><dd><a class="el" href="uio-int_8c-example.html#a2">uio-int.c</a>.</dd>
</dl>
</div>
</div>
<a id="a05909651fa170a63e98e3f8e13451b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05909651fa170a63e98e3f8e13451b7b">&#9670;&nbsp;</a></span>howto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void howto </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stampa un messaggio che fornisce indicazioni sull'utilizzo del programma. </p>
<dl><dt><b>Esempi: </b></dt><dd><a class="el" href="uio-int_8c-example.html#a0">uio-int.c</a>.</dd>
</dl>
</div>
</div>
<a id="a3c04138a5bfe5d72780bb7e82a18e627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c04138a5bfe5d72780bb7e82a18e627">&#9670;&nbsp;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funzione <a class="el" href="uio-int_8c.html#a3c04138a5bfe5d72780bb7e82a18e627" title="funzione main(). ">main()</a>. </p>
<h4>Parsing dei parametri di invocazione</h4>
<p>Il parsing dei parametri passati al programma all'atto della sua invocazione viene effettuato dalla funzione <a class="el" href="uio-int_8c.html#ab6b18eb1bf7bc996599c06dc6dad8f53" title="Effettua il parsing dei parametri passati al programma. ">parse_args()</a>. Si rimanda alla sua documentazione per i dettagli sui parametri riconosciuti.</p>
<p>Se non viene specificato il device UIO col quale interagire è impossibile continuare. Per questo motivo, in questo caso, il programma viene terminato.</p>
<h4>Accesso ad un device /dev/uioX</h4>
<p>Il driver generic-UIO è il driver generico per eccellenza. Ad ogni periferica compatibile con UIO è associato un file diverso in /dev/uioX attraverso il quale è possibile raggiungere il device. Tale file sarà /dev/uio0 per il primo device, /dev/uio1 per il secondo, /dev/uio2 per il terzo e così via. on for subsequent devices. Tale file può essere usato per accedere allo spazio degli indirizzi del device usando mmap().</p>
<p>In questo caso, rispetto all'esempio noDriver, accedere al device è estremamente più semplice. Se il device è compatibile con il driver UIO, è possibile "aprire" un file in /dev/uioX, effettuare il mapping, connettendo il device allo spazio di indirizzamento del processo, senza la necessità di conoscere l'indirizzo fisico della periferica col quale di intende comunicare.</p>
<p>L'accesso al device /dev/uioX viene ottenuto mediante la system-call open(): </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sys/stat.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fcntl.h&gt;</span></div><div class="line"><span class="keywordtype">int</span> open(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> oflag, ...  );</div></div><!-- fragment --><p> la quale restituisce il descrittore del file /dev/uioX, usato nel seguito per effettuare le operazioni di I/O. I valori del parametro oflag specificano il modo in cui il file /dev/uioX viene aperto. In questo caso viene usato O_RDWR, il quale garantisce accesso in lettura ed in scrittura. Altri valori sono O_RDONLY, il quale garantisce accesso in sola lettura, ed O_WRONLY, che, invece, garantisce accesso in sola scrittura.</p>
<h4>Mapping un device /dev/uioX</h4>
<p>La "conversione" dell'indirizzo fisico del device in indirizzo virtuale appartenente allo spazio di indirizzamento del processo viene effettuato tramite la chiamata alla funzione mmap(), la quale stabilisce un mapping tra lo spazio di indirizzamento di un processo ed un file, una porzione di memoria condivisa o un qualsiasi altro memory-object, restituendo un indirizzo virtuale valido, attraverso il quale è possibile accedere al blocco di memoria fisico. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sys/mman.h&gt;</span></div><div class="line"><span class="keywordtype">void</span> *mmap(<span class="keywordtype">void</span> *addr, <span class="keywordtype">size_t</span> len, <span class="keywordtype">int</span> prot, <span class="keywordtype">int</span> flags, <span class="keywordtype">int</span> fildes, off_t off);</div></div><!-- fragment --><p> Per semplicità supponiamo che la chiamata alla funzione sia la seguente: </p><center>pa=mmap(addr, len, prot, flags, fildes, off);</center><p> la semantica dei diversi parametri è:</p><ul>
<li>pa: indirizzo virtuale dell'address-space locale del processo, a cui viene eseguito il map; se il mapping ha successo viene restituito qualcosa di diverso da MAP_FAILED;</li>
<li>addr:</li>
<li>len: lunghezza, in byte, del blocco mappato; in questo caso viene usato il valore restituito da sysconf(_SC_PAGESIZE);</li>
<li>prot: specifica i permessi di accesso al blocco di memoria del quale si sta facendo il mapping;<ul>
<li>PROT_READ indica che il blocco può essere letto;</li>
<li>PROT_WRITE indica che il blocco può essere scritto;</li>
<li>PROT_NONE sta ad indicare che il blocco non può essere acceduto;</li>
</ul>
</li>
<li>flags:fornisce informazioni aggiuntive circa la gestione del blocco di dati di cui si sta facendo il mapping; il valore del flag può essere uno dei seguenti:<ul>
<li>MAP_SHARED: modifiche al blocco sono condivise con chiunque altri lo stia usando;</li>
<li>MAP_PRIVATE: le modifiche sono primate;</li>
</ul>
</li>
</ul>
<ul>
<li>filedes: descrittore del file /dev/mem</li>
<li>off: indirizzo fisico del blocco che si intente mappare; è necessario che sia allineato alla dimensione della pagina di memoria, così come restituito dalla funzione sysconf(_SC_PAGESIZE);</li>
</ul>
<p>In questo caso la chiamata a mmap avviene con i seguenti parametri: </p><div class="fragment"><div class="line">uint32_t page_size = sysconf(_SC_PAGESIZE);     <span class="comment">// dimensione della pagina</span></div><div class="line"><span class="keywordtype">void</span>* vrt_gpio_addr = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, descriptor, 0);</div></div><!-- fragment --><p>Rispetto al "driver" nodriver, la chiamata differisce per un solo perticolare: essendo descriptor il descrittore di uioX, e l'offset specificato nullo, la funzione restituisce direttamente l'indirizzo virtuale del device nello spazio di indirizzamento del processo.</p>
<h4>Operazioni sul device</h4>
<p>Una volta effettuato il mapping, le operazioni preventivate con l'invocazione del programma vengono effettuate dalla funzione <a class="el" href="uio-int_8c.html#a78b676750c5d08c316cad35ec3963c53" title="Effettua operazioni su un device. ">gpio_op()</a>. Si rimanda alla sua documentazione per i dettagli sulle operazioni effettuate().</p>
<dl><dt><b>Esempi: </b></dt><dd><a class="el" href="uio-int_8c-example.html#a32">uio-int.c</a>.</dd>
</dl>
</div>
</div>
<a id="ab6b18eb1bf7bc996599c06dc6dad8f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b18eb1bf7bc996599c06dc6dad8f53">&#9670;&nbsp;</a></span>parse_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int parse_args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>uio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>op_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mode_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>op_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>write_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>op_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effettua il parsing dei parametri passati al programma. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uio_file</td><td>file uio da usare </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">op_mode</td><td>sarà impostato ad 1 se l'utente intende effettuare scrittuara su mode </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode_value</td><td>conterrà il valore che l'utente intende scrivere nel registro mode </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">op_write</td><td>sarà impostato ad 1 se l'utente intende effettuare scrittuara su write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">write_value</td><td>conterrà il valore che l'utente intende scrivere nel registro write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">op_read</td><td>sarà impostato ad 1 se l'utente intende effettuare lettura da read</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Valori di ritorno</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>se il parsing ha successo </td></tr>
    <tr><td class="paramname">-1</td><td>se si verifica un errore </td></tr>
  </table>
  </dd>
</dl>
<h4>Parsing dei parametri del programma.</h4>
<p>Il parsing viene effettuato usando la funzione getopt(). </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div><div class="line"><span class="keywordtype">int</span> getopt(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keywordtype">char</span> *optstring);</div></div><!-- fragment --><p> Essa prende in input i parametri argc ed argv passati alla funzione <a class="el" href="uio-int_8c.html#a3c04138a5bfe5d72780bb7e82a18e627" title="funzione main(). ">main()</a> quando il programma viene invocato. Quando una delle stringhe che compongono argv comincia con il carattere '-', getopt() la considera una opzione. Il carattere immediatamente successivo il '-' identifica la particolare opzione. La funzione può essere chiamata ripetutamente, fino a quando non restituisce -1, ad indicare che sono stati analizzati tutti i parametri passati al programma. Quando getopt() trova un'opzione, restituisce quel carattere ed aggiorna la variabile globale optind, che punta al prossimo parametro contenuto in argv. La stringa optstring indica quali sono le opzioni considerate. Se una opzione è seguita da ':' vuol dire che essa è seguita da un argomento. Tale argomento può essere ottenuto mediante la variabile globale optarg.</p>
<h4>Parametri riconosciuti</h4>
<p>La funzione riconosce i parametri:</p><ul>
<li>'d' : seguito dal percordo del device /dev/uioX col quale interagire</li>
<li>'w' : operazione di scrittura, seguito dal valore che si intende scrivere, in esadecimale; la scrittura verrà effettuata sul registro WRITE;</li>
<li>'m' : impostazione modalità, seguito dalla modalità col quale impostare il device; la scrittura verrà effettuata sul registro MODE;</li>
<li>'r' : operazione di lettura, primo di argomento; la lettura viene effettuata dal registro READ ed è non bloccante, nel senso che viene semplicemente letto il contenuto del registro.</li>
</ul>
<dl><dt><b>Esempi: </b></dt><dd><a class="el" href="uio-int_8c-example.html#a1">uio-int.c</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_413f4e031a85da0d68269c6fd2f76e1c.html">Src</a></li><li class="navelem"><a class="el" href="dir_1b70f4f506dadebaa011ded43b066ccb.html">Examples</a></li><li class="navelem"><a class="el" href="uio-int_8c.html">uio-int.c</a></li>
    <li class="footer">Generato Sab 29 Lug 2017 11:19:44 per Zynq-7000 Driver Pack da
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
