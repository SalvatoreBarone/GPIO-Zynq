<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zynq-7000 Driver Pack: Riferimenti per la struct myGPIOK_t</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zynq-7000 Driver Pack
   &#160;<span id="projectnumber">3.2</span>
   </div>
   <div id="projectbrief">Implementazione C di device-driver per Xilinx Zynq-7000</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Cerca');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Cerca');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structmy_g_p_i_o_k__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Campi</a>  </div>
  <div class="headertitle">
<div class="title">Riferimenti per la struct myGPIOK_t<div class="ingroups"><a class="el" href="group__my_g_p_i_o.html">MyGPIO</a> &raquo; <a class="el" href="group___linux-_driver.html">Linux-Driver</a> &raquo; <a class="el" href="group__my_g_p_i_o_k__t.html">MyGPIOK_t</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Stuttura per l'astrazione di un device myGPIO in kernel-mode.  
 <a href="structmy_g_p_i_o_k__t.html#details">Continua...</a></p>

<p><code>#include &lt;<a class="el" href="my_g_p_i_o_k__t_8h_source.html">myGPIOK_t.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Campi</h2></td></tr>
<tr class="memitem:aeb60fb4e41b5f11f70ebe969361884f4"><td class="memItemLeft" align="right" valign="top">dev_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#aeb60fb4e41b5f11f70ebe969361884f4">Mm</a></td></tr>
<tr class="separator:aeb60fb4e41b5f11f70ebe969361884f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7801058bef8fbe4a2cec3c9579cd70"><td class="memItemLeft" align="right" valign="top">struct platform_device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a3a7801058bef8fbe4a2cec3c9579cd70">op</a></td></tr>
<tr class="separator:a3a7801058bef8fbe4a2cec3c9579cd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba682fe45d5a1501790dbdb1d99bd6a"><td class="memItemLeft" align="right" valign="top">struct cdev&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#acba682fe45d5a1501790dbdb1d99bd6a">cdev</a></td></tr>
<tr class="separator:acba682fe45d5a1501790dbdb1d99bd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6a82c73e7a9d99293d9ce0b8837faf"><td class="memItemLeft" align="right" valign="top">struct device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#acf6a82c73e7a9d99293d9ce0b8837faf">dev</a></td></tr>
<tr class="separator:acf6a82c73e7a9d99293d9ce0b8837faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6474dd18270738a5c4853fd93b5e70"><td class="memItemLeft" align="right" valign="top">struct class *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a9b6474dd18270738a5c4853fd93b5e70">class</a></td></tr>
<tr class="separator:a9b6474dd18270738a5c4853fd93b5e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a1593ebe61611c4e29413903a373a5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a42a1593ebe61611c4e29413903a373a5">irqNumber</a></td></tr>
<tr class="separator:a42a1593ebe61611c4e29413903a373a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee102d0534084ca58a9cf9b8a3d9cc9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a8ee102d0534084ca58a9cf9b8a3d9cc9">irq_mask</a></td></tr>
<tr class="separator:a8ee102d0534084ca58a9cf9b8a3d9cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565a1848c3ae8026257a74cf169c6941"><td class="memItemLeft" align="right" valign="top">struct resource&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a565a1848c3ae8026257a74cf169c6941">rsrc</a></td></tr>
<tr class="separator:a565a1848c3ae8026257a74cf169c6941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c4eb95350c67ccb239a8a39c43c09a"><td class="memItemLeft" align="right" valign="top">struct resource *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a18c4eb95350c67ccb239a8a39c43c09a">mreg</a></td></tr>
<tr class="separator:a18c4eb95350c67ccb239a8a39c43c09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f87b53dc5049a349ef01aa586c0b5dc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a0f87b53dc5049a349ef01aa586c0b5dc">rsrc_size</a></td></tr>
<tr class="separator:a0f87b53dc5049a349ef01aa586c0b5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aef493b3c2bc9d1f036ce0acea9bba"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#af5aef493b3c2bc9d1f036ce0acea9bba">vrtl_addr</a></td></tr>
<tr class="separator:af5aef493b3c2bc9d1f036ce0acea9bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251570f8e6976ad87411093e330e7b4f"><td class="memItemLeft" align="right" valign="top">wait_queue_head_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a251570f8e6976ad87411093e330e7b4f">read_queue</a></td></tr>
<tr class="separator:a251570f8e6976ad87411093e330e7b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2080617f88cafd765430573afe7701d1"><td class="memItemLeft" align="right" valign="top">wait_queue_head_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a2080617f88cafd765430573afe7701d1">poll_queue</a></td></tr>
<tr class="separator:a2080617f88cafd765430573afe7701d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8d3d6037e2d2fdadbd7c2fd995f0a1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a2b8d3d6037e2d2fdadbd7c2fd995f0a1">can_read</a></td></tr>
<tr class="separator:a2b8d3d6037e2d2fdadbd7c2fd995f0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1ddf972b4dc84dd331a0c72e5d9895"><td class="memItemLeft" align="right" valign="top">spinlock_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a1e1ddf972b4dc84dd331a0c72e5d9895">slock_int</a></td></tr>
<tr class="separator:a1e1ddf972b4dc84dd331a0c72e5d9895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da711ac290a9613b8d8af97f122b997"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#a2da711ac290a9613b8d8af97f122b997">total_irq</a></td></tr>
<tr class="separator:a2da711ac290a9613b8d8af97f122b997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41bbc7fe03ef25b7f468275fb565d78"><td class="memItemLeft" align="right" valign="top">spinlock_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html#ac41bbc7fe03ef25b7f468275fb565d78">sl_total_irq</a></td></tr>
<tr class="separator:ac41bbc7fe03ef25b7f468275fb565d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrizione dettagliata</h2>
<div class="textblock"><p>Stuttura per l'astrazione di un device myGPIO in kernel-mode. </p>
<p>è buona abitudine, se non quasi indispensabile, definire una struttura dati nella quale contenere tutto ciò che è legato al device o al driver. In questo modulo viene usata la struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a> per contenere tutto ciò che è necessario al funzionamento del driver. </p>
</div><h2 class="groupheader">Documentazione dei campi</h2>
<a id="a2b8d3d6037e2d2fdadbd7c2fd995f0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8d3d6037e2d2fdadbd7c2fd995f0a1">&#9670;&nbsp;</a></span>can_read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t can_read</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag "puoi leggere" Il valore viene settato dalla funzione <a class="el" href="group___linux-_driver.html#ga2fc230a12a97aa63e43b2dc4aec73511" title="Interrupt-handler. ">myGPIOK_irq_handler()</a> al manifestarsi di un interrupt, prima di risvegliare i processi in attesa di un interrupt. I processi che effettuano read() bloccante restano bloccati finoché int_occurred = 0 </p>

</div>
</div>
<a id="acba682fe45d5a1501790dbdb1d99bd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba682fe45d5a1501790dbdb1d99bd6a">&#9670;&nbsp;</a></span>cdev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct cdev cdev</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stuttura per l'astrazione di un device a caratteri Il kernel usa, internamente, una struttura cdev per rappresentare i device a caratteri. Prima che il kernel invochi le funzioni definite dal driver per il device, bisogna allocare e registrare uno, o più, oggetti cdev. In questo caso è sufficiente allocare uno solo di questi oggetti. </p>

</div>
</div>
<a id="a9b6474dd18270738a5c4853fd93b5e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6474dd18270738a5c4853fd93b5e70">&#9670;&nbsp;</a></span>class</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct class* class</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf6a82c73e7a9d99293d9ce0b8837faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6a82c73e7a9d99293d9ce0b8837faf">&#9670;&nbsp;</a></span>dev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct device* dev</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ee102d0534084ca58a9cf9b8a3d9cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee102d0534084ca58a9cf9b8a3d9cc9">&#9670;&nbsp;</a></span>irq_mask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t irq_mask</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maschera delle interruzioni interne per il device </p>

</div>
</div>
<a id="a42a1593ebe61611c4e29413903a373a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a1593ebe61611c4e29413903a373a5">&#9670;&nbsp;</a></span>irqNumber</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t irqNumber</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>interrupt-number a cui il device è connesso. Restituito dalla chiamata alla funzione irq_of_parse_and_map() </p>

</div>
</div>
<a id="aeb60fb4e41b5f11f70ebe969361884f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb60fb4e41b5f11f70ebe969361884f4">&#9670;&nbsp;</a></span>Mm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dev_t Mm</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Major e minor number associati al device </p>

</div>
</div>
<a id="a18c4eb95350c67ccb239a8a39c43c09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c4eb95350c67ccb239a8a39c43c09a">&#9670;&nbsp;</a></span>mreg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct resource* mreg</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>puntatre alla regione di memoria cui il device è mapapto </p>

</div>
</div>
<a id="a3a7801058bef8fbe4a2cec3c9579cd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7801058bef8fbe4a2cec3c9579cd70">&#9670;&nbsp;</a></span>op</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct platform_device* op</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puntatore a struttura platform_device cui l'oggetto <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device myGPIO in kernel-mode. ">myGPIOK_t</a> si riferisce </p>

</div>
</div>
<a id="a2080617f88cafd765430573afe7701d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2080617f88cafd765430573afe7701d1">&#9670;&nbsp;</a></span>poll_queue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wait_queue_head_t poll_queue</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wait queue per la system-call poll() </p>

</div>
</div>
<a id="a251570f8e6976ad87411093e330e7b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251570f8e6976ad87411093e330e7b4f">&#9670;&nbsp;</a></span>read_queue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wait_queue_head_t read_queue</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wait queue per la system-call read() Una chiamata a read() potrebbe arrivare quando i dati non sono disponibili, ma potrebbero esserlo in futuro, oppure, una chiamata a write() potrebbe avvenire quando il device non è in grado di accettare altri dati (perché il suo buffer di ingresso potrebbe essere pieno). Il processo chiamante non ha la minima conoscenza delle dinamiche interne del device, per cui, nell'impossibilità di servire la richiesta, il driver deve bloccare il processo e metterlo tra i processi "sleeping", fin quando la richiesta non può essere servita. Tutti i processi in attesa di un particolare evento vengono posti all'interno della stessa wait queue. In linux una wait queue viene implementata da una struttura dati wait_queue_head_t, definita in &lt;linux/wait.h&gt;. </p>

</div>
</div>
<a id="a565a1848c3ae8026257a74cf169c6941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565a1848c3ae8026257a74cf169c6941">&#9670;&nbsp;</a></span>rsrc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct resource rsrc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Struttura che astrae una risorsa device, dal punto di vista della memoria alla quale la risorsa è mappata. In particolare i campi "start" ed "end" contengono, rispettivamente, il primo e l'ultimo indirizzo fisico a cui il device è mappato. </p>

</div>
</div>
<a id="a0f87b53dc5049a349ef01aa586c0b5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f87b53dc5049a349ef01aa586c0b5dc">&#9670;&nbsp;</a></span>rsrc_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rsrc_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>rsrc.end - rsrc.start numero di indirizzi associati alla periferica. occorre per effettuare il mapping indirizzo fisico - indirizzo virtuale </p>

</div>
</div>
<a id="ac41bbc7fe03ef25b7f468275fb565d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41bbc7fe03ef25b7f468275fb565d78">&#9670;&nbsp;</a></span>sl_total_irq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spinlock_t sl_total_irq</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spinlock usato per garantire l'accesso in mutua esclusione alla variabile total_irq da parte delle funzioni del modulo </p>

</div>
</div>
<a id="a1e1ddf972b4dc84dd331a0c72e5d9895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1ddf972b4dc84dd331a0c72e5d9895">&#9670;&nbsp;</a></span>slock_int</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spinlock_t slock_int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spinlock usato per garantire l'accesso in mutua esclusione alla variabile int_occurred da parte delle funzioni del modulo. I semafori sono uno strumento potentissimo per per l'implementazione di sezioni critiche, ma non possono essere usati in codice non interrompibile. Gli spilock sono come i semafori, ma possono essere usati anche in codice non interrompibile, come può esserlo un modulo kernel. Sostanzialmente se uno spinlock è già stato acquisito da qualcun altro, si entra in un hot-loop dal quale si esce solo quando chi possiede lo spinlock lo rilascia. Trattandosi di moduli kernel, è di vitale importanza che la sezione critica sia quanto più piccola possibile. Ovviamente l'implementazione è "un pò" più complessa di come è stata descritta, ma il concetto è questo. Gli spinlock sono definiti in &lt;linux/spinlock.h&gt;. </p>

</div>
</div>
<a id="a2da711ac290a9613b8d8af97f122b997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da711ac290a9613b8d8af97f122b997">&#9670;&nbsp;</a></span>total_irq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t total_irq</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>numero totale di interrupt manifestatesi </p>

</div>
</div>
<a id="af5aef493b3c2bc9d1f036ce0acea9bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aef493b3c2bc9d1f036ce0acea9bba">&#9670;&nbsp;</a></span>vrtl_addr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* vrtl_addr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>indirizzo virtuale della periferica </p>

</div>
</div>
<hr/>La documentazione per questa struct è stata generata a partire dal seguente file:<ul>
<li>Src/myGPIO/linux-driver/<a class="el" href="my_g_p_i_o_k__t_8h_source.html">myGPIOK_t.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a></li>
    <li class="footer">Generato Sab 29 Lug 2017 11:19:45 per Zynq-7000 Driver Pack da
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
