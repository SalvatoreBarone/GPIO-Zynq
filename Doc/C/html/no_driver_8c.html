<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Zynq-7000 Driver Pack: Riferimenti per il file Src/Examples/noDriver.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Zynq-7000 Driver Pack
   &#160;<span id="projectnumber">3.1</span>
   </div>
   <div id="projectbrief">C implementation of some Driver for Zynq-7000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Cerca');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Pagina&#160;Principale</span></a></li>
      <li><a href="modules.html"><span>Moduli</span></a></li>
      <li><a href="annotated.html"><span>Strutture&#160;dati</span></a></li>
      <li class="current"><a href="files.html"><span>File</span></a></li>
      <li><a href="examples.html"><span>Esempi</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Cerca" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>Elenco&#160;dei&#160;file</span></a></li>
      <li><a href="globals.html"><span>Elementi&#160;globali</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('no_driver_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Tutto</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Strutture dati</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>File</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Funzioni</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variabili</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Tipi enumerati (enum)</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Valori del tipo enumerato</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Definizioni</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Gruppi</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Funzioni</a>  </div>
  <div class="headertitle">
<div class="title">Riferimenti per il file noDriver.c</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;sys/mman.h&gt;</code><br />
<code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &quot;<a class="el" href="my_g_p_i_o_8h_source.html">myGPIO.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Grafo delle dipendenze di inclusione per noDriver.c:</div>
<div class="dyncontent">
<div class="center"><img src="no_driver_8c__incl.png" border="0" usemap="#_src_2_examples_2no_driver_8c" alt=""/></div>
<map name="_src_2_examples_2no_driver_8c" id="_src_2_examples_2no_driver_8c">
<area shape="rect" id="node8" href="my_g_p_i_o_8h.html" title="myGPIO.h" alt="" coords="496,80,580,107"/></map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funzioni</h2></td></tr>
<tr class="memitem:a05909651fa170a63e98e3f8e13451b7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="no_driver_8c.html#a05909651fa170a63e98e3f8e13451b7b">howto</a> (void)</td></tr>
<tr class="memdesc:a05909651fa170a63e98e3f8e13451b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stampa un messaggio che fornisce indicazioni sull'utilizzo del programma.  <a href="#a05909651fa170a63e98e3f8e13451b7b">Continua...</a><br /></td></tr>
<tr class="separator:a05909651fa170a63e98e3f8e13451b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218f8a9dfc36572bfe2230c5e2d2c776"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="no_driver_8c.html#a218f8a9dfc36572bfe2230c5e2d2c776">parse_args</a> (int argc, char **argv, uint32_t *gpio_address, uint8_t *op_mode, uint32_t *mode_value, uint8_t *op_write, uint32_t *write_value, uint8_t *op_read)</td></tr>
<tr class="memdesc:a218f8a9dfc36572bfe2230c5e2d2c776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effettua il parsing dei parametri passati al programma.  <a href="#a218f8a9dfc36572bfe2230c5e2d2c776">Continua...</a><br /></td></tr>
<tr class="separator:a218f8a9dfc36572bfe2230c5e2d2c776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879d8b839631449ecb5bc4d0721432b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="no_driver_8c.html#a879d8b839631449ecb5bc4d0721432b6">gpio_op</a> (void *vrt_gpio_addr, uint8_t op_mode, uint32_t mode_value, uint8_t op_write, uint32_t write_value, uint8_t op_read)</td></tr>
<tr class="memdesc:a879d8b839631449ecb5bc4d0721432b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effettua operazioni su un device.  <a href="#a879d8b839631449ecb5bc4d0721432b6">Continua...</a><br /></td></tr>
<tr class="separator:a879d8b839631449ecb5bc4d0721432b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="no_driver_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a3c04138a5bfe5d72780bb7e82a18e627"><td class="mdescLeft">&#160;</td><td class="mdescRight">funzione <a class="el" href="no_driver_8c.html#a3c04138a5bfe5d72780bb7e82a18e627" title="funzione main(). ">main()</a>.  <a href="#a3c04138a5bfe5d72780bb7e82a18e627">Continua...</a><br /></td></tr>
<tr class="separator:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Documentazione delle funzioni</h2>
<a class="anchor" id="a879d8b839631449ecb5bc4d0721432b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_op </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vrt_gpio_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>op_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>op_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>write_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>op_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effettua operazioni su un device. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vrt_gpio_addr</td><td>indirizzo di memoria del device gpio </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_mode</td><td>sara' impostato ad 1 se l'utente intende effettuare scrittuara su mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode_value</td><td>conterra' il valore che l'utente intende scrivere nel registro mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_write</td><td>sara' impostato ad 1 se l'utente intende effettuare scrittuara su write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_value</td><td>conterra' il valore che l'utente intende scrivere nel registro write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_read</td><td>sara' impostato ad 1 se l'utente intende effettuare lettura da read</td></tr>
  </table>
  </dd>
</dl>
<p>La funzione viene invocata dopo che sia stato eseguito il parsing dei parametri passati al programma quando esso viene invocato. E' stata scritta per funzionare sia con il GPIO Xilinx che con il GPIO custom myGPIO. E' possibile utilizzare il primo definendo la macro <b>XIL_GPIO</b>. Effettua, sul device, le operazioni impostate, in accordo con i parametri passati al programma alla sua invocazione. </p>
<h4>Impostazione della modalita' di funzionamento</h4>
<p>Nel caso in cui si stia operando su un device GPIO Xilinx, le operazioni di impostazione della modalita' di funzionamento del GPIO vengono effettuate scrivendo direttamente sul registro MODE del device. In caso contrario si e' preferito utilizzare la funzioni myGPIO_setMode() (Si veda il modulo myGPIO). Funzionalmente non c'e' differenza.</p>
<h4>Operazione di scrittura</h4>
<p>Nel caso in cui si stia operando su un device GPIO Xilinx, le operazioni di scrittura del valore dei pin del device GPIO vengono effettuate scrivendo direttamente sul registro WRITE del device. In caso contrario si e' preferito utilizzare la funzioni myGPIO_setValue() (Si veda il modulo myGPIO). Funzionalmente non c'e' differenza.</p>
<h4>Operazione di lettura</h4>
<p>Nel caso in cui si stia operando su un device GPIO Xilinx, le operazioni di lettura del valore dei pin del device GPIO vengono effettuate leggendo direttamente dal registro READ del device. In caso contrario si e' preferito utilizzare la funzioni myGPIO_getRead() (Si veda il modulo myGPIO). Funzionalmente non c'e' differenza. La lettura e' non bloccante: viene semplicemente letto il valore contenuto nel registro perche' tale modalita' di interazione non permette l'implementazione di un meccanismo di lettura basato su interruzioni.</p>

</div>
</div>
<a class="anchor" id="a05909651fa170a63e98e3f8e13451b7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void howto </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stampa un messaggio che fornisce indicazioni sull'utilizzo del programma. </p>

</div>
</div>
<a class="anchor" id="a3c04138a5bfe5d72780bb7e82a18e627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funzione <a class="el" href="no_driver_8c.html#a3c04138a5bfe5d72780bb7e82a18e627" title="funzione main(). ">main()</a>. </p>
<h4>Parsing dei parametri di invocazione</h4>
<p>Il parsing dei parametri passati al programma all'atto della sua invocazione viene effettuato dalla funzione <a class="el" href="no_driver_8c.html#a218f8a9dfc36572bfe2230c5e2d2c776" title="Effettua il parsing dei parametri passati al programma. ">parse_args()</a>. Si rimanda alla sua documentazione per i dettagli sui parametri riconosciuti.</p>
<p>Se non viene specificato l'indirizzo fisico del device al quale accedere e' impossibile continuare. Per questo motivo, in questo caso, il programma viene terminato.</p>
<h4>Apertura di /dev/mem</h4>
<p>In questo specifico esempio l'interfacciamento avviene da user-space, agendo direttamente sui registri di memoria, senza mediazione di altri driver, usando il device /dev/mem. Questo presuppone che si sia nelle condizioni di poter calcolare dell'indirizzo di memoria virtuale del device. <br />
 L'accesso al device /dev/mem viene ottenuto mediante la system-call open(): </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;sys/stat.h&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;fcntl.h&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int open(const char *path, int oflag, ...  );</div>
</div><!-- fragment --><p> la quale restituisce il descrittore del file /dev/mem, usato nel seguito per effettuare le operazioni di I/O. I valori del parametro oflag specificano il modo in cui il file /dev/mem viene aperto. In questo caso viene usato O_RDWR, il quale garantisce accesso in lettura ed in scrittura. Altri valori sono O_RDONLY, il quale garantisce accesso in sola lettura, ed O_WRONLY, che, invece, garantisce accesso in sola scrittura.</p>
<h4>Calcolo dell'indirizzo virtuale del device.</h4>
<p>Linux implementa la segregazione della memoria. Vale a dire che un processo puo' accedere solo agli indirizzo di memoria (virtuali) appartenenti al suo address-space. Se e' necessario effettuare un accesso ad un indirizzo specifico, bisogna effettuare il mapping di quell'indirizzo nell'address space del processo. Linux implementa la paginazione della memoria, quindi l'indirizzo del quale si desidera effettuare il mapping, apparterra' ad una specifica pagina di memoria. Per sapere a quale pagina appartenga l'idirizzo, e' necessario conoscere quale sia la dimensione delle pagine di memoria. Tipicamente la dimensione delle pagine e' una potenza del due. Si supponga che l'indirizzo di cui si vuole fare il mapping e' <b>0x43C002F0</b> e che la dimensione delle pagine sia 16KB. Scrivendo la dimensione delle pagine in esadecimale <br />
 </p><center><b>0x00002000</b></center><p><br />
 sottraendo 1 <br />
 </p><center><b>0x00001FFF</b></center><p><br />
 negando <br />
 </p><center><b>0xFFFFE000</b></center><p><br />
 si ottiene una maschera che, posta in and con un indirizzo, restituisce l'indirizzo della pagina di memoria a cui l'indirizzo appartiene. In questo caso <br />
 </p><center><b>0x43C002F0 &amp; 0xFFFFE000 = 0x43C00000</b></center><p><br />
 L'indirizzo della pagina potra' essere usato per il mapping, ma per accedere allo specifico indirizzo e' necessario calcolarne l'offset, sottraengogli l'indirizzo della pagina. In questo modo, dopo aver effettuato il mapping, si potra' accedere allo stesso a partire dall'indirizzo virtuale della pagina stessa.</p>
<h4>Conversione dell'indirizzo fisico in indirizzo virtuale</h4>
<p>La "conversione" dell'indirizzo fisico del device in indirizzo virtuale appartenente allo spazio di indirizzamento del processo viene effettuato tramite la chiamata alla funzione mmap(), la quale stabilisce un mapping tra lo spazio di indirizzamento di un processo ed un file, una porzione di memoria condivisa o un qualsiasi altro memory-object, restituendo un indirizzo virtuale valido, attraverso il quale e' possibile accedere al blocco di memoria fisico. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;sys/mman.h&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);</div>
</div><!-- fragment --><p> Per semplicita' supponiamo che la chiamata alla funzione sia la seguente: </p><center>pa=mmap(addr, len, prot, flags, fildes, off);</center><p> la semantica dei diversi parametri e':</p><ul>
<li>pa: indirizzo virtuale dell'address-space locale del processo, a cui viene eseguito il map; se il mapping ha successo viene restituito qualcosa di diverso da MAP_FAILED;</li>
<li>addr:</li>
<li>len: lunghezza, in byte, del blocco mappato; in questo caso viene usato il valore restituito da sysconf(_SC_PAGESIZE);</li>
<li>prot: specifica i permessi di accesso al blocco di memoria del quale si sta facendo il mapping;<ul>
<li>PROT_READ indica che il blocco puo' essere letto;</li>
<li>PROT_WRITE indica che il blocco puo' essere scritto;</li>
<li>PROT_NONE sta ad indicare che il blocco non puo' essere acceduto;</li>
</ul>
</li>
<li>flags:fornisce informazioni aggiuntive circa la gestione del blocco di dati di cui si sta facendo il mapping; il valore del flag puo' essere uno dei seguenti:<ul>
<li>MAP_SHARED: modifiche al blocco sono condivise con chiunque altri lo stia usando;</li>
<li>MAP_PRIVATE: le modifiche sono primate;</li>
</ul>
</li>
</ul>
<ul>
<li>filedes: descrittore del file /dev/mem</li>
<li>off: indirizzo fisico del blocco che si intente mappare; e' necessario che sia allineato alla dimensione della pagina di memoria, cosi' come restituito dalla funzione sysconf(_SC_PAGESIZE);</li>
</ul>
<p>In questo caso la chiamata a mmap avviene con i seguenti parametri: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;uint32_t page_size = sysconf(_SC_PAGESIZE);     // dimensione della pagina</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;uint32_t page_mask = ~(page_size-1);            // maschera di conversione indirizzo -&gt; indirizzo pagina</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;uint32_t page_addr = gpio_addr &amp; page_mask;     // indirizzo della &quot;pagina fisica&quot; a cui e&#39; mappato il device</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;uint32_t offset = gpio_addr - page_addr;        // offset del device rispetto all&#39;indirizzo della pagina</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;void* vrt_page_addr = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, descriptor, page_addr) + offset;</div>
</div><!-- fragment --><h4>Operazioni sul device</h4>
<p>Una volta effettuato il mapping, le operazioni preventivate con l'invocazione del programma vengono effettuate dalla funzione <a class="el" href="no_driver_8c.html#a879d8b839631449ecb5bc4d0721432b6" title="Effettua operazioni su un device. ">gpio_op()</a>. Si rimanda alla sua documentazione per i dettagli sulle operazioni effettuate().</p>

</div>
</div>
<a class="anchor" id="a218f8a9dfc36572bfe2230c5e2d2c776"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int parse_args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>gpio_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>op_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mode_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>op_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>write_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>op_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effettua il parsing dei parametri passati al programma. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gpio_address</td><td>conterra' l'indirizzo di memoria del device gpio </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">op_mode</td><td>sara' impostato ad 1 se l'utente intende effettuare scrittuara su mode </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode_value</td><td>conterra' il valore che l'utente intende scrivere nel registro mode </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">op_write</td><td>sara' impostato ad 1 se l'utente intende effettuare scrittuara su write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">write_value</td><td>conterra' il valore che l'utente intende scrivere nel registro write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">op_read</td><td>sara' impostato ad 1 se l'utente intende effettuare lettura da read</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Valori di ritorno</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>se il parsing ha successo </td></tr>
    <tr><td class="paramname">-1</td><td>se si verifica un errore </td></tr>
  </table>
  </dd>
</dl>
<h4>Parsing dei parametri del programma.</h4>
<p>Il parsing viene effettuato usando la funzione getopt(). </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;unistd.h&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;int getopt(int argc, char * const argv[], const char *optstring);</div>
</div><!-- fragment --><p> Essa prende in input i parametri argc ed argv passati alla funzione <a class="el" href="no_driver_8c.html#a3c04138a5bfe5d72780bb7e82a18e627" title="funzione main(). ">main()</a> quando il programma viene invocato. Quando una delle stringhe che compongono argv comincia con il carattere '-', getopt() la considera una opzione. Il carattere immediatamente successivo il '-' identifica la particolare opzione. La funzione puo' essere chiamata ripetutamente, fino a quando non restituisce -1, ad indicare che sono stati analizzati tutti i parametri passati al programma. Quando getopt() trova un'opzione, restituisce quel carattere ed aggiorna la variabile globale optind, che punta al prossimo parametro contenuto in argv. La stringa optstring indica quali sono le opzioni considerate. Se una opzione e' seguita da ':' vuol dire che essa e' seguita da un argomento. Tale argomento puo' essere ottenuto mediante la variabile globale optarg.</p>
<h4>Parametri riconosciuti</h4>
<p>La funzione riconosce i parametri:</p><ul>
<li>'a' : seguito dall'indirizzo fisico della periferica con la quale interagire, il quale puo' essere indicato in esadecimale;</li>
<li>'w' : operazione di scrittura, seguito dal valore che si intende scrivere, in esadecimale; la scrittura verra' effettuata sul registro WRITE;</li>
<li>'m' : impostazione modalita', seguito dalla modalita' col quale impostare il device; la scrittura verra' effettuata sul registro MODE;</li>
<li>'r' : operazione di lettura, primo di argomento; la lettura viene effettuata dal registro READ ed e' non bloccante, nel senso che viene semplicemente letto il contenuto del registro.</li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_413f4e031a85da0d68269c6fd2f76e1c.html">Src</a></li><li class="navelem"><a class="el" href="dir_1b70f4f506dadebaa011ded43b066ccb.html">Examples</a></li><li class="navelem"><a class="el" href="no_driver_8c.html">noDriver.c</a></li>
    <li class="footer">Generato Ven 23 Giu 2017 15:46:55 per Zynq-7000 Driver Pack da
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
