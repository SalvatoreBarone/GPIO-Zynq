<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Zynq-7000 Driver Pack: Kernel-Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Zynq-7000 Driver Pack
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">C implementation of some Driver for Zynq-7000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Cerca');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Pagina&#160;Principale</span></a></li>
      <li><a href="modules.html"><span>Moduli</span></a></li>
      <li><a href="annotated.html"><span>Strutture&#160;dati</span></a></li>
      <li><a href="files.html"><span>File</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Cerca" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___kernel-_module.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Tutto</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Strutture dati</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>File</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Funzioni</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variabili</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Tipi enumerati (enum)</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Valori del tipo enumerato</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Definizioni</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Gruppi</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Strutture dati</a> &#124;
<a href="#define-members">Definizioni</a> &#124;
<a href="#func-members">Funzioni</a> &#124;
<a href="#var-members">Variabili</a>  </div>
  <div class="headertitle">
<div class="title">Kernel-Module<div class="ingroups"><a class="el" href="group__my_g_p_i_o.html">MyGPIO</a> &raquo; <a class="el" href="group___linux-_driver.html">Linux-Driver</a> &raquo; <a class="el" href="group___kernel-_driver.html">Kernel-Driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Device-driver in kernel-mode per myGPIO.  
<a href="#details">Continua...</a></p>
<div class="dynheader">
Diagramma di collaborazione per Kernel-Module:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___kernel-_module.png" border="0" alt="" usemap="#group______kernel-__module"/>
<map name="group______kernel-__module" id="group______kernel-__module">
<area shape="rect" id="node1" href="group___kernel-_driver.html" title="Kernel&#45;Driver" alt="" coords="5,5,104,32"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Strutture dati</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stuttura per l'astrazione di un device.  <a href="structmy_g_p_i_o_k__t.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Definizioni</h2></td></tr>
<tr class="memitem:ga25634d21648ca7fb7a2aca614bafaaeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>&#160;&#160;&#160;&quot;myGPIOK&quot;</td></tr>
<tr class="memdesc:ga25634d21648ca7fb7a2aca614bafaaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nome identificativo del device-driver. DEVE corrispondere al valore del campo "compatible" nel device tree source.  <a href="#ga25634d21648ca7fb7a2aca614bafaaeb">Continua...</a><br /></td></tr>
<tr class="separator:ga25634d21648ca7fb7a2aca614bafaaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga605a877d5e63c79a65d4a57d364680b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga605a877d5e63c79a65d4a57d364680b4">REQUIRED_MINOR_NUMBER</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga605a877d5e63c79a65d4a57d364680b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numero di minor-number richiesti da driver.  <a href="#ga605a877d5e63c79a65d4a57d364680b4">Continua...</a><br /></td></tr>
<tr class="separator:ga605a877d5e63c79a65d4a57d364680b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funzioni</h2></td></tr>
<tr class="memitem:gae40973a06d72f7c41a9af07513a62307"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#gae40973a06d72f7c41a9af07513a62307">myGPIOK_probe</a> (struct platform_device *op)</td></tr>
<tr class="memdesc:gae40973a06d72f7c41a9af07513a62307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Viene chiamata quando il modulo viene inserito.  <a href="#gae40973a06d72f7c41a9af07513a62307">Continua...</a><br /></td></tr>
<tr class="separator:gae40973a06d72f7c41a9af07513a62307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59fddfaa36dea357f4bbdfceb0f47f8c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga59fddfaa36dea357f4bbdfceb0f47f8c">myGPIOK_remove</a> (struct platform_device *op)</td></tr>
<tr class="separator:ga59fddfaa36dea357f4bbdfceb0f47f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad013759c18fbf6ea96005b9b3bfa5b4e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#gad013759c18fbf6ea96005b9b3bfa5b4e">myGPIOK_open</a> (struct inode *inode, struct file *file_ptr)</td></tr>
<tr class="memdesc:gad013759c18fbf6ea96005b9b3bfa5b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invocata all'apertura del file corrispondente al device.  <a href="#gad013759c18fbf6ea96005b9b3bfa5b4e">Continua...</a><br /></td></tr>
<tr class="separator:gad013759c18fbf6ea96005b9b3bfa5b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ce7f574723246c790b70b06e3e7103"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga17ce7f574723246c790b70b06e3e7103">myGPIOK_release</a> (struct inode *inode, struct file *file_ptr)</td></tr>
<tr class="memdesc:ga17ce7f574723246c790b70b06e3e7103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invocata alla chiusura del file corrispondente al device.  <a href="#ga17ce7f574723246c790b70b06e3e7103">Continua...</a><br /></td></tr>
<tr class="separator:ga17ce7f574723246c790b70b06e3e7103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e7f726b72320a272b633ecbaecefff"><td class="memItemLeft" align="right" valign="top">static loff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga66e7f726b72320a272b633ecbaecefff">myGPIOK_llseek</a> (struct file *file_ptr, loff_t off, int whence)</td></tr>
<tr class="memdesc:ga66e7f726b72320a272b633ecbaecefff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementa le system-call lseek() e llseek().  <a href="#ga66e7f726b72320a272b633ecbaecefff">Continua...</a><br /></td></tr>
<tr class="separator:ga66e7f726b72320a272b633ecbaecefff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba935e8a8215c2ebce9a7147fd4f5147"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#gaba935e8a8215c2ebce9a7147fd4f5147">myGPIOK_poll</a> (struct file *file_ptr, struct poll_table_struct *wait)</td></tr>
<tr class="memdesc:gaba935e8a8215c2ebce9a7147fd4f5147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica che le operazioni di lettura/scrittura risultino non-bloccanti.  <a href="#gaba935e8a8215c2ebce9a7147fd4f5147">Continua...</a><br /></td></tr>
<tr class="separator:gaba935e8a8215c2ebce9a7147fd4f5147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ac339df9c02ae5f11a2a7727adc923"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga90ac339df9c02ae5f11a2a7727adc923">myGPIOK_read</a> (struct file *file_ptr, char *buf, size_t count, loff_t *off)</td></tr>
<tr class="memdesc:ga90ac339df9c02ae5f11a2a7727adc923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legge dati dal device.  <a href="#ga90ac339df9c02ae5f11a2a7727adc923">Continua...</a><br /></td></tr>
<tr class="separator:ga90ac339df9c02ae5f11a2a7727adc923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eea0f6c86e8966ba9b701da57502aad"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga1eea0f6c86e8966ba9b701da57502aad">myGPIOK_write</a> (struct file *file_ptr, const char *buf, size_t size, loff_t *off)</td></tr>
<tr class="memdesc:ga1eea0f6c86e8966ba9b701da57502aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invia dati al device.  <a href="#ga1eea0f6c86e8966ba9b701da57502aad">Continua...</a><br /></td></tr>
<tr class="separator:ga1eea0f6c86e8966ba9b701da57502aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc230a12a97aa63e43b2dc4aec73511"><td class="memItemLeft" align="right" valign="top">static irqreturn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga2fc230a12a97aa63e43b2dc4aec73511">myGPIOK_irq_handler</a> (int irq, struct pt_regs *regs)</td></tr>
<tr class="separator:ga2fc230a12a97aa63e43b2dc4aec73511"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variabili</h2></td></tr>
<tr class="memitem:gae370dfc26b06b6cc24a7bcc152f4969e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#gae370dfc26b06b6cc24a7bcc152f4969e">myGPIOK_dev_ptr</a> = NULL</td></tr>
<tr class="memdesc:gae370dfc26b06b6cc24a7bcc152f4969e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device. ">myGPIOK_t</a>, contenente tutti i dati necessari al device driver.  <a href="#gae370dfc26b06b6cc24a7bcc152f4969e">Continua...</a><br /></td></tr>
<tr class="separator:gae370dfc26b06b6cc24a7bcc152f4969e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434e034e4625b1949f0c626823870a39"><td class="memItemLeft" align="right" valign="top">static dev_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga434e034e4625b1949f0c626823870a39">myGPIOK_Mm_number</a></td></tr>
<tr class="memdesc:ga434e034e4625b1949f0c626823870a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Major e minor number per il device driver.  <a href="#ga434e034e4625b1949f0c626823870a39">Continua...</a><br /></td></tr>
<tr class="separator:ga434e034e4625b1949f0c626823870a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8d1bce7d6389684a037e94381c275c"><td class="memItemLeft" align="right" valign="top">static struct class *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#gaaf8d1bce7d6389684a037e94381c275c">myGPIOK_class</a> = NULL</td></tr>
<tr class="separator:gaaf8d1bce7d6389684a037e94381c275c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d345c792760e3103059b6b6e0bfdaee"><td class="memItemLeft" align="right" valign="top">static struct device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga2d345c792760e3103059b6b6e0bfdaee">myGPIOK_device</a> = NULL</td></tr>
<tr class="separator:ga2d345c792760e3103059b6b6e0bfdaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91f28437e0a553effa546d16fa44f03a"><td class="memItemLeft" align="right" valign="top">static struct of_device_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga91f28437e0a553effa546d16fa44f03a">myGPIOk_match</a> []</td></tr>
<tr class="memdesc:ga91f28437e0a553effa546d16fa44f03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifica il device all'interno del device tree.  <a href="#ga91f28437e0a553effa546d16fa44f03a">Continua...</a><br /></td></tr>
<tr class="separator:ga91f28437e0a553effa546d16fa44f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dba1541b58fa63f8208232ffce4fc47"><td class="memItemLeft" align="right" valign="top">static struct platform_driver&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga8dba1541b58fa63f8208232ffce4fc47">myGPIOK_driver</a></td></tr>
<tr class="memdesc:ga8dba1541b58fa63f8208232ffce4fc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definisce quali funzioni probe() e remove() chiamare quando viene caricato un driver.  <a href="#ga8dba1541b58fa63f8208232ffce4fc47">Continua...</a><br /></td></tr>
<tr class="separator:ga8dba1541b58fa63f8208232ffce4fc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f31111fdb3b4a5944e18d45045e0f01"><td class="memItemLeft" align="right" valign="top">static struct file_operations&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga9f31111fdb3b4a5944e18d45045e0f01">myGPIO_fops</a></td></tr>
<tr class="memdesc:ga9f31111fdb3b4a5944e18d45045e0f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">mantiene puntatori a funzioni che definiscono il gli operatori che agiscono su un file/device.  <a href="#ga9f31111fdb3b4a5944e18d45045e0f01">Continua...</a><br /></td></tr>
<tr class="separator:ga9f31111fdb3b4a5944e18d45045e0f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrizione dettagliata</h2>
<p>Device-driver in kernel-mode per myGPIO. </p>
<h2>Platform-device</h2>
<p>I device driver, anche se sono moduli kernel, non si scrivono come normali moduli Kernel.</p>
<p>I "platform-device" sono device che non possono annunciarsi al software (non possono dire "Hey,
sono qui'!" al sistema operativo), quindi sono intrinsecamente "non-scopribili", nel senso che il sistema, al boot, deve sapere che ci sono, ma non e' in grado di scoprirli. A differenza dei device PCI o USB, che non sono platform-device, un device I²C non viene enumerato a livello hardware, per cui e' necessario che il sistema operativo sappia, a tempo di "compilazione", cioe' prima del boot - quale device sia connesso al bus I²C.</p>
<p>I non-discoverable devices stanno proliferando molto velocemente nel mondo embedded, per cui il Kernel Linux offre ancora la possibilita' di specificare quale hardware sia presente nel sistema. Bisogna distinguere in:</p><ul>
<li>Platform Driver</li>
<li>Platform Device</li>
</ul>
<p>Per quanto riguarda la parte driver, il kernel Linux kernel definisce un insieme di operazioni standard che possono essere effettuate su un platform-device. Un riferimento pue' essere <a href="http://lxr.free-electrons.com/source/include/linux/platform_device.h#L173">http://lxr.free-electrons.com/source/include/linux/platform_device.h#L173</a>.</p>
<p>Le callbacks probe() e remove() costituiscono l'insieme minimo di operazioni che devono essere implementate. Tali funzioni devono avere gli stessi parametri delle due seguenti, ma possono avere nome qualsiasi.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> sample_drv_probe(<span class="keyword">struct</span> platform_device *pdev) {</div>
<div class="line">        <span class="comment">//Empty Probe function.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> sample_drv_remove(<span class="keyword">struct</span> platform_device *pdev) {</div>
<div class="line">        <span class="comment">//Empty remove function.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>La definizione di quali funzioni probe() e remove() chiamare quando viene caricato un driver viene effettuato attraverso la seguente struttura e la chiamata alla macro <a class="el" href="my_g_p_i_o_k_8c.html#a61e890be90fe5582db8048893ca0ebbf">module_platform_driver()</a>, la quale prende in input la struttura seguente ed implementa, al posto nostro, le funzioni module_init() e module_close() standard, chiamate quando il modulo viene caricato o rimosso dal kernel.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>platform_driver sample_pldriver = {</div>
<div class="line">    .probe  = sample_drv_probe,</div>
<div class="line">    .remove = sample_drv_remove,</div>
<div class="line">    .driver = {</div>
<div class="line">        .name  = <a class="code" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>,</div>
<div class="line">    },</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="my_g_p_i_o_k_8c.html#a61e890be90fe5582db8048893ca0ebbf">module_platform_driver</a>(sample_pldriver);</div>
</div><!-- fragment --><p>Si noti DRIVER_NAME: deve essere identica alla stringa indicata, nel device-tree, al campo "compatible".</p>
<p>Affinche' il driver possa essere caricato a caldo, e' necessario aggiungere alla struttura di cui sopra qualche informazione in piu'. Tutti i device-driver devono esporre un ID. A tempo di compilazione, il processo di build estrae queste informazioni dai driver per la preparazione di una tabella. Quando si "inserisce" il device, la tabella viene riferita dal kernel e, se viene trovata una entry corrispondente al driver per quel device, il driver viene caricato ed inizializzato.</p>
<p>Usando la struttura</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>of_device_id device_match[] = {</div>
<div class="line">        {.compatible = <a class="code" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>},</div>
<div class="line">        {},</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="my_g_p_i_o_k_8c.html#a4982cc224a0881ae5d106fce7526fb68">MODULE_DEVICE_TABLE</a>(of, device_match);</div>
</div><!-- fragment --><p>si identifica un particolare device. La macro <a class="el" href="my_g_p_i_o_k_8c.html#a4982cc224a0881ae5d106fce7526fb68">MODULE_DEVICE_TABLE()</a> viene usata per inserire una nuova entry nella tabella accennata precedentemente. Alla struttura platform_driver possono essere aggiunte anche queste informazioni, per cui essa si presentera' come riportato di seguito.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>platform_driver sample_pldriver = {</div>
<div class="line">    .probe  = sample_drv_probe,</div>
<div class="line">    .remove = sample_drv_remove,</div>
<div class="line">    .driver = {</div>
<div class="line">        .name  = <a class="code" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>,</div>
<div class="line">        .owner = THIS_MODULE,</div>
<div class="line">        .of_match_table = device_match,</div>
<div class="line">    },</div>
<div class="line">};</div>
</div><!-- fragment --> <h2 class="groupheader">Documentazione delle definizioni</h2>
<a class="anchor" id="ga25634d21648ca7fb7a2aca614bafaaeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRIVER_NAME&#160;&#160;&#160;&quot;myGPIOK&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nome identificativo del device-driver. DEVE corrispondere al valore del campo "compatible" nel device tree source. </p>

</div>
</div>
<a class="anchor" id="ga605a877d5e63c79a65d4a57d364680b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REQUIRED_MINOR_NUMBER&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numero di minor-number richiesti da driver. </p>

</div>
</div>
<h2 class="groupheader">Documentazione delle funzioni</h2>
<a class="anchor" id="ga2fc230a12a97aa63e43b2dc4aec73511"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static irqreturn_t myGPIOK_irq_handler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct pt_regs *&#160;</td>
          <td class="paramname"><em>regs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td></td></tr>
    <tr><td class="paramname">regs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga66e7f726b72320a272b633ecbaecefff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static loff_t myGPIOK_llseek </td>
          <td>(</td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loff_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementa le system-call lseek() e llseek(). </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'implementazione di read() e write() non sposta la testina di lettura/scrittura!</dd></dl>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_ptr</td><td></td></tr>
    <tr><td class="paramname">off</td><td></td></tr>
    <tr><td class="paramname">whence</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gad013759c18fbf6ea96005b9b3bfa5b4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int myGPIOK_open </td>
          <td>(</td>
          <td class="paramtype">struct inode *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invocata all'apertura del file corrispondente al device. </p>
<h3>Il metodo open()</h3>
<p>Il metodo open di un device driver viene fornito per effettuare ogni inizializzazione necessaria ad operazioni successive. Effettua le seguenti operazioni:</p><ul>
<li>verifica che non si siano manifestati errori;</li>
<li>inizializza il device</li>
<li>aggiorna il puntatore f_op, se necessario;</li>
<li>alloca e popola ogni struttura dati necessaria, ponendola successivamente nel campo private_data della struttura dati file.</li>
</ul>
<p>In primo luogo e' necessario identificare il device che sta per essere aperto. Tenendo presente che il prototipo di qualunque metodo open e'</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int (*open)(struct inode *inode, struct file *filp);</div>
</div><!-- fragment --><p>il parametro inode contiene tutte le informazioni necessarie all'interno del campo i_cdev, il quale contiene la struttura cdev inizializzata precedentemente dalla funzione di probe(). Il problema e' che non abbiamo bisogno della sola struttura cdev, ma della struttura che la contiene, in questo caso della struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device. ">myGPIOK_t</a>. Fortunatamente i programmatori del kernel hanno reso la vita semplice agli altri, predisponendo la macro container_if() definita in &lt;linux/kernel.h&gt;.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;container_of(pointer, container_type, container_field);</div>
</div><!-- fragment --><p>La macro prende in ingresso un puntatore ad un campo di tipo container_field, di una struttura container_type, restituendo il puntatore alla struttura che la contiene.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td></td></tr>
    <tr><td class="paramname">file</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gaba935e8a8215c2ebce9a7147fd4f5147"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int myGPIOK_poll </td>
          <td>(</td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct poll_table_struct *&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifica che le operazioni di lettura/scrittura risultino non-bloccanti. </p>
<p>Questo metodo e' il back-end di tre diverse system-calls: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramname">wait</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>restituisce una maschera di bit che indica se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili. </dd></dl>

</div>
</div>
<a class="anchor" id="gae40973a06d72f7c41a9af07513a62307"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int myGPIOK_probe </td>
          <td>(</td>
          <td class="paramtype">struct platform_device *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Viene chiamata quando il modulo viene inserito. </p>
<p>Inizializza il driver e la periferica. Alloca un oggetto <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device. ">myGPIOK_t</a>, che astrae un device myGPIO, e lo inizializza, associandogli gli operatori che permetteranno di interagire con tale device da user-space.</p>
<h5>Inizializzazione del driver</h5>
<p>Il device GPIO viene gestito come un character-device, ossia un device su cui e' possibile leggere e/o scrivere byte. Il kernel usa, internamente, una struttura cdev per rappresentare i device a caratteri. Prima che il kernel invochi le funzioni definite dal driver per il device, bisogna allocare e registrare uno, o piu', oggetti cdev. Per farlo e' necessario includere &lt;linux/cdev.h&gt;, che definisce tale struttura e le relative funzioni.</p>
<h5>Major-number e Minor-number</h5>
<p>Ai device drivers sono associati un major-number ed un minor-number. Il major-number viene usato dal kernel per identificare il driver corretto corrispondente ad uno specifico device, quando si effettuano operazioni su di esso. Il ruolo del minor number dipende dal device e viene gestito internamente dal driver. Il driver scritto per GPIO non usera' minor-number. La registrazione di un device driver puo' essere effettuata chiamando <b>alloc_chrdev_region()</b>, la quale alloca un char-device numbers. Il major number viene scelto dinamicamente e restituito dalla funzione attraverso il parametro dev. La funzione restituisce un valore negativo nel caso in cui si verifichino errori, 0 altrimenti. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int alloc_chrdev_region (dev_t * dev, unsigned baseminor, unsigned count, const char *name);</div>
</div><!-- fragment --><ul>
<li>dev: major e minor number</li>
<li>baseminor: primo dei minor number richiesti</li>
<li>count: numero di minornumber richiesti</li>
<li>name: nome del device driver</li>
</ul>
<h5>Device Class</h5>
<p>Ai device-drivers viene associata una classe ed un device-name. Per creare ed associare una classe ad un device driver si puo' usare la seguente. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct class * class_create(struct module * owner, const char * name);</div>
</div><!-- fragment --><ul>
<li>owner: puntatore al modulo che "possiede" la classe, THIS_MODULE</li>
<li>name: puntatore alla stringa identificativa (il nome) del device driver, DRIVER_NAME</li>
</ul>
<h5>Operatori</h5>
<p>Essendo un device "visto" come un file, ogni device driver deve implementare tutte le system-call previste per l'interfacciamento con un file. La corrispondenza tra la system-call e la funzione fornita dal driver viene stabilita attraverso la struttura file_operations. La struttura dati file_operations, definita in &lt;linux/fs.h&gt; mantiene puntatori a funzioni definite dal driver che consentono di definire il comportamento degli operatori che agiscono su un file.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;static struct file_operations myGPIO_fops = {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    .owner      = THIS_MODULE,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    .llseek     = driver_seek,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    .read       = driver_read,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    .write      = driver_write,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    .poll       = driver_poll,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    .open       = driver_open,</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    .release    = driver_release</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;};</div>
</div><!-- fragment --><p>Ogni campo della struttura deve puntare ad una funzione del driver che implementa uno specifico "operatore" su file, oppure impostata a NULL se l'operatore non e' supportato. L'esatto comportamento del kernel, quando uno dei puntatori e' NULL, varia da funzione a funzione. La lista seguente introduce tutti gli operatori che un'applicazione puo' invocare su un device. La lista e' stata mantenuta snella, includendo solo i campi strettamente necessari.</p>
<ul>
<li><em>struct module *owner</em> :<br />
 il primo campo della struttura non e' un operatore, ma un puntatore al modulo che "possiede" la struttura. Il campo ha lo scopo di evitare che il modulo venga rimosso dal kernel quando uno degli operatori e' in uso. Viene inizializzato usando la macro THIS_MODULE, definita in &lt;linux/module.h&gt;.</li>
<li><em>loff_t (*llseek) (struct file *, loff_t, int)</em> : il campo llseek e' usato per cambiare la posizione della "testina" di lettura/ scrittura in un file. La funzione restituisce la nuova posizione della testina. loff_t e' un intero a 64 bit (anche su architetture a 32 bit). Eventuali errori vengono segnalati con un valore di ritorno negativo. Se questo campo e' posto a NULL, eventuali chiamate a seek modifigheranno la posizione della testina in un modo impredicibile.</li>
<li><em>ssize_t (*read) (struct file *, char _ _user *, size_t, loff_t *)</em> :<br />
 usata per leggere dati dal device. Se lasciato a NULL, ogni chiamata a read fallira' e non sara' possibile leggere dal device. La funzione restituisce il numero di byte letti con successo ma, nel caso si verifichi un errore, restituisce un numero intero negativo.</li>
<li><em>ssize_t (*write) (struct file *, const char _ _user *, size_t, loff_t *)</em> :<br />
 invia dati al device. Se NULL ogni chiamata alla system-call write causera' un errore. Il valore di ritorno, se non negativo, rappresenta il numero di byte correttamente scritti.</li>
<li><em>unsigned int (*poll) (struct file *, struct poll_table_struct *)</em> :<br />
 questo metodo e' il back-end di tre diverse system-calls: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno. La funzione dovrebbe restituire una maschera che indichi se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili. Se viene lasciata NULL si intende che le operazioni di lettura/scrittura sul device siano sempre non-bloccanti.</li>
<li><em>int (*open) (struct inode *, struct file *)</em> :<br />
 Anche se, di solito, e' la prima operazione che si effettua su un file, non e' strettamente necessaria la sua implementazione. Se lasciata NULL, l'apertura del device andra' comunque a buon fine, ma al driver non verra' inviata alcuna notifica.</li>
<li><em>int (*release) (struct inode *, struct file *)</em> :<br />
 questo operatore viene invocato quando il file viene rilasciato. Come open, puo' essere lasciato NULL.</li>
</ul>
<p>L'inizializzazione di un device a caratteri passa anche attraverso la definizione di questo tipo di operatori. Essi possono essere impostati attraverso l'uso della funzione </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void cdev_init (struct cdev *cdev, const struct file_operations *fops);</div>
</div><!-- fragment --><p> la quale prende, come parametri</p><ul>
<li>cdev: puntatore a struttura cdev da inizializzare;</li>
<li>fops: puntatore a struttura file_operation con cui inizializzare il device.</li>
</ul>
<h5>Aggiunta del device</h5>
<p>Il driver, a questo punto, e' pronto per essere aggiunto. E' possibile aggiungere il driver usando </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int cdev_add (struct cdev *p, dev_t dev, unsigned count);</div>
</div><!-- fragment --><p> La quale accetta come parametri</p><ul>
<li>p: puntatore a struttura cdev structure per il device</li>
<li>dev: device number (precedentemente inizializzato usando la funzione <em>alloc_chrdev_region()</em>)</li>
<li>count: numero di minor-numbers richiesti per il device</li>
</ul>
<p>La funzione restituisce un numero negativo in caso di errore.</p>
<p>Il passo successivo e' la registrazione del device e la sua aggiunta al filesystem. Tale operazione puo' essere effettuata chiamando </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct device * device_create( struct class *class, struct device *parent, dev_t devt, const char *fmt, ...)</div>
</div><!-- fragment --><ul>
<li>class: puntatore alla struttura class alla quale il device deve essere registrato</li>
<li>parent: puntatore ad eventuale device parent</li>
<li>devt: tmajor number</li>
<li>fmt: nome del device.</li>
</ul>
<p>La funzione pu' essere usata solo sulla classe dei device a caratteri. Crea un device all'interno del filesystem, associandogli il major number preventivamente inizializzato. La funzione restituisce il puntatore alla struttura device creata all'interno del filesystem. Si noti che il puntatre alla struttura classes DEVE essere stato precedentemente creato attraverso una chiamata alla funzione <em>class_create()</em>.</p>
<h5>Accedere al segmento di memoria a cui la periferica e' mappata</h5>
<p>Un driver, tipicamente, prende possesso del segmento di memoria cui e' mappato il device con la funzione di probe. Il problema e' che il device e' mappato ad un indirizzo di memoria fisico ed il Kernel, così come qualsiasi altro programma, lavora su indirizzi di memoria virtuali. La funzione</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int of_address_to_resource(struct device_node *node, int index, struct resource *r);</div>
</div><!-- fragment --><p>popola una struttura resource con l'indirizzo di memoria cui e' mapato il device usando le informazioni contenute all'interno del device tree. Ad esempio, se il device tree contiene </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;reg = &lt;0x41200000 0x10000&gt;;</div>
</div><!-- fragment --><p> signidifa che l'indirizzo fisico associato al device e' l'indirizzo 0x41200000, che al device sono riservati 0x10000 bytes. of_address_to_resource() settera' res.start = 0x41200000 e res.end = 0x4120ffff.</p>
<p>Le regioni di memoria per di I/O vanno allocate prima di poter essere usate.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct resource *request_mem_region(unsigned long start, unsigned long len, char *name);</div>
</div><!-- fragment --><p>Questa funzione alloca una regione di memoria di len byte a partire da start restituendone l'indirizzo, mentre nel caso in cui si verifichi un errore viene restituito NULL. La funzione viene chiamata per ottenere l'accesso esclusivo della regione di memoria, per evitare che driver diversi tentino di accedere allo stesso spazio di memoria.</p>
<p>L'allocazione dello spazio di memoria non e' l'unico step da eseguire prima che tale memoria possa essere usata. E' necessario fare in modo che sia resa accessibile al kernel attraverso un mapping, usando la funzione.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void *ioremap(unsigned long phys_addr, unsigned long size);</div>
</div><!-- fragment --><ul>
<li><h5>Interrupts</h5>
</li>
</ul>
<p>The LKM driver must register a handler function for the interrupt, which defines the actions that the interrupt should perform. L'handler deve essere compatibile con il tipo puntatore a funzione irq_handler_t, così definito. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct irqreturn_t (*irq_handler_t)(int irq, struct pt_regs * regs);</div>
</div><!-- fragment --><p> Il modulo definisce la funzione <a class="el" href="group___kernel-_module.html#ga2fc230a12a97aa63e43b2dc4aec73511">myGPIOK_irq_handler()</a>. L'handler puo' essere registrato usando</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int request_irq(    unsigned int irqNumber,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;                    irqreturn_t (*handler)(int, void *, struct pt_regs *),</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;                    unsigned long irqflags,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;                    const char *devname,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;                    void *dev_id);</div>
</div><!-- fragment --><p>IL parametro irqNumber puo' essere determinato automaticamente usando la funzione</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;unsigned int irq_of_parse_and_map(struct device_node *node, int index);</div>
</div><!-- fragment --><p>La funzione irq_of_parse_and_map() effettua un looks-up nella specifica degli interrupt all'interno del device tree e restituisce un irq number cosi' come de lo aspetta request_irq() (cioe' compaci con l'enumerazione in /proc/interrupts). Il secondo argomento della funzione e', tipicamente, zero, ad indicare che, all'interno del device tree, verra' preso in considerazione soltanto il primo degli interrupt specificate. Il device tree, nella sezione dedicata al gpio,reca </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;interrupts = &lt;0 29 4&gt;;</div>
</div><!-- fragment --><p>Il primo numero (0) e' un flag che indica se l'interrupt sia connesso ad una line SPI (shared peripheral interrupt). Un valore diverso da zero indica che la linea e' SPI.</p>
<p>Il secondo numero si riferisce all'interrupt number. Per farla breve, quando si definisce la parte hardware, in questo specifico esempio il device GPIO e' connesso alla linea 61 del GIC. Sottraendo 32 si orriene 29.</p>
<p>Il terzo numero si riferisce alla tipologia dell'interrupt. Sono possibili tre valori:</p><ul>
<li>0 : power-up default</li>
<li>1 : rising-edge</li>
<li>4 : a livelli, active alto</li>
</ul>
<dl class="retval"><dt>Valori di ritorno</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>nel caso in cui non si sia verificato nessun errore; </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>nel caso in cui non sia possibile allocare memoria; </td></tr>
    <tr><td class="paramname">&lt;0</td><td>per altri errori </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90ac339df9c02ae5f11a2a7727adc923"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t myGPIOK_read </td>
          <td>(</td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loff_t *&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Legge dati dal device. </p>
<h3>Operazioni di lettura e scrittura</h3>
<p>I metodi read() e write() effettuano operazioni simili, ossia copiare dati da/verso il device. Il loro prototipo e' molto simile.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ssize_t read(struct file *filp, char __user *buff, size_t count, loff_t *offp);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;ssize_t write(struct file *filp, const char __user *buff, size_t count, loff_t *offp);</div>
</div><!-- fragment --><p>Per entrambi i metodifilep e' il puntatore al file che rapresenta il device, count e' la dimensione dei dati da trasferire, buff e' il puntatore al buffer contenente i dati (da scrivere per la write() o letti per la read()). Infine offp e' il puntatore ad un oggetto "long offset type" che indica la posizione alla quale si sta effettuando l'accesso.</p>
<p>Buff e' un puntatore appartenente allo spazio di indirizzamento del programma user-space che utilizza il modulo kernel. Il modulo, quindi, non puo' accedere direttamente ad esso, dereferenziandolo, per diverse ragioni, tra le quali:</p><ul>
<li>a seconda dell'architettura sulla quale il driver e' in esecuzione e di come il kernel e' stato configurato, il puntatore userspace potrebbe non essere valido mentre il modulo kernel viene eseguito;</li>
<li>la memoria user-space e' paginata e potrebbe non essere presente in RAM quando la system-call viene effettuata, per cui dereferenziando il puntatore potrebbe originarsi un page-fault con conseguente terminazione del processo che ha effettuato la system-call;</li>
<li>il puntatore in questione potrebbe essere stato fornito da un programma user-space buggato o malizioso, motivo per cui dereferenziandolo verrebbe a crearsi un punto di accesso attraverso il quale il programma userspace puo' modificare la memoria senza costrizioni.</li>
</ul>
<p>Ovviamente il driver deve essere in grado di poter accedere al buffer userspace, per cui tale accesso va fatto solo ed esclusivamente attraverso delle funzioni fornite dal kernel stesso, e definite in &lt;asm/uaccess.h&gt;</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;unsigned long copy_to_user(void __user *to, const void *from, unsigned long count);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;unsigned long copy_from_user(void *to, const void __user *from, unsigned long count);</div>
</div><!-- fragment --><p>Queste due funzioni non si limitano a copiare dati da/verso userspacem: verificano, infatti, anche che il puntatore al buffer userspace sia valido. Se il puntatore non risultasse valido la copia non viene effettuata.</p>
<p>Sia il metodo read() che il metodo write() restituiscono un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte trasferiti con successo.</p>
<h5>Accesso ai registri del device</h5>
<p>Si potrebbe senrire la tentazione di usare il puntatore restituito da ioremap() dereferenziandolo per accedere alla memoria. Questo modo di procedere non e' portabile ed e' prono ad errori. Il modo corretto di accedere alla memoria e' attraverso l'uso delle funzioni per il memory-mapped I/O, definite in &lt;asm/io.h&gt;.</p>
<p>Per leggere dalla memoria vengono usate le seguenti:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;unsigned int ioread8(void *addr);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;unsigned int ioread16(void *addr);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;unsigned int ioread32(void *addr);</div>
</div><!-- fragment --><p>addr e' l'indirizzo di memoria virtuale del device, ottenuto mediante chiamata a ioremap(), a cui viene, eventualmente, aggiunto un offset. Il valore restituito dalle funzioni e' quello letto dalla particolare locazione di memoria a cui viene effettuato accesso.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ppos</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>restituisce un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte scritti con successo. </dd></dl>

</div>
</div>
<a class="anchor" id="ga17ce7f574723246c790b70b06e3e7103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int myGPIOK_release </td>
          <td>(</td>
          <td class="paramtype">struct inode *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invocata alla chiusura del file corrispondente al device. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td></td></tr>
    <tr><td class="paramname">file</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga59fddfaa36dea357f4bbdfceb0f47f8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int myGPIOK_remove </td>
          <td>(</td>
          <td class="paramtype">struct platform_device *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Viene chiamata automaticamente alla rimozione del mosulo.</p>
<p>Dealloca tutta la memoria utilizzata dal driver, de-inizializzando il device. </p>

</div>
</div>
<a class="anchor" id="ga1eea0f6c86e8966ba9b701da57502aad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t myGPIOK_write </td>
          <td>(</td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loff_t *&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invia dati al device. </p>
<h3>Operazioni di lettura e scrittura</h3>
<p>I metodi read() e write() effettuano operazioni simili, ossia copiare dati da/verso il device. Il loro prototipo e' molto simile.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ssize_t read(struct file *filp, char __user *buff, size_t count, loff_t *offp);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;ssize_t write(struct file *filp, const char __user *buff, size_t count, loff_t *offp);</div>
</div><!-- fragment --><p>Per entrambi i metodifilep e' il puntatore al file che rapresenta il device, count e' la dimensione dei dati da trasferire, buff e' il puntatore al buffer contenente i dati (da scrivere per la write() o letti per la read()). Infine offp e' il puntatore ad un oggetto "long offset type" che indica la posizione alla quale si sta effettuando l'accesso.</p>
<p>Buff e' un puntatore appartenente allo spazio di indirizzamento del programma user-space che utilizza il modulo kernel. Il modulo, quindi, non puo' accedere direttamente ad esso, dereferenziandolo, per diverse ragioni, tra le quali:</p><ul>
<li>a seconda dell'architettura sulla quale il driver e' in esecuzione e di come il kernel e' stato configurato, il puntatore userspace potrebbe non essere valido mentre il modulo kernel viene eseguito;</li>
<li>la memoria user-space e' paginata e potrebbe non essere presente in RAM quando la system-call viene effettuata, per cui dereferenziando il puntatore potrebbe originarsi un page-fault con conseguente terminazione del processo che ha effettuato la system-call;</li>
<li>il puntatore in questione potrebbe essere stato fornito da un programma user-space buggato o malizioso, motivo per cui dereferenziandolo verrebbe a crearsi un punto di accesso attraverso il quale il programma userspace puo' modificare la memoria senza costrizioni.</li>
</ul>
<p>Ovviamente il driver deve essere in grado di poter accedere al buffer userspace, per cui tale accesso va fatto solo ed esclusivamente attraverso delle funzioni fornite dal kernel stesso, e definite in &lt;asm/uaccess.h&gt;</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;unsigned long copy_to_user(void __user *to, const void *from, unsigned long count);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;unsigned long copy_from_user(void *to, const void __user *from, unsigned long count);</div>
</div><!-- fragment --><p>Queste due funzioni non si limitano a copiare dati da/verso userspacem: verificano, infatti, anche che il puntatore al buffer userspace sia valido. Se il puntatore non risultasse valido la copia non viene effettuata.</p>
<p>Sia il metodo read() che il metodo write() restituiscono un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte trasferiti con successo.</p>
<h5>Accesso ai registri del device</h5>
<p>Si potrebbe senrire la tentazione di usare il puntatore restituito da ioremap() dereferenziandolo per accedere alla memoria. Questo modo di procedere non e' portabile ed e' prono ad errori. Il modo corretto di accedere alla memoria e' attraverso l'uso delle funzioni per il memory-mapped I/O, definite in &lt;asm/io.h&gt;.</p>
<p>Per scrivere nella memoria vengono usate le seguenti:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void iowrite8(u8 value, void *addr);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;void iowrite16(u16 value, void *addr);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;void iowrite32(u32 value, void *addr);</div>
</div><!-- fragment --><p>addr e' l'indirizzo di memoria virtuale del device, ottenuto mediante chiamata a ioremap(), a cui viene, eventualmente, aggiunto un offset. value e' il valore che verra' scritto alla particolare locazione di memoria a cui viene effettuato accesso.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">off</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>restituisce un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte scritti con successo. </dd></dl>

</div>
</div>
<h2 class="groupheader">Documentazione delle variabili</h2>
<a class="anchor" id="ga9f31111fdb3b4a5944e18d45045e0f01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct file_operations myGPIO_fops</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Valore iniziale:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        .owner      = THIS_MODULE,</div>
<div class="line">        .llseek     = <a class="code" href="group___kernel-_module.html#ga66e7f726b72320a272b633ecbaecefff">myGPIOK_llseek</a>,</div>
<div class="line">        .read       = <a class="code" href="group___kernel-_module.html#ga90ac339df9c02ae5f11a2a7727adc923">myGPIOK_read</a>,</div>
<div class="line">        .write      = <a class="code" href="group___kernel-_module.html#ga1eea0f6c86e8966ba9b701da57502aad">myGPIOK_write</a>,</div>
<div class="line">        .poll       = <a class="code" href="group___kernel-_module.html#gaba935e8a8215c2ebce9a7147fd4f5147">myGPIOK_poll</a>,</div>
<div class="line">        .open       = <a class="code" href="group___kernel-_module.html#gad013759c18fbf6ea96005b9b3bfa5b4e">myGPIOK_open</a>,</div>
<div class="line">        .release    = <a class="code" href="group___kernel-_module.html#ga17ce7f574723246c790b70b06e3e7103">myGPIOK_release</a></div>
<div class="line">}</div>
<div class="ttc" id="group___kernel-_module_html_ga66e7f726b72320a272b633ecbaecefff"><div class="ttname"><a href="group___kernel-_module.html#ga66e7f726b72320a272b633ecbaecefff">myGPIOK_llseek</a></div><div class="ttdeci">static loff_t myGPIOK_llseek(struct file *file_ptr, loff_t off, int whence)</div><div class="ttdoc">Implementa le system-call lseek() e llseek(). </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:721</div></div>
<div class="ttc" id="group___kernel-_module_html_ga17ce7f574723246c790b70b06e3e7103"><div class="ttname"><a href="group___kernel-_module.html#ga17ce7f574723246c790b70b06e3e7103">myGPIOK_release</a></div><div class="ttdeci">static int myGPIOK_release(struct inode *inode, struct file *file_ptr)</div><div class="ttdoc">Invocata alla chiusura del file corrispondente al device. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:705</div></div>
<div class="ttc" id="group___kernel-_module_html_gad013759c18fbf6ea96005b9b3bfa5b4e"><div class="ttname"><a href="group___kernel-_module.html#gad013759c18fbf6ea96005b9b3bfa5b4e">myGPIOK_open</a></div><div class="ttdeci">static int myGPIOK_open(struct inode *inode, struct file *file_ptr)</div><div class="ttdoc">Invocata all&#39;apertura del file corrispondente al device. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:684</div></div>
<div class="ttc" id="group___kernel-_module_html_ga90ac339df9c02ae5f11a2a7727adc923"><div class="ttname"><a href="group___kernel-_module.html#ga90ac339df9c02ae5f11a2a7727adc923">myGPIOK_read</a></div><div class="ttdeci">static ssize_t myGPIOK_read(struct file *file_ptr, char *buf, size_t count, loff_t *ppos)</div><div class="ttdoc">Legge dati dal device. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:858</div></div>
<div class="ttc" id="group___kernel-_module_html_gaba935e8a8215c2ebce9a7147fd4f5147"><div class="ttname"><a href="group___kernel-_module.html#gaba935e8a8215c2ebce9a7147fd4f5147">myGPIOK_poll</a></div><div class="ttdeci">static unsigned int myGPIOK_poll(struct file *file_ptr, struct poll_table_struct *wait)</div><div class="ttdoc">Verifica che le operazioni di lettura/scrittura risultino non-bloccanti. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:768</div></div>
<div class="ttc" id="group___kernel-_module_html_ga1eea0f6c86e8966ba9b701da57502aad"><div class="ttname"><a href="group___kernel-_module.html#ga1eea0f6c86e8966ba9b701da57502aad">myGPIOK_write</a></div><div class="ttdeci">static ssize_t myGPIOK_write(struct file *file_ptr, const char *buf, size_t size, loff_t *off)</div><div class="ttdoc">Invia dati al device. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:961</div></div>
</div><!-- fragment -->
<p>mantiene puntatori a funzioni che definiscono il gli operatori che agiscono su un file/device. </p>
<p>Essendo un device "visto" come un file, ogni device driver deve implementare tutte le system-call previste per l'interfacciamento con un file. La corrispondenza tra la system-call e la funzione fornita dal driver viene stabilita attraverso tale struttura. La struttura dati file_operations, definita in &lt;linux/fs.h&gt; mantiene puntatori a funzioni definite dal driver che consentono di definire il comportamento degli operatori che agiscono su un file. </p>

</div>
</div>
<a class="anchor" id="gaaf8d1bce7d6389684a037e94381c275c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct class* myGPIOK_class = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gae370dfc26b06b6cc24a7bcc152f4969e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmy_g_p_i_o_k__t.html">myGPIOK_t</a>* myGPIOK_dev_ptr = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puntatore a struttura <a class="el" href="structmy_g_p_i_o_k__t.html" title="Stuttura per l&#39;astrazione di un device. ">myGPIOK_t</a>, contenente tutti i dati necessari al device driver. </p>

</div>
</div>
<a class="anchor" id="ga2d345c792760e3103059b6b6e0bfdaee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct device* myGPIOK_device = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8dba1541b58fa63f8208232ffce4fc47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct platform_driver myGPIOK_driver</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Valore iniziale:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        .probe = <a class="code" href="group___kernel-_module.html#gae40973a06d72f7c41a9af07513a62307">myGPIOK_probe</a>,</div>
<div class="line">        .remove = <a class="code" href="group___kernel-_module.html#ga59fddfaa36dea357f4bbdfceb0f47f8c">myGPIOK_remove</a>,</div>
<div class="line">        .driver = {</div>
<div class="line">                .name = <a class="code" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>,</div>
<div class="line">                .owner = THIS_MODULE,</div>
<div class="line">                .of_match_table = <a class="code" href="group___kernel-_module.html#ga91f28437e0a553effa546d16fa44f03a">myGPIOk_match</a>,</div>
<div class="line">        },</div>
<div class="line">}</div>
<div class="ttc" id="group___kernel-_module_html_ga91f28437e0a553effa546d16fa44f03a"><div class="ttname"><a href="group___kernel-_module.html#ga91f28437e0a553effa546d16fa44f03a">myGPIOk_match</a></div><div class="ttdeci">static struct of_device_id myGPIOk_match[]</div><div class="ttdoc">Identifica il device all&#39;interno del device tree. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:245</div></div>
<div class="ttc" id="group___kernel-_module_html_ga59fddfaa36dea357f4bbdfceb0f47f8c"><div class="ttname"><a href="group___kernel-_module.html#ga59fddfaa36dea357f4bbdfceb0f47f8c">myGPIOK_remove</a></div><div class="ttdeci">static int myGPIOK_remove(struct platform_device *op)</div><div class="ttdef"><b>Definition:</b> myGPIOK.c:631</div></div>
<div class="ttc" id="group___kernel-_module_html_gae40973a06d72f7c41a9af07513a62307"><div class="ttname"><a href="group___kernel-_module.html#gae40973a06d72f7c41a9af07513a62307">myGPIOK_probe</a></div><div class="ttdeci">static int myGPIOK_probe(struct platform_device *op)</div><div class="ttdoc">Viene chiamata quando il modulo viene inserito. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:520</div></div>
<div class="ttc" id="group___kernel-_module_html_ga25634d21648ca7fb7a2aca614bafaaeb"><div class="ttname"><a href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a></div><div class="ttdeci">#define DRIVER_NAME</div><div class="ttdoc">Nome identificativo del device-driver. DEVE corrispondere al valore del campo "compatible" nel device...</div><div class="ttdef"><b>Definition:</b> myGPIOK.c:208</div></div>
</div><!-- fragment -->
<p>Definisce quali funzioni probe() e remove() chiamare quando viene caricato un driver. </p>

</div>
</div>
<a class="anchor" id="ga91f28437e0a553effa546d16fa44f03a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct of_device_id myGPIOk_match[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Valore iniziale:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        {.compatible = <a class="code" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>},</div>
<div class="line">        {},</div>
<div class="line">}</div>
<div class="ttc" id="group___kernel-_module_html_ga25634d21648ca7fb7a2aca614bafaaeb"><div class="ttname"><a href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a></div><div class="ttdeci">#define DRIVER_NAME</div><div class="ttdoc">Nome identificativo del device-driver. DEVE corrispondere al valore del campo "compatible" nel device...</div><div class="ttdef"><b>Definition:</b> myGPIOK.c:208</div></div>
</div><!-- fragment -->
<p>Identifica il device all'interno del device tree. </p>
<p>Tutti i device-driver devono esporre un ID. A tempo di compilazione, il processo di build estrae queste informazioni dai driver per la preparazione di una tabella. Quando si "inserisce" il device, la tabella viene riferita dal kernel e, se viene trovata una entry corrispondente al driver per quel device, il driver viene caricato ed inizializzato. </p>

</div>
</div>
<a class="anchor" id="ga434e034e4625b1949f0c626823870a39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dev_t myGPIOK_Mm_number</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Major e minor number per il device driver. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generato Lun 19 Giu 2017 13:14:08 per Zynq-7000 Driver Pack da
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
