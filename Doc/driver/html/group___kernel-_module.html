<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Zynq-7000 Driver Pack: Kernel-Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Zynq-7000 Driver Pack
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">C implementation of some Driver for Zynq-7000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Cerca');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Pagina&#160;Principale</span></a></li>
      <li><a href="modules.html"><span>Moduli</span></a></li>
      <li><a href="annotated.html"><span>Strutture&#160;dati</span></a></li>
      <li><a href="files.html"><span>File</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Cerca" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___kernel-_module.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Tutto</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Strutture dati</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>File</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Funzioni</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variabili</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Tipi enumerati (enum)</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Valori del tipo enumerato</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Definizioni</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Gruppi</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Definizioni</a> &#124;
<a href="#func-members">Funzioni</a> &#124;
<a href="#var-members">Variabili</a>  </div>
  <div class="headertitle">
<div class="title">Kernel-Module<div class="ingroups"><a class="el" href="group__my_g_p_i_o.html">MyGPIO</a> &raquo; <a class="el" href="group___linux-_driver.html">Linux-Driver</a> &raquo; <a class="el" href="group___kernel-_driver.html">Kernel-Driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Device-driver in kernel-mode per myGPIO.  
<a href="#details">Continua...</a></p>
<div class="dynheader">
Diagramma di collaborazione per Kernel-Module:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___kernel-_module.png" border="0" alt="" usemap="#group______kernel-__module"/>
<map name="group______kernel-__module" id="group______kernel-__module">
<area shape="rect" id="node1" href="group___kernel-_driver.html" title="Kernel&#45;Driver" alt="" coords="5,5,104,32"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Definizioni</h2></td></tr>
<tr class="memitem:ga25634d21648ca7fb7a2aca614bafaaeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>&#160;&#160;&#160;&quot;myGPIOK&quot;</td></tr>
<tr class="memdesc:ga25634d21648ca7fb7a2aca614bafaaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nome identificativo del device-driver. DEVE corrispondere al valore del campo "compatible" nel device tree source.  <a href="#ga25634d21648ca7fb7a2aca614bafaaeb">Continua...</a><br /></td></tr>
<tr class="separator:ga25634d21648ca7fb7a2aca614bafaaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funzioni</h2></td></tr>
<tr class="memitem:gae40973a06d72f7c41a9af07513a62307"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#gae40973a06d72f7c41a9af07513a62307">myGPIOK_probe</a> (struct platform_device *op)</td></tr>
<tr class="memdesc:gae40973a06d72f7c41a9af07513a62307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Viene chiamata quando il modulo viene inserito.  <a href="#gae40973a06d72f7c41a9af07513a62307">Continua...</a><br /></td></tr>
<tr class="separator:gae40973a06d72f7c41a9af07513a62307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59fddfaa36dea357f4bbdfceb0f47f8c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga59fddfaa36dea357f4bbdfceb0f47f8c">myGPIOK_remove</a> (struct platform_device *op)</td></tr>
<tr class="separator:ga59fddfaa36dea357f4bbdfceb0f47f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4982cc224a0881ae5d106fce7526fb68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga4982cc224a0881ae5d106fce7526fb68">MODULE_DEVICE_TABLE</a> (of, <a class="el" href="group___kernel-_module.html#ga91f28437e0a553effa546d16fa44f03a">myGPIOk_match</a>)</td></tr>
<tr class="separator:ga4982cc224a0881ae5d106fce7526fb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e890be90fe5582db8048893ca0ebbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga61e890be90fe5582db8048893ca0ebbf">module_platform_driver</a> (<a class="el" href="group___kernel-_module.html#ga8dba1541b58fa63f8208232ffce4fc47">myGPIOK_driver</a>)</td></tr>
<tr class="separator:ga61e890be90fe5582db8048893ca0ebbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee309b7824d1efb418d9aa5e8c888c7c"><td class="memItemLeft" align="right" valign="top">static loff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#gaee309b7824d1efb418d9aa5e8c888c7c">myGPIOK_seek</a> (struct file *file, loff_t off, int whence)</td></tr>
<tr class="memdesc:gaee309b7824d1efb418d9aa5e8c888c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">usato per cambiare la posizione della "testina" di lettura/scrittura in un file.  <a href="#gaee309b7824d1efb418d9aa5e8c888c7c">Continua...</a><br /></td></tr>
<tr class="separator:gaee309b7824d1efb418d9aa5e8c888c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac03e8e943c9886549d64625253b8c4bf"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#gac03e8e943c9886549d64625253b8c4bf">myGPIOK_read</a> (struct file *file, char *buf, size_t count, loff_t *ppos)</td></tr>
<tr class="memdesc:gac03e8e943c9886549d64625253b8c4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">legge dati dal device.  <a href="#gac03e8e943c9886549d64625253b8c4bf">Continua...</a><br /></td></tr>
<tr class="separator:gac03e8e943c9886549d64625253b8c4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93f7a4111f4555747323e4afcb1343fd"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga93f7a4111f4555747323e4afcb1343fd">myGPIOK_write</a> (struct file *file, const char *buf, size_t size, loff_t *off)</td></tr>
<tr class="memdesc:ga93f7a4111f4555747323e4afcb1343fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invia dati al device.  <a href="#ga93f7a4111f4555747323e4afcb1343fd">Continua...</a><br /></td></tr>
<tr class="separator:ga93f7a4111f4555747323e4afcb1343fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a9fd0cd8497c6fb4415ffcf0733270"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga27a9fd0cd8497c6fb4415ffcf0733270">myGPIOK_poll</a> (struct file *file, struct poll_table_struct *wait)</td></tr>
<tr class="memdesc:ga27a9fd0cd8497c6fb4415ffcf0733270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica che le operazioni di lettura/scrittura risultino non-bloccanti.  <a href="#ga27a9fd0cd8497c6fb4415ffcf0733270">Continua...</a><br /></td></tr>
<tr class="separator:ga27a9fd0cd8497c6fb4415ffcf0733270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa7d2d19eb7034855c87a17e433918d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga7aa7d2d19eb7034855c87a17e433918d">myGPIOK_open</a> (struct inode *inode, struct file *file)</td></tr>
<tr class="memdesc:ga7aa7d2d19eb7034855c87a17e433918d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invocata all'apertura del file corrispondente al device.  <a href="#ga7aa7d2d19eb7034855c87a17e433918d">Continua...</a><br /></td></tr>
<tr class="separator:ga7aa7d2d19eb7034855c87a17e433918d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf310cbdd4b64b3e108ed0cd67374fa9b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#gaf310cbdd4b64b3e108ed0cd67374fa9b">myGPIOK_release</a> (struct inode *inode, struct file *file)</td></tr>
<tr class="memdesc:gaf310cbdd4b64b3e108ed0cd67374fa9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invocata alla chiusura del file corrispondente al device.  <a href="#gaf310cbdd4b64b3e108ed0cd67374fa9b">Continua...</a><br /></td></tr>
<tr class="separator:gaf310cbdd4b64b3e108ed0cd67374fa9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variabili</h2></td></tr>
<tr class="memitem:ga91f28437e0a553effa546d16fa44f03a"><td class="memItemLeft" align="right" valign="top">static struct of_device_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga91f28437e0a553effa546d16fa44f03a">myGPIOk_match</a> []</td></tr>
<tr class="memdesc:ga91f28437e0a553effa546d16fa44f03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifica il device all'interno del device tree.  <a href="#ga91f28437e0a553effa546d16fa44f03a">Continua...</a><br /></td></tr>
<tr class="separator:ga91f28437e0a553effa546d16fa44f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dba1541b58fa63f8208232ffce4fc47"><td class="memItemLeft" align="right" valign="top">static struct platform_driver&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga8dba1541b58fa63f8208232ffce4fc47">myGPIOK_driver</a></td></tr>
<tr class="memdesc:ga8dba1541b58fa63f8208232ffce4fc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definisce quali funzioni probe() e remove() chiamare quando viene caricato un driver.  <a href="#ga8dba1541b58fa63f8208232ffce4fc47">Continua...</a><br /></td></tr>
<tr class="separator:ga8dba1541b58fa63f8208232ffce4fc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f31111fdb3b4a5944e18d45045e0f01"><td class="memItemLeft" align="right" valign="top">static struct file_operations&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel-_module.html#ga9f31111fdb3b4a5944e18d45045e0f01">myGPIO_fops</a></td></tr>
<tr class="memdesc:ga9f31111fdb3b4a5944e18d45045e0f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">definisce la corrispondenza tra funzioni kernel e funzioni driver.  <a href="#ga9f31111fdb3b4a5944e18d45045e0f01">Continua...</a><br /></td></tr>
<tr class="separator:ga9f31111fdb3b4a5944e18d45045e0f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrizione dettagliata</h2>
<p>Device-driver in kernel-mode per myGPIO. </p>
<h2>Platform-device</h2>
<p>I device driver, anche se sono moduli kernel, non si scrivono come normali moduli Kernel.</p>
<p>I "platform-device" sono device che non possono annunciarsi al software (non possono dire "Hey,
sono qui'!" al sistema operativo), quindi sono intrinsecamente "non-scopribili", nel senso che il sistema, al boot, deve sapere che ci sono, ma non e' in grado di scoprirli. A differenza dei device PCI o USB, che non sono platform-device, un device I²C non viene enumerato a livello hardware, per cui e' necessario che il sistema operativo sappia, a tempo di "compilazione", cioe' prima del boot - quale device sia connesso al bus I²C.</p>
<p>I non-discoverable devices stanno proliferando molto velocemente nel mondo embedded, per cui il Kernel Linux offre ancora la possibilita' di specificare quale hardware sia presente nel sistema. Bisogna distinguere in:</p><ul>
<li>Platform Driver</li>
<li>Platform Device</li>
</ul>
<p>Per quanto riguarda la parte driver, il kernel Linux kernel definisce un insieme di operazioni standard che possono essere effettuate su un platform-device. Un riferimento pue' essere <a href="http://lxr.free-electrons.com/source/include/linux/platform_device.h#L173">http://lxr.free-electrons.com/source/include/linux/platform_device.h#L173</a>.</p>
<p>Le callbacks probe() e remove() costituiscono l'insieme minimo di operazioni che devono essere implementate. Tali funzioni devono avere gli stessi parametri delle due seguenti, ma possono avere nome qualsiasi.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> sample_drv_probe(<span class="keyword">struct</span> platform_device *pdev) {</div>
<div class="line">        <span class="comment">//Empty Probe function.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> sample_drv_remove(<span class="keyword">struct</span> platform_device *pdev) {</div>
<div class="line">        <span class="comment">//Empty remove function.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>La definizione di quali funzioni probe() e remove() chiamare quando viene caricato un driver viene effettuato attraverso la seguente struttura e la chiamata alla macro <a class="el" href="group___kernel-_module.html#ga61e890be90fe5582db8048893ca0ebbf">module_platform_driver()</a>, la quale prende in input la struttura seguente ed implementa, al posto nostro, le funzioni module_init() e module_close() standard, chiamate quando il modulo viene caricato o rimosso dal kernel.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>platform_driver sample_pldriver = {</div>
<div class="line">    .probe  = sample_drv_probe,</div>
<div class="line">    .remove = sample_drv_remove,</div>
<div class="line">    .driver = {</div>
<div class="line">        .name  = <a class="code" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>,</div>
<div class="line">    },</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group___kernel-_module.html#ga61e890be90fe5582db8048893ca0ebbf">module_platform_driver</a>(sample_pldriver);</div>
</div><!-- fragment --><p>Si noti DRIVER_NAME: deve essere identica alla stringa indicata, nel device-tree, al campo "compatible".</p>
<p>Affinche' il driver possa essere caricato a caldo, e' necessario aggiungere alla struttura di cui sopra qualche informazione in piu'. Tutti i device-driver devono esporre un ID. A tempo di compilazione, il processo di build estrae queste informazioni dai driver per la preparazione di una tabella. Quando si "inserisce" il device, la tabella viene riferita dal kernel e, se viene trovata una entry corrispondente al driver per quel device, il driver viene caricato ed inizializzato.</p>
<p>Usando la struttura</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>of_device_id device_match[] = {</div>
<div class="line">        {.compatible = <a class="code" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>},</div>
<div class="line">        {},</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group___kernel-_module.html#ga4982cc224a0881ae5d106fce7526fb68">MODULE_DEVICE_TABLE</a>(of, device_match);</div>
</div><!-- fragment --><p>si identifica un particolare device. La macro <a class="el" href="group___kernel-_module.html#ga4982cc224a0881ae5d106fce7526fb68">MODULE_DEVICE_TABLE()</a> viene usata per inserire una nuova entry nella tabella accennata precedentemente. Alla struttura platform_driver possono essere aggiunte anche queste informazioni, per cui essa si presentera' come riportato di seguito.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>platform_driver sample_pldriver = {</div>
<div class="line">    .probe  = sample_drv_probe,</div>
<div class="line">    .remove = sample_drv_remove,</div>
<div class="line">    .driver = {</div>
<div class="line">        .name  = <a class="code" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>,</div>
<div class="line">        .owner = THIS_MODULE,</div>
<div class="line">        .of_match_table = device_match,</div>
<div class="line">    },</div>
<div class="line">};</div>
</div><!-- fragment --><h2>Inizializzazione del driver - probe()</h2>
<h3>Corrispondenza tra funzioni kernel e funzioni driver.</h3>
<p>Essendo un device "visto" come un file, ogni device driver deve implementare tutte le system-call previste per l'interfacciamento con un file. La corrispondenza tra la system-call e la funzione fornita dal driver viene stabilita attraverso la struttura</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>file_operations <a class="code" href="group___kernel-_module.html#ga9f31111fdb3b4a5944e18d45045e0f01">myGPIO_fops</a> = {</div>
<div class="line">    .owner      = THIS_MODULE,</div>
<div class="line">    .llseek     = driver_seek,</div>
<div class="line">    .read       = driver_read,</div>
<div class="line">    .write      = driver_write,</div>
<div class="line">    .poll       = driver_poll,</div>
<div class="line">    .open       = driver_open,</div>
<div class="line">    .release    = driver_release</div>
<div class="line">};</div>
</div><!-- fragment --><p>Ogni campo della struttura deve puntare ad una funzione del driver che implementa uno specifico "operatore" su file, oppure impostata a NULL se l'operatore non e' supportato. L'esatto comportamento del kernel, quando uno dei puntatori e' NULL, varia da funzione a funzione. La lista seguente introduce tutti gli operatori che un'applicazione puo' invocare su un device. La lista e' stata mantenuta snella, includendo solo i campi strettamente necessari.</p>
<ul>
<li><em>struct module *owner</em> :<br />
 il primo campo della struttura non e' un operatore, ma un puntatore al modulo che "possiede" la struttura. Il campo ha lo scopo di evitare che il modulo venga rimosso dal kernel quando uno degli operatori e' in uso. Viene inizializzato usando la macro THIS_MODULE, definita in &lt;linux/module.h&gt;.</li>
<li><em>loff_t (*llseek) (struct file *, loff_t, int)</em> : il campo llseek e' usato per cambiare la posizione della "testina" di lettura/ scrittura in un file. La funzione restituisce la nuova posizione della testina. loff_t e' un intero a 64 bit (anche su architetture a 32 bit). Eventuali errori vengono segnalati con un valore di ritorno negativo. Se questo campo e' posto a NULL, eventuali chiamate a seek modifigheranno la posizione della testina in un modo impredicibile.</li>
<li><em>ssize_t (*read) (struct file *, char _ _user *, size_t, loff_t *)</em> :<br />
 usata per leggere dati dal device. Se lasciato a NULL, ogni chiamata a read fallira' e non sara' possibile leggere dal device. La funzione restituisce il numero di byte letti con successo ma, nel caso si verifichi un errore, restituisce un numero intero negativo.</li>
<li><em>ssize_t (*write) (struct file *, const char _ _user *, size_t, loff_t *)</em> :<br />
 invia dati al device. Se NULL ogni chiamata alla system-call write causera' un errore. Il valore di ritorno, se non negativo, rappresenta il numero di byte correttamente scritti.</li>
<li><em>unsigned int (*poll) (struct file *, struct poll_table_struct *)</em> :<br />
 questo metodo e' il back-end di tre diverse system-calls: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno. La funzione dovrebbe restituire una maschera che indichi se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili. Se viene lasciata NULL si intende che le operazioni di lettura/scrittura sul device siano sempre non-bloccanti.</li>
<li><em>int (*open) (struct inode *, struct file *)</em> :<br />
 Anche se, di solito, e' la prima operazione che si effettua su un file, non e' strettamente necessaria la sua implementazione. Se lasciata NULL, l'apertura del device andra' comunque a buon fine, ma al driver non verra' inviata alcuna notifica.</li>
<li><em>int (*release) (struct inode *, struct file *)</em> :<br />
 questo operatore viene invocato quando il file viene rilasciato. Come open, puo' essere lasciato NULL. </li>
</ul>
<h2 class="groupheader">Documentazione delle definizioni</h2>
<a class="anchor" id="ga25634d21648ca7fb7a2aca614bafaaeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRIVER_NAME&#160;&#160;&#160;&quot;myGPIOK&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nome identificativo del device-driver. DEVE corrispondere al valore del campo "compatible" nel device tree source. </p>

</div>
</div>
<h2 class="groupheader">Documentazione delle funzioni</h2>
<a class="anchor" id="ga4982cc224a0881ae5d106fce7526fb68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MODULE_DEVICE_TABLE </td>
          <td>(</td>
          <td class="paramtype">of&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___kernel-_module.html#ga91f28437e0a553effa546d16fa44f03a">myGPIOk_match</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>una nuova entry nella tabella delle corrispondenze device - driver. </p><dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">of</td><td>riferimento alla tabella </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myGPIOk_match</td><td>struttura of_device_id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga61e890be90fe5582db8048893ca0ebbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">module_platform_driver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___kernel-_module.html#ga8dba1541b58fa63f8208232ffce4fc47">myGPIOK_driver</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>la macro <a class="el" href="group___kernel-_module.html#ga61e890be90fe5582db8048893ca0ebbf">module_platform_driver()</a> prende in input la struttura platform_driver ed implementa le funzioni module_init() e module_close() standard, chiamate quando il modulo viene caricato o rimosso dal kernel.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">myGPIOK_driver</td><td>struttura platform_driver associata al driver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7aa7d2d19eb7034855c87a17e433918d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int myGPIOK_open </td>
          <td>(</td>
          <td class="paramtype">struct inode *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invocata all'apertura del file corrispondente al device. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td></td></tr>
    <tr><td class="paramname">file</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga27a9fd0cd8497c6fb4415ffcf0733270"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int myGPIOK_poll </td>
          <td>(</td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct poll_table_struct *&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifica che le operazioni di lettura/scrittura risultino non-bloccanti. </p>
<p>Questo metodo e' il back-end di tre diverse system-calls: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramname">wait</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>restituisce una maschera di bit che indica se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili. </dd></dl>

</div>
</div>
<a class="anchor" id="gae40973a06d72f7c41a9af07513a62307"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int myGPIOK_probe </td>
          <td>(</td>
          <td class="paramtype">struct platform_device *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Viene chiamata quando il modulo viene inserito. </p>
<p>Inizializza il driver e la periferica.</p>
<dl class="retval"><dt>Valori di ritorno</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>nel caso in cui non si sia verificato nessun errore; </td></tr>
    <tr><td class="paramname">-1</td><td>nel caso </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac03e8e943c9886549d64625253b8c4bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t myGPIOK_read </td>
          <td>(</td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loff_t *&#160;</td>
          <td class="paramname"><em>ppos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>legge dati dal device. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramname">count</td><td></td></tr>
    <tr><td class="paramname">ppos</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>La funzione restituisce il numero di byte letti con successo ma, nel caso si verifichi un errore, restituisce un numero intero negativo. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf310cbdd4b64b3e108ed0cd67374fa9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int myGPIOK_release </td>
          <td>(</td>
          <td class="paramtype">struct inode *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invocata alla chiusura del file corrispondente al device. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td></td></tr>
    <tr><td class="paramname">file</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga59fddfaa36dea357f4bbdfceb0f47f8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int myGPIOK_remove </td>
          <td>(</td>
          <td class="paramtype">struct platform_device *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Viene chiamata automaticamente alla rimozione del mosulo.</p>
<p>Dealloca tutte la memoria utilizzata dal driver. </p>

</div>
</div>
<a class="anchor" id="gaee309b7824d1efb418d9aa5e8c888c7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static loff_t myGPIOK_seek </td>
          <td>(</td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loff_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>usato per cambiare la posizione della "testina" di lettura/scrittura in un file. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramname">off</td><td></td></tr>
    <tr><td class="paramname">whence</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>La funzione restituisce la nuova posizione della testina o -1 nel caso in cui si verifichi un errore. </dd></dl>

</div>
</div>
<a class="anchor" id="ga93f7a4111f4555747323e4afcb1343fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t myGPIOK_write </td>
          <td>(</td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loff_t *&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invia dati al device. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramname">size</td><td></td></tr>
    <tr><td class="paramname">off</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>Il valore di ritorno, se non negativo, rappresenta il numero di byte correttamente scritti. </dd></dl>

</div>
</div>
<h2 class="groupheader">Documentazione delle variabili</h2>
<a class="anchor" id="ga9f31111fdb3b4a5944e18d45045e0f01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct file_operations myGPIO_fops</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Valore iniziale:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        .owner      = THIS_MODULE,</div>
<div class="line">        .llseek     = <a class="code" href="group___kernel-_module.html#gaee309b7824d1efb418d9aa5e8c888c7c">myGPIOK_seek</a>,</div>
<div class="line">        .read       = <a class="code" href="group___kernel-_module.html#gac03e8e943c9886549d64625253b8c4bf">myGPIOK_read</a>,</div>
<div class="line">        .write      = <a class="code" href="group___kernel-_module.html#ga93f7a4111f4555747323e4afcb1343fd">myGPIOK_write</a>,</div>
<div class="line">        .poll       = <a class="code" href="group___kernel-_module.html#ga27a9fd0cd8497c6fb4415ffcf0733270">myGPIOK_poll</a>,</div>
<div class="line">        .open       = <a class="code" href="group___kernel-_module.html#ga7aa7d2d19eb7034855c87a17e433918d">myGPIOK_open</a>,</div>
<div class="line">        .release    = <a class="code" href="group___kernel-_module.html#gaf310cbdd4b64b3e108ed0cd67374fa9b">myGPIOK_release</a></div>
<div class="line">}</div>
<div class="ttc" id="group___kernel-_module_html_gac03e8e943c9886549d64625253b8c4bf"><div class="ttname"><a href="group___kernel-_module.html#gac03e8e943c9886549d64625253b8c4bf">myGPIOK_read</a></div><div class="ttdeci">static ssize_t myGPIOK_read(struct file *file, char *buf, size_t count, loff_t *ppos)</div><div class="ttdoc">legge dati dal device. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:333</div></div>
<div class="ttc" id="group___kernel-_module_html_gaee309b7824d1efb418d9aa5e8c888c7c"><div class="ttname"><a href="group___kernel-_module.html#gaee309b7824d1efb418d9aa5e8c888c7c">myGPIOK_seek</a></div><div class="ttdeci">static loff_t myGPIOK_seek(struct file *file, loff_t off, int whence)</div><div class="ttdoc">usato per cambiare la posizione della "testina" di lettura/scrittura in un file. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:317</div></div>
<div class="ttc" id="group___kernel-_module_html_gaf310cbdd4b64b3e108ed0cd67374fa9b"><div class="ttname"><a href="group___kernel-_module.html#gaf310cbdd4b64b3e108ed0cd67374fa9b">myGPIOK_release</a></div><div class="ttdeci">static int myGPIOK_release(struct inode *inode, struct file *file)</div><div class="ttdoc">Invocata alla chiusura del file corrispondente al device. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:394</div></div>
<div class="ttc" id="group___kernel-_module_html_ga7aa7d2d19eb7034855c87a17e433918d"><div class="ttname"><a href="group___kernel-_module.html#ga7aa7d2d19eb7034855c87a17e433918d">myGPIOK_open</a></div><div class="ttdeci">static int myGPIOK_open(struct inode *inode, struct file *file)</div><div class="ttdoc">Invocata all&#39;apertura del file corrispondente al device. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:381</div></div>
<div class="ttc" id="group___kernel-_module_html_ga27a9fd0cd8497c6fb4415ffcf0733270"><div class="ttname"><a href="group___kernel-_module.html#ga27a9fd0cd8497c6fb4415ffcf0733270">myGPIOK_poll</a></div><div class="ttdeci">static unsigned int myGPIOK_poll(struct file *file, struct poll_table_struct *wait)</div><div class="ttdoc">Verifica che le operazioni di lettura/scrittura risultino non-bloccanti. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:368</div></div>
<div class="ttc" id="group___kernel-_module_html_ga93f7a4111f4555747323e4afcb1343fd"><div class="ttname"><a href="group___kernel-_module.html#ga93f7a4111f4555747323e4afcb1343fd">myGPIOK_write</a></div><div class="ttdeci">static ssize_t myGPIOK_write(struct file *file, const char *buf, size_t size, loff_t *off)</div><div class="ttdoc">Invia dati al device. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:349</div></div>
</div><!-- fragment -->
<p>definisce la corrispondenza tra funzioni kernel e funzioni driver. </p>
<p>Essendo un device "visto" come un file, ogni device driver deve implementare tutte le system-call previste per l'interfacciamento con un file. La corrispondenza tra la system-call e la funzione fornita dal driver viene stabilita attraverso tale struttura. </p>

</div>
</div>
<a class="anchor" id="ga8dba1541b58fa63f8208232ffce4fc47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct platform_driver myGPIOK_driver</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Valore iniziale:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        .probe = <a class="code" href="group___kernel-_module.html#gae40973a06d72f7c41a9af07513a62307">myGPIOK_probe</a>,</div>
<div class="line">        .remove = <a class="code" href="group___kernel-_module.html#ga59fddfaa36dea357f4bbdfceb0f47f8c">myGPIOK_remove</a>,</div>
<div class="line">        .driver = {</div>
<div class="line">                .name = <a class="code" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>,</div>
<div class="line">                .owner = THIS_MODULE,</div>
<div class="line">                .of_match_table = <a class="code" href="group___kernel-_module.html#ga91f28437e0a553effa546d16fa44f03a">myGPIOk_match</a>,</div>
<div class="line">        },</div>
<div class="line">}</div>
<div class="ttc" id="group___kernel-_module_html_ga91f28437e0a553effa546d16fa44f03a"><div class="ttname"><a href="group___kernel-_module.html#ga91f28437e0a553effa546d16fa44f03a">myGPIOk_match</a></div><div class="ttdeci">static struct of_device_id myGPIOk_match[]</div><div class="ttdoc">Identifica il device all&#39;interno del device tree. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:253</div></div>
<div class="ttc" id="group___kernel-_module_html_ga59fddfaa36dea357f4bbdfceb0f47f8c"><div class="ttname"><a href="group___kernel-_module.html#ga59fddfaa36dea357f4bbdfceb0f47f8c">myGPIOK_remove</a></div><div class="ttdeci">static int myGPIOK_remove(struct platform_device *op)</div><div class="ttdef"><b>Definition:</b> myGPIOK.c:234</div></div>
<div class="ttc" id="group___kernel-_module_html_gae40973a06d72f7c41a9af07513a62307"><div class="ttname"><a href="group___kernel-_module.html#gae40973a06d72f7c41a9af07513a62307">myGPIOK_probe</a></div><div class="ttdeci">static int myGPIOK_probe(struct platform_device *op)</div><div class="ttdoc">Viene chiamata quando il modulo viene inserito. </div><div class="ttdef"><b>Definition:</b> myGPIOK.c:221</div></div>
<div class="ttc" id="group___kernel-_module_html_ga25634d21648ca7fb7a2aca614bafaaeb"><div class="ttname"><a href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a></div><div class="ttdeci">#define DRIVER_NAME</div><div class="ttdoc">Nome identificativo del device-driver. DEVE corrispondere al valore del campo "compatible" nel device...</div><div class="ttdef"><b>Definition:</b> myGPIOK.c:243</div></div>
</div><!-- fragment -->
<p>Definisce quali funzioni probe() e remove() chiamare quando viene caricato un driver. </p>

</div>
</div>
<a class="anchor" id="ga91f28437e0a553effa546d16fa44f03a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct of_device_id myGPIOk_match[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Valore iniziale:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        {.compatible = <a class="code" href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a>},</div>
<div class="line">        {},</div>
<div class="line">}</div>
<div class="ttc" id="group___kernel-_module_html_ga25634d21648ca7fb7a2aca614bafaaeb"><div class="ttname"><a href="group___kernel-_module.html#ga25634d21648ca7fb7a2aca614bafaaeb">DRIVER_NAME</a></div><div class="ttdeci">#define DRIVER_NAME</div><div class="ttdoc">Nome identificativo del device-driver. DEVE corrispondere al valore del campo "compatible" nel device...</div><div class="ttdef"><b>Definition:</b> myGPIOK.c:243</div></div>
</div><!-- fragment -->
<p>Identifica il device all'interno del device tree. </p>
<p>Tutti i device-driver devono esporre un ID. A tempo di compilazione, il processo di build estrae queste informazioni dai driver per la preparazione di una tabella. Quando si "inserisce" il device, la tabella viene riferita dal kernel e, se viene trovata una entry corrispondente al driver per quel device, il driver viene caricato ed inizializzato. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generato Sab 17 Giu 2017 12:35:53 per Zynq-7000 Driver Pack da
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
