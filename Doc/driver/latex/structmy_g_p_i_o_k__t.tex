\hypertarget{structmy_g_p_i_o_k__t}{\section{Riferimenti per la struct my\+G\+P\+I\+O\+K\+\_\+t}
\label{structmy_g_p_i_o_k__t}\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
}


Stuttura per l'astrazione di un device.  


\subsection*{Campi}
\begin{DoxyCompactItemize}
\item 
struct cdev \hyperlink{structmy_g_p_i_o_k__t_acba682fe45d5a1501790dbdb1d99bd6a}{cdev}
\item 
uint32\+\_\+t \hyperlink{structmy_g_p_i_o_k__t_a42a1593ebe61611c4e29413903a373a5}{irq\+Number}
\item 
struct resource \hyperlink{structmy_g_p_i_o_k__t_a565a1848c3ae8026257a74cf169c6941}{rsrc}
\item 
struct resource $\ast$ \hyperlink{structmy_g_p_i_o_k__t_a18c4eb95350c67ccb239a8a39c43c09a}{mreg}
\item 
uint32\+\_\+t \hyperlink{structmy_g_p_i_o_k__t_a0f87b53dc5049a349ef01aa586c0b5dc}{rsrc\+\_\+size}
\item 
void $\ast$ \hyperlink{structmy_g_p_i_o_k__t_af5aef493b3c2bc9d1f036ce0acea9bba}{vrtl\+\_\+addr}
\item 
wait\+\_\+queue\+\_\+head\+\_\+t \hyperlink{structmy_g_p_i_o_k__t_a251570f8e6976ad87411093e330e7b4f}{read\+\_\+queue}
\item 
wait\+\_\+queue\+\_\+head\+\_\+t \hyperlink{structmy_g_p_i_o_k__t_a2080617f88cafd765430573afe7701d1}{poll\+\_\+queue}
\item 
uint32\+\_\+t \hyperlink{structmy_g_p_i_o_k__t_a6fd94ecf2bef1aa7bd105577b660a112}{int\+\_\+occurred}
\item 
spinlock\+\_\+t \hyperlink{structmy_g_p_i_o_k__t_a1e1ddf972b4dc84dd331a0c72e5d9895}{slock\+\_\+int}
\item 
uint32\+\_\+t \hyperlink{structmy_g_p_i_o_k__t_a2da711ac290a9613b8d8af97f122b997}{total\+\_\+irq}
\item 
spinlock\+\_\+t \hyperlink{structmy_g_p_i_o_k__t_ac41bbc7fe03ef25b7f468275fb565d78}{sl\+\_\+total\+\_\+irq}
\end{DoxyCompactItemize}


\subsection{Descrizione dettagliata}
Stuttura per l'astrazione di un device. 

E' buona abitudine, se non quasi indispensabile, definire una struttura dati nella quale contenere tutto cio' che e' legato al device o al driver. In questo modulo viene usata la struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} per contenere tutto cio' che e' necessario al funzionamento del driver. 

\subsection{Documentazione dei campi}
\hypertarget{structmy_g_p_i_o_k__t_acba682fe45d5a1501790dbdb1d99bd6a}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!cdev@{cdev}}
\index{cdev@{cdev}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{cdev}]{\setlength{\rightskip}{0pt plus 5cm}struct cdev cdev}}\label{structmy_g_p_i_o_k__t_acba682fe45d5a1501790dbdb1d99bd6a}
Stuttura per l'astrazione di un device a caratteri, Il kernel usa, internamente, una struttura cdev per rappresentare i device a caratteri. Prima che il kernel invochi le funzioni definite dal driver per il device, bisogna allocare e registrare uno, o piu', oggetti cdev. In questo caso e' sufficiente allocare uno solo di questi oggetti. \hypertarget{structmy_g_p_i_o_k__t_a6fd94ecf2bef1aa7bd105577b660a112}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!int\+\_\+occurred@{int\+\_\+occurred}}
\index{int\+\_\+occurred@{int\+\_\+occurred}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{int\+\_\+occurred}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t int\+\_\+occurred}}\label{structmy_g_p_i_o_k__t_a6fd94ecf2bef1aa7bd105577b660a112}
Flag \char`\"{}interrupt occurred\char`\"{} Il valore viene settato dalla funzione \hyperlink{group___kernel-_module_ga2fc230a12a97aa63e43b2dc4aec73511}{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler()} al manifestarsi di un interrupt, prima di risvegliare i processi in attesa che tale variabile assuma uno specifico valore. I valori con cui questo flag puo' essere settato sono due\+:
\begin{DoxyItemize}
\item M\+Y\+G\+P\+I\+O\+K\+\_\+\+S\+R\+E\+A\+D \+: per la read bloccante.
\item M\+Y\+G\+P\+I\+O\+K\+\_\+\+A\+R\+E\+A\+D \+: pre la read non bloccante.
\end{DoxyItemize}

I processi che effettuano read() bloccante restano bloccati finoche' int\+\_\+occurred \& M\+Y\+G\+P\+I\+O\+\_\+\+S\+R\+E\+A\+D != 0 \hypertarget{structmy_g_p_i_o_k__t_a42a1593ebe61611c4e29413903a373a5}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!irq\+Number@{irq\+Number}}
\index{irq\+Number@{irq\+Number}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{irq\+Number}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t irq\+Number}}\label{structmy_g_p_i_o_k__t_a42a1593ebe61611c4e29413903a373a5}
interrupt-\/number a cui il device e' connesso. Restituito dalla chiamata alla funzione irq\+\_\+of\+\_\+parse\+\_\+and\+\_\+map() \hypertarget{structmy_g_p_i_o_k__t_a18c4eb95350c67ccb239a8a39c43c09a}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!mreg@{mreg}}
\index{mreg@{mreg}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{mreg}]{\setlength{\rightskip}{0pt plus 5cm}struct resource$\ast$ mreg}}\label{structmy_g_p_i_o_k__t_a18c4eb95350c67ccb239a8a39c43c09a}
puntatre alla regione di memoria cui il device e' mapapto \hypertarget{structmy_g_p_i_o_k__t_a2080617f88cafd765430573afe7701d1}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!poll\+\_\+queue@{poll\+\_\+queue}}
\index{poll\+\_\+queue@{poll\+\_\+queue}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{poll\+\_\+queue}]{\setlength{\rightskip}{0pt plus 5cm}wait\+\_\+queue\+\_\+head\+\_\+t poll\+\_\+queue}}\label{structmy_g_p_i_o_k__t_a2080617f88cafd765430573afe7701d1}
wait queue per la system-\/call poll() \hypertarget{structmy_g_p_i_o_k__t_a251570f8e6976ad87411093e330e7b4f}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!read\+\_\+queue@{read\+\_\+queue}}
\index{read\+\_\+queue@{read\+\_\+queue}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{read\+\_\+queue}]{\setlength{\rightskip}{0pt plus 5cm}wait\+\_\+queue\+\_\+head\+\_\+t read\+\_\+queue}}\label{structmy_g_p_i_o_k__t_a251570f8e6976ad87411093e330e7b4f}
wait queue per la system-\/call read() Una chiamata a read() potrebbe arrivare quando i dati non sono disponibili, ma potrebbero esserlo in futuro, oppure, una chiamata a write() potrebbe avvenire quando il device non e' in grado di accettare altri dati (perche' il suo buffer di ingresso potrebbe essere pieno). Il processo chiamante non ha la minima conoscenza delle dinamiche interne del device, per cui, nell'impossibilita' di servire la richiesta, il driver deve bloccare il processo e metterlo tra i processi \char`\"{}sleeping\char`\"{}, fin quando la richiesta non puo' essere servita. Tutti i processi in attesa di un particolare evento vengono posti all'interno della stessa wait queue. In linux una wait queue viene implementata da una struttura dati wait\+\_\+queue\+\_\+head\+\_\+t, definita in $<$linux/wait.\+h$>$. \hypertarget{structmy_g_p_i_o_k__t_a565a1848c3ae8026257a74cf169c6941}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!rsrc@{rsrc}}
\index{rsrc@{rsrc}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{rsrc}]{\setlength{\rightskip}{0pt plus 5cm}struct resource rsrc}}\label{structmy_g_p_i_o_k__t_a565a1848c3ae8026257a74cf169c6941}
Struttura che astrae una risorsa device, dal punto di vista della memoria alla quale la risorsa e' mappata. In particolare i campi \char`\"{}start\char`\"{} ed \char`\"{}end\char`\"{} contengono, rispettivamente, il primo e l'ultimo indirizzo fisico a cui il device e' mappato. \hypertarget{structmy_g_p_i_o_k__t_a0f87b53dc5049a349ef01aa586c0b5dc}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!rsrc\+\_\+size@{rsrc\+\_\+size}}
\index{rsrc\+\_\+size@{rsrc\+\_\+size}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{rsrc\+\_\+size}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t rsrc\+\_\+size}}\label{structmy_g_p_i_o_k__t_a0f87b53dc5049a349ef01aa586c0b5dc}
rsrc.\+end -\/ rsrc.\+start numero di indirizzi associati alla periferica. occorre per effettuare il mapping indirizzo fisico -\/ indirizzo virtuale \hypertarget{structmy_g_p_i_o_k__t_ac41bbc7fe03ef25b7f468275fb565d78}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!sl\+\_\+total\+\_\+irq@{sl\+\_\+total\+\_\+irq}}
\index{sl\+\_\+total\+\_\+irq@{sl\+\_\+total\+\_\+irq}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{sl\+\_\+total\+\_\+irq}]{\setlength{\rightskip}{0pt plus 5cm}spinlock\+\_\+t sl\+\_\+total\+\_\+irq}}\label{structmy_g_p_i_o_k__t_ac41bbc7fe03ef25b7f468275fb565d78}
Spinlock usato per garantire l'accesso in mutua esclusione alla variabile total\+\_\+irq da parte delle funzioni del modulo \hypertarget{structmy_g_p_i_o_k__t_a1e1ddf972b4dc84dd331a0c72e5d9895}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!slock\+\_\+int@{slock\+\_\+int}}
\index{slock\+\_\+int@{slock\+\_\+int}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{slock\+\_\+int}]{\setlength{\rightskip}{0pt plus 5cm}spinlock\+\_\+t slock\+\_\+int}}\label{structmy_g_p_i_o_k__t_a1e1ddf972b4dc84dd331a0c72e5d9895}
Spinlock usato per garantire l'accesso in mutua esclusione alla variabile int\+\_\+occurred da parte delle funzioni del modulo. I semafori sono uno strumento potentissimo per per l'implementazione di sezioni critiche, ma non possono essere usati in codice non interrompibile. Gli spilock sono come i semafori, ma possono essere usati anche in codice non interrompibile, come puo' esserlo un modulo kernel. Sostanzialmente se uno spinlock e' gia' stato acquisito da qualcun altro, si entra in un hot-\/loop dal quale si esce solo quando chi possiede lo spinlock lo rilascia. Trattandosi di moduli kernel, e' di vitale importanza che la sezione critica sia quanto piu' piccola possibile. Ovviamente l'implementazione e' \char`\"{}un
po'\char`\"{} piu' complessa di come e' stata descritta, ma il concetto e' questo. Gli spinlock sono definiti in $<$linux/spinlock.\+h$>$. \hypertarget{structmy_g_p_i_o_k__t_a2da711ac290a9613b8d8af97f122b997}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!total\+\_\+irq@{total\+\_\+irq}}
\index{total\+\_\+irq@{total\+\_\+irq}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{total\+\_\+irq}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t total\+\_\+irq}}\label{structmy_g_p_i_o_k__t_a2da711ac290a9613b8d8af97f122b997}
numero totale di interrupt manifestatesi \hypertarget{structmy_g_p_i_o_k__t_af5aef493b3c2bc9d1f036ce0acea9bba}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!vrtl\+\_\+addr@{vrtl\+\_\+addr}}
\index{vrtl\+\_\+addr@{vrtl\+\_\+addr}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{vrtl\+\_\+addr}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ vrtl\+\_\+addr}}\label{structmy_g_p_i_o_k__t_af5aef493b3c2bc9d1f036ce0acea9bba}
indirizzo virtuale della periferica 

La documentazione per questa struct Ã¨ stata generata a partire dal seguente file\+:\begin{DoxyCompactItemize}
\item 
my\+G\+P\+I\+O/linux-\/driver/kernel\+\_\+module/kernel\+\_\+module/\hyperlink{my_g_p_i_o_k_8c}{my\+G\+P\+I\+O\+K.\+c}\end{DoxyCompactItemize}
