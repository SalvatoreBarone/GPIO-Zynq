\hypertarget{structmy_g_p_i_o_k__t}{\section{Riferimenti per la struct my\+G\+P\+I\+O\+K\+\_\+t}
\label{structmy_g_p_i_o_k__t}\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
}


Stuttura per l'astrazione di un device.  


\subsection*{Campi}
\begin{DoxyCompactItemize}
\item 
struct cdev \hyperlink{structmy_g_p_i_o_k__t_acba682fe45d5a1501790dbdb1d99bd6a}{cdev}
\item 
uint32\+\_\+t \hyperlink{structmy_g_p_i_o_k__t_a42a1593ebe61611c4e29413903a373a5}{irq\+Number}
\item 
struct resource \hyperlink{structmy_g_p_i_o_k__t_a565a1848c3ae8026257a74cf169c6941}{rsrc}
\item 
struct resource $\ast$ \hyperlink{structmy_g_p_i_o_k__t_a18c4eb95350c67ccb239a8a39c43c09a}{mreg}
\item 
uint32\+\_\+t \hyperlink{structmy_g_p_i_o_k__t_a0f87b53dc5049a349ef01aa586c0b5dc}{rsrc\+\_\+size}
\item 
uint32\+\_\+t $\ast$ \hyperlink{structmy_g_p_i_o_k__t_a7fb037ce37d63eb2c327ec952c74d2e9}{vrtl\+\_\+addr}
\end{DoxyCompactItemize}


\subsection{Descrizione dettagliata}
Stuttura per l'astrazione di un device. 

E' buona abitudine, se non quasi indispensabile, definire una struttura dati nella quale contenere tutto cio' che e' legato al device o al driver. In questo modulo viene usata la struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} per contenere tutto cio' che e' necessario al funzionamento del driver. 

\subsection{Documentazione dei campi}
\hypertarget{structmy_g_p_i_o_k__t_acba682fe45d5a1501790dbdb1d99bd6a}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!cdev@{cdev}}
\index{cdev@{cdev}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{cdev}]{\setlength{\rightskip}{0pt plus 5cm}struct cdev cdev}}\label{structmy_g_p_i_o_k__t_acba682fe45d5a1501790dbdb1d99bd6a}
Stuttura per l'astrazione di un device a caratteri, Il kernel usa, internamente, una struttura cdev per rappresentare i device a caratteri. Prima che il kernel invochi le funzioni definite dal driver per il device, bisogna allocare e registrare uno, o piu', oggetti cdev. In questo caso e' sufficiente allocare uno solo di questi oggetti. \hypertarget{structmy_g_p_i_o_k__t_a42a1593ebe61611c4e29413903a373a5}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!irq\+Number@{irq\+Number}}
\index{irq\+Number@{irq\+Number}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{irq\+Number}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t irq\+Number}}\label{structmy_g_p_i_o_k__t_a42a1593ebe61611c4e29413903a373a5}
interrupt-\/number a cui il device e' connesso. Restituito salla chiamata alla funzione irq\+\_\+of\+\_\+parse\+\_\+and\+\_\+map() \hypertarget{structmy_g_p_i_o_k__t_a18c4eb95350c67ccb239a8a39c43c09a}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!mreg@{mreg}}
\index{mreg@{mreg}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{mreg}]{\setlength{\rightskip}{0pt plus 5cm}struct resource$\ast$ mreg}}\label{structmy_g_p_i_o_k__t_a18c4eb95350c67ccb239a8a39c43c09a}
puntatre alla regione di memoria cui il device e' mapapto \hypertarget{structmy_g_p_i_o_k__t_a565a1848c3ae8026257a74cf169c6941}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!rsrc@{rsrc}}
\index{rsrc@{rsrc}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{rsrc}]{\setlength{\rightskip}{0pt plus 5cm}struct resource rsrc}}\label{structmy_g_p_i_o_k__t_a565a1848c3ae8026257a74cf169c6941}
Struttura che astrae una risorsa device, dal punto di vista della memoria alla quale la risorsa e' mappata. In particolare i campi \char`\"{}start\char`\"{} ed \char`\"{}end\char`\"{} contendono, rispettivamente, il primo e l'ultimo indirizzo fisico a cui il device e' mappato. \hypertarget{structmy_g_p_i_o_k__t_a0f87b53dc5049a349ef01aa586c0b5dc}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!rsrc\+\_\+size@{rsrc\+\_\+size}}
\index{rsrc\+\_\+size@{rsrc\+\_\+size}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{rsrc\+\_\+size}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t rsrc\+\_\+size}}\label{structmy_g_p_i_o_k__t_a0f87b53dc5049a349ef01aa586c0b5dc}
rsrc.\+end -\/ rsrc.\+start numero di indirizzi associati alla periferica. occorre per effettuare il mapping indirizzo fisico -\/ indirizzo virtuale \hypertarget{structmy_g_p_i_o_k__t_a7fb037ce37d63eb2c327ec952c74d2e9}{\index{my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}!vrtl\+\_\+addr@{vrtl\+\_\+addr}}
\index{vrtl\+\_\+addr@{vrtl\+\_\+addr}!my\+G\+P\+I\+O\+K\+\_\+t@{my\+G\+P\+I\+O\+K\+\_\+t}}
\subsubsection[{vrtl\+\_\+addr}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t$\ast$ vrtl\+\_\+addr}}\label{structmy_g_p_i_o_k__t_a7fb037ce37d63eb2c327ec952c74d2e9}
indirizzo virtuale della periferica 

La documentazione per questa struct Ã¨ stata generata a partire dal seguente file\+:\begin{DoxyCompactItemize}
\item 
my\+G\+P\+I\+O/linux-\/driver/kernel\+\_\+module/kernel\+\_\+module/\hyperlink{my_g_p_i_o_k_8c}{my\+G\+P\+I\+O\+K.\+c}\end{DoxyCompactItemize}
