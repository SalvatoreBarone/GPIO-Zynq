\hypertarget{group___no_driver}{\section{No\+Driver}
\label{group___no_driver}\index{No\+Driver@{No\+Driver}}
}


Questo e' un programma di esempio per l'interfacciamento con una periferica my\+G\+P\+I\+O.  


Diagramma di collaborazione per No\+Driver\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=241pt]{group___no_driver}
\end{center}
\end{figure}
\subsection*{Funzioni}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group___no_driver_ga05909651fa170a63e98e3f8e13451b7b}{howto} (void)
\begin{DoxyCompactList}\small\item\em Stampa un messaggio che fornisce indicazioni sull'utilizzo del programma. \end{DoxyCompactList}\item 
int \hyperlink{group___no_driver_ga218f8a9dfc36572bfe2230c5e2d2c776}{parse\+\_\+args} (int argc, char $\ast$$\ast$argv, uint32\+\_\+t $\ast$gpio\+\_\+address, uint8\+\_\+t $\ast$op\+\_\+mode, uint32\+\_\+t $\ast$mode\+\_\+value, uint8\+\_\+t $\ast$op\+\_\+write, uint32\+\_\+t $\ast$write\+\_\+value, uint8\+\_\+t $\ast$op\+\_\+read)
\begin{DoxyCompactList}\small\item\em Effettua il parsing dei parametri passati al programma. \end{DoxyCompactList}\item 
void \hyperlink{group___no_driver_ga879d8b839631449ecb5bc4d0721432b6}{gpio\+\_\+op} (void $\ast$vrt\+\_\+gpio\+\_\+addr, uint8\+\_\+t op\+\_\+mode, uint32\+\_\+t mode\+\_\+value, uint8\+\_\+t op\+\_\+write, uint32\+\_\+t write\+\_\+value, uint8\+\_\+t op\+\_\+read)
\begin{DoxyCompactList}\small\item\em Effettua operazioni su un device. \end{DoxyCompactList}\item 
int \hyperlink{group___no_driver_ga3c04138a5bfe5d72780bb7e82a18e627}{main} (int argc, char $\ast$$\ast$argv)
\begin{DoxyCompactList}\small\item\em funzione \hyperlink{group___no_driver_ga3c04138a5bfe5d72780bb7e82a18e627}{main()}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Descrizione dettagliata}
Questo e' un programma di esempio per l'interfacciamento con una periferica my\+G\+P\+I\+O. 

In questo specifico esempio l'interfacciamento avviene da user-\/space, agendo direttamente sui registri di memoria, senza mediazione di altri driver, usando il device /dev/mem. 

\subsection{Documentazione delle funzioni}
\hypertarget{group___no_driver_ga879d8b839631449ecb5bc4d0721432b6}{\index{No\+Driver@{No\+Driver}!gpio\+\_\+op@{gpio\+\_\+op}}
\index{gpio\+\_\+op@{gpio\+\_\+op}!No\+Driver@{No\+Driver}}
\subsubsection[{gpio\+\_\+op}]{\setlength{\rightskip}{0pt plus 5cm}void gpio\+\_\+op (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{vrt\+\_\+gpio\+\_\+addr, }
\item[{uint8\+\_\+t}]{op\+\_\+mode, }
\item[{uint32\+\_\+t}]{mode\+\_\+value, }
\item[{uint8\+\_\+t}]{op\+\_\+write, }
\item[{uint32\+\_\+t}]{write\+\_\+value, }
\item[{uint8\+\_\+t}]{op\+\_\+read}
\end{DoxyParamCaption}
)}}\label{group___no_driver_ga879d8b839631449ecb5bc4d0721432b6}


Effettua operazioni su un device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em vrt\+\_\+gpio\+\_\+addr} & indirizzo di memoria del device gpio \\
\hline
\mbox{\tt in}  & {\em op\+\_\+mode} & sara' impostato ad 1 se l'utente intende effettuare scrittuara su mode \\
\hline
\mbox{\tt in}  & {\em mode\+\_\+value} & conterra' il valore che l'utente intende scrivere nel registro mode \\
\hline
\mbox{\tt in}  & {\em op\+\_\+write} & sara' impostato ad 1 se l'utente intende effettuare scrittuara su write \\
\hline
\mbox{\tt in}  & {\em write\+\_\+value} & conterra' il valore che l'utente intende scrivere nel registro write \\
\hline
\mbox{\tt in}  & {\em op\+\_\+read} & sara' impostato ad 1 se l'utente intende effettuare lettura da read\\
\hline
\end{DoxyParams}
La funzione viene invocata dopo che sia stato eseguito il parsing dei parametri passati al programma quando esso viene invocato. E' stata scritta per funzionare sia con il G\+P\+I\+O Xilinx che con il G\+P\+I\+O custom my\+G\+P\+I\+O. E' possibile utilizzare il primo definendo la macro {\bfseries X\+I\+L\+\_\+\+G\+P\+I\+O}. Effettua, sul device, le operazioni impostate, in accordo con i parametri passati al programma alla sua invocazione. \subparagraph*{Impostazione della modalita' di funzionamento}

Nel caso in cui si stia operando su un device G\+P\+I\+O Xilinx, le operazioni di impostazione della modalita' di funzionamento del G\+P\+I\+O vengono effettuate scrivendo direttamente sul registro M\+O\+D\+E del device. In caso contrario si e' preferito utilizzare la funzioni \hyperlink{group__my_g_p_i_o_ga38a2ea04d07af50f7f570f0367594c8b}{my\+G\+P\+I\+O\+\_\+set\+Mode()} (Si veda il modulo my\+G\+P\+I\+O). Funzionalmente non c'e' differenza.

\subparagraph*{Operazione di scrittura}

Nel caso in cui si stia operando su un device G\+P\+I\+O Xilinx, le operazioni di scrittura del valore dei pin del device G\+P\+I\+O vengono effettuate scrivendo direttamente sul registro W\+R\+I\+T\+E del device. In caso contrario si e' preferito utilizzare la funzioni \hyperlink{group__my_g_p_i_o_gab742e68093ad4c90fe299b64fd6736ca}{my\+G\+P\+I\+O\+\_\+set\+Value()} (Si veda il modulo my\+G\+P\+I\+O). Funzionalmente non c'e' differenza.

\subparagraph*{Operazione di lettura}

Nel caso in cui si stia operando su un device G\+P\+I\+O Xilinx, le operazioni di lettura del valore dei pin del device G\+P\+I\+O vengono effettuate leggendo direttamente dal registro R\+E\+A\+D del device. In caso contrario si e' preferito utilizzare la funzioni \hyperlink{group__my_g_p_i_o_gadb3ecd03ea82420488977134c9313e18}{my\+G\+P\+I\+O\+\_\+get\+Read()} (Si veda il modulo my\+G\+P\+I\+O). Funzionalmente non c'e' differenza. La lettura e' non bloccante\+: viene semplicemente letto il valore contenuto nel registro perche' tale modalita' di interazione non permette l'implementazione di un meccanismo di lettura basato su interruzioni.\hypertarget{group___no_driver_ga05909651fa170a63e98e3f8e13451b7b}{\index{No\+Driver@{No\+Driver}!howto@{howto}}
\index{howto@{howto}!No\+Driver@{No\+Driver}}
\subsubsection[{howto}]{\setlength{\rightskip}{0pt plus 5cm}void howto (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{group___no_driver_ga05909651fa170a63e98e3f8e13451b7b}


Stampa un messaggio che fornisce indicazioni sull'utilizzo del programma. 

\hypertarget{group___no_driver_ga3c04138a5bfe5d72780bb7e82a18e627}{\index{No\+Driver@{No\+Driver}!main@{main}}
\index{main@{main}!No\+Driver@{No\+Driver}}
\subsubsection[{main}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$$\ast$}]{argv}
\end{DoxyParamCaption}
)}}\label{group___no_driver_ga3c04138a5bfe5d72780bb7e82a18e627}


funzione \hyperlink{group___no_driver_ga3c04138a5bfe5d72780bb7e82a18e627}{main()}. 

\subparagraph*{Parsing dei parametri di invocazione}

Il parsing dei parametri passati al programma all'atto della sua invocazione viene effettuato dalla funzione \hyperlink{group___no_driver_ga218f8a9dfc36572bfe2230c5e2d2c776}{parse\+\_\+args()}. Si rimanda alla sua documentazione per i dettagli sui parametri riconosciuti.

Se non viene specificato l'indirizzo fisico del device al quale accedere e' impossibile continuare. Per questo motivo, in questo caso, il programma viene terminato.

\subparagraph*{Apertura di /dev/mem}

In questo specifico esempio l'interfacciamento avviene da user-\/space, agendo direttamente sui registri di memoria, senza mediazione di altri driver, usando il device /dev/mem. Questo presuppone che si sia nelle condizioni di poter calcolare dell'indirizzo di memoria virtuale del device. ~\newline
 L'accesso al device /dev/mem viene ottenuto mediante la system-\/call open()\+: 
\begin{DoxyCode}
1 #include <sys/stat.h>
2 #include <fcntl.h>
3 int open(const char *path, int oflag, ...  );
\end{DoxyCode}
 la quale restituisce il descrittore del file /dev/mem, usato nel seguito per effettuare le operazioni di I/\+O. I valori del parametro oflag specificano il modo in cui il file /dev/mem viene aperto. In questo caso viene usato O\+\_\+\+R\+D\+W\+R, il quale garantisce accesso in lettura ed in scrittura. Altri valori sono O\+\_\+\+R\+D\+O\+N\+L\+Y, il quale garantisce accesso in sola lettura, ed O\+\_\+\+W\+R\+O\+N\+L\+Y, che, invece, garantisce accesso in sola scrittura.

\subparagraph*{Calcolo dell'indirizzo virtuale del device.}

Linux implementa la segregazione della memoria. Vale a dire che un processo puo' accedere solo agli indirizzo di memoria (virtuali) appartenenti al suo address-\/space. Se e' necessario effettuare un accesso ad un indirizzo specifico, bisogna effettuare il mapping di quell'indirizzo nell'address space del processo. Linux implementa la paginazione della memoria, quindi l'indirizzo del quale si desidera effettuare il mapping, apparterra' ad una specifica pagina di memoria. Per sapere a quale pagina appartenga l'idirizzo, e' necessario conoscere quale sia la dimensione delle pagine di memoria. Tipicamente la dimensione delle pagine e' una potenza del due. Si supponga che l'indirizzo di cui si vuole fare il mapping e' {\bfseries 0x43\+C002\+F0} e che la dimensione delle pagine sia 16\+K\+B. Scrivendo la dimensione delle pagine in esadecimale ~\newline
 \begin{center}{\bfseries 0x00002000}\end{center} ~\newline
 sottraendo 1 ~\newline
 \begin{center}{\bfseries 0x00001\+F\+F\+F}\end{center} ~\newline
 negando ~\newline
 \begin{center}{\bfseries 0x\+F\+F\+F\+F\+E000}\end{center} ~\newline
 si ottiene una maschera che, posta in and con un indirizzo, restituisce l'indirizzo della pagina di memoria a cui l'indirizzo appartiene. In questo caso ~\newline
 \begin{center}{\bfseries 0x43\+C002\+F0 \& 0x\+F\+F\+F\+F\+E000 = 0x43\+C00000}\end{center} ~\newline
 L'indirizzo della pagina potra' essere usato per il mapping, ma per accedere allo specifico indirizzo e' necessario calcolarne l'offset, sottraengogli l'indirizzo della pagina. In questo modo, dopo aver effettuato il mapping, si potra' accedere allo stesso a partire dall'indirizzo virtuale della pagina stessa.

\subparagraph*{Conversione dell'indirizzo fisico in indirizzo virtuale}

La \char`\"{}conversione\char`\"{} dell'indirizzo fisico del device in indirizzo virtuale appartenente allo spazio di indirizzamento del processo viene effettuato tramite la chiamata alla funzione mmap(), la quale stabilisce un mapping tra lo spazio di indirizzamento di un processo ed un file, una porzione di memoria condivisa o un qualsiasi altro memory-\/object, restituendo un indirizzo virtuale valido, attraverso il quale e' possibile accedere al blocco di memoria fisico. 
\begin{DoxyCode}
1 #include <sys/mman.h>
2 void *mmap(void *addr, size\_t len, int prot, int flags, int fildes, off\_t off);
\end{DoxyCode}
 Per semplicita' supponiamo che la chiamata alla funzione sia la seguente\+: \begin{center}pa=mmap(addr, len, prot, flags, fildes, off);\end{center}  la semantica dei diversi parametri e'\+:
\begin{DoxyItemize}
\item pa\+: indirizzo virtuale dell'address-\/space locale del processo, a cui viene eseguito il map; se il mapping ha successo viene restituito qualcosa di diverso da M\+A\+P\+\_\+\+F\+A\+I\+L\+E\+D;
\item addr\+:
\item len\+: lunghezza, in byte, del blocco mappato; in questo caso viene usato il valore restituito da sysconf(\+\_\+\+S\+C\+\_\+\+P\+A\+G\+E\+S\+I\+Z\+E);
\item prot\+: specifica i permessi di accesso al blocco di memoria del quale si sta facendo il mapping;
\begin{DoxyItemize}
\item P\+R\+O\+T\+\_\+\+R\+E\+A\+D indica che il blocco puo' essere letto;
\item P\+R\+O\+T\+\_\+\+W\+R\+I\+T\+E indica che il blocco puo' essere scritto;
\item P\+R\+O\+T\+\_\+\+N\+O\+N\+E sta ad indicare che il blocco non puo' essere acceduto;
\end{DoxyItemize}
\item flags\+:fornisce informazioni aggiuntive circa la gestione del blocco di dati di cui si sta facendo il mapping; il valore del flag puo' essere uno dei seguenti\+:
\begin{DoxyItemize}
\item M\+A\+P\+\_\+\+S\+H\+A\+R\+E\+D\+: modifiche al blocco sono condivise con chiunque altri lo stia usando;
\item M\+A\+P\+\_\+\+P\+R\+I\+V\+A\+T\+E\+: le modifiche sono primate;
\end{DoxyItemize}
\end{DoxyItemize}
\begin{DoxyItemize}
\item filedes\+: descrittore del file /dev/mem
\item off\+: indirizzo fisico del blocco che si intente mappare; e' necessario che sia allineato alla dimensione della pagina di memoria, cosi' come restituito dalla funzione sysconf(\+\_\+\+S\+C\+\_\+\+P\+A\+G\+E\+S\+I\+Z\+E);
\end{DoxyItemize}

In questo caso la chiamata a mmap avviene con i seguenti parametri\+: 
\begin{DoxyCode}
1 uint32\_t page\_size = sysconf(\_SC\_PAGESIZE);     // dimensione della pagina
2 uint32\_t page\_mask = ~(page\_size-1);            // maschera di conversione indirizzo -> indirizzo pagina
3 uint32\_t page\_addr = gpio\_addr & page\_mask;     // indirizzo della "pagina fisica" a cui e' mappato il
       device
4 uint32\_t offset = gpio\_addr - page\_addr;        // offset del device rispetto all'indirizzo della pagina
5 void* vrt\_page\_addr = mmap(NULL, page\_size, PROT\_READ | PROT\_WRITE, MAP\_SHARED, descriptor, page\_addr) +
       offset;
\end{DoxyCode}


\subparagraph*{Operazioni sul device}

Una volta effettuato il mapping, le operazioni preventivate con l'invocazione del programma vengono effettuate dalla funzione \hyperlink{group___no_driver_ga879d8b839631449ecb5bc4d0721432b6}{gpio\+\_\+op()}. Si rimanda alla sua documentazione per i dettagli sulle operazioni effettuate().\hypertarget{group___no_driver_ga218f8a9dfc36572bfe2230c5e2d2c776}{\index{No\+Driver@{No\+Driver}!parse\+\_\+args@{parse\+\_\+args}}
\index{parse\+\_\+args@{parse\+\_\+args}!No\+Driver@{No\+Driver}}
\subsubsection[{parse\+\_\+args}]{\setlength{\rightskip}{0pt plus 5cm}int parse\+\_\+args (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$$\ast$}]{argv, }
\item[{uint32\+\_\+t $\ast$}]{gpio\+\_\+address, }
\item[{uint8\+\_\+t $\ast$}]{op\+\_\+mode, }
\item[{uint32\+\_\+t $\ast$}]{mode\+\_\+value, }
\item[{uint8\+\_\+t $\ast$}]{op\+\_\+write, }
\item[{uint32\+\_\+t $\ast$}]{write\+\_\+value, }
\item[{uint8\+\_\+t $\ast$}]{op\+\_\+read}
\end{DoxyParamCaption}
)}}\label{group___no_driver_ga218f8a9dfc36572bfe2230c5e2d2c776}


Effettua il parsing dei parametri passati al programma. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em argc} & \\
\hline
\mbox{\tt in}  & {\em argv} & \\
\hline
\mbox{\tt out}  & {\em gpio\+\_\+address} & conterra' l'indirizzo di memoria del device gpio \\
\hline
\mbox{\tt out}  & {\em op\+\_\+mode} & sara' impostato ad 1 se l'utente intende effettuare scrittuara su mode \\
\hline
\mbox{\tt out}  & {\em mode\+\_\+value} & conterra' il valore che l'utente intende scrivere nel registro mode \\
\hline
\mbox{\tt out}  & {\em op\+\_\+write} & sara' impostato ad 1 se l'utente intende effettuare scrittuara su write \\
\hline
\mbox{\tt out}  & {\em write\+\_\+value} & conterra' il valore che l'utente intende scrivere nel registro write \\
\hline
\mbox{\tt out}  & {\em op\+\_\+read} & sara' impostato ad 1 se l'utente intende effettuare lettura da read\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Valori di ritorno}
{\em 0} & se il parsing ha successo \\
\hline
{\em -\/1} & se si verifica un errore \\
\hline
\end{DoxyRetVals}
\subparagraph*{Parsing dei parametri del programma.}

Il parsing viene effettuato usando la funzione getopt(). 
\begin{DoxyCode}
1 #include <unistd.h>
2 int getopt(int argc, char * const argv[], const char *optstring);
\end{DoxyCode}
 Essa prende in input i parametri argc ed argv passati alla funzione \hyperlink{group___no_driver_ga3c04138a5bfe5d72780bb7e82a18e627}{main()} quando il programma viene invocato. Quando una delle stringhe che compongono argv comincia con il carattere '-\/', getopt() la considera una opzione. Il carattere immediatamente successivo il '-\/' identifica la particolare opzione. La funzione puo' essere chiamata ripetutamente, fino a quando non restituisce -\/1, ad indicare che sono stati analizzati tutti i parametri passati al programma. Quando getopt() trova un'opzione, restituisce quel carattere ed aggiorna la variabile globale optind, che punta al prossimo parametro contenuto in argv. La stringa optstring indica quali sono le opzioni considerate. Se una opzione e' seguita da '\+:' vuol dire che essa e' seguita da un argomento. Tale argomento puo' essere ottenuto mediante la variabile globale optarg.

\subparagraph*{Parametri riconosciuti}

La funzione riconosce i parametri\+:
\begin{DoxyItemize}
\item 'a' \+: seguito dall'indirizzo fisico della periferica con la quale interagire, il quale puo' essere indicato in esadecimale;
\item 'w' \+: operazione di scrittura, seguito dal valore che si intende scrivere, in esadecimale; la scrittura verra' effettuata sul registro W\+R\+I\+T\+E;
\item 'm' \+: impostazione modalita', seguito dalla modalita' col quale impostare il device; la scrittura verra' effettuata sul registro M\+O\+D\+E;
\item 'r' \+: operazione di lettura, primo di argomento; la lettura viene effettuata dal registro R\+E\+A\+D ed e' non bloccante, nel senso che viene semplicemente letto il contenuto del registro.
\end{DoxyItemize}