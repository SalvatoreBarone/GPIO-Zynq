\hypertarget{group___kernel-_module}{\section{Kernel-\/\+Module}
\label{group___kernel-_module}\index{Kernel-\/\+Module@{Kernel-\/\+Module}}
}


Device-\/driver in kernel-\/mode per my\+G\+P\+I\+O.  


Diagramma di collaborazione per Kernel-\/\+Module\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=269pt]{group___kernel-_module}
\end{center}
\end{figure}
\subsection*{Definizioni}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}~\char`\"{}my\+G\+P\+I\+O\+K\char`\"{}
\begin{DoxyCompactList}\small\item\em Nome identificativo del device-\/driver. D\+E\+V\+E corrispondere al valore del campo \char`\"{}compatible\char`\"{} nel device tree source. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Funzioni}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{group___kernel-_module_gae40973a06d72f7c41a9af07513a62307}{my\+G\+P\+I\+O\+K\+\_\+probe} (struct platform\+\_\+device $\ast$op)
\begin{DoxyCompactList}\small\item\em Viene chiamata quando il modulo viene inserito. \end{DoxyCompactList}\item 
static int \hyperlink{group___kernel-_module_ga59fddfaa36dea357f4bbdfceb0f47f8c}{my\+G\+P\+I\+O\+K\+\_\+remove} (struct platform\+\_\+device $\ast$op)
\item 
\hyperlink{group___kernel-_module_ga4982cc224a0881ae5d106fce7526fb68}{M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+L\+E} (of, \hyperlink{group___kernel-_module_ga91f28437e0a553effa546d16fa44f03a}{my\+G\+P\+I\+Ok\+\_\+match})
\item 
\hyperlink{group___kernel-_module_ga61e890be90fe5582db8048893ca0ebbf}{module\+\_\+platform\+\_\+driver} (\hyperlink{group___kernel-_module_ga8dba1541b58fa63f8208232ffce4fc47}{my\+G\+P\+I\+O\+K\+\_\+driver})
\item 
static loff\+\_\+t \hyperlink{group___kernel-_module_gaee309b7824d1efb418d9aa5e8c888c7c}{my\+G\+P\+I\+O\+K\+\_\+seek} (struct file $\ast$file, loff\+\_\+t off, int whence)
\begin{DoxyCompactList}\small\item\em usato per cambiare la posizione della \char`\"{}testina\char`\"{} di lettura/scrittura in un file. \end{DoxyCompactList}\item 
static ssize\+\_\+t \hyperlink{group___kernel-_module_gac03e8e943c9886549d64625253b8c4bf}{my\+G\+P\+I\+O\+K\+\_\+read} (struct file $\ast$file, char $\ast$buf, size\+\_\+t count, loff\+\_\+t $\ast$ppos)
\begin{DoxyCompactList}\small\item\em legge dati dal device. \end{DoxyCompactList}\item 
static ssize\+\_\+t \hyperlink{group___kernel-_module_ga93f7a4111f4555747323e4afcb1343fd}{my\+G\+P\+I\+O\+K\+\_\+write} (struct file $\ast$file, const char $\ast$buf, size\+\_\+t size, loff\+\_\+t $\ast$off)
\begin{DoxyCompactList}\small\item\em Invia dati al device. \end{DoxyCompactList}\item 
static unsigned int \hyperlink{group___kernel-_module_ga27a9fd0cd8497c6fb4415ffcf0733270}{my\+G\+P\+I\+O\+K\+\_\+poll} (struct file $\ast$file, struct poll\+\_\+table\+\_\+struct $\ast$wait)
\begin{DoxyCompactList}\small\item\em Verifica che le operazioni di lettura/scrittura risultino non-\/bloccanti. \end{DoxyCompactList}\item 
static int \hyperlink{group___kernel-_module_ga7aa7d2d19eb7034855c87a17e433918d}{my\+G\+P\+I\+O\+K\+\_\+open} (struct inode $\ast$inode, struct file $\ast$file)
\begin{DoxyCompactList}\small\item\em Invocata all'apertura del file corrispondente al device. \end{DoxyCompactList}\item 
static int \hyperlink{group___kernel-_module_gaf310cbdd4b64b3e108ed0cd67374fa9b}{my\+G\+P\+I\+O\+K\+\_\+release} (struct inode $\ast$inode, struct file $\ast$file)
\begin{DoxyCompactList}\small\item\em Invocata alla chiusura del file corrispondente al device. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variabili}
\begin{DoxyCompactItemize}
\item 
static struct of\+\_\+device\+\_\+id \hyperlink{group___kernel-_module_ga91f28437e0a553effa546d16fa44f03a}{my\+G\+P\+I\+Ok\+\_\+match} \mbox{[}$\,$\mbox{]}
\begin{DoxyCompactList}\small\item\em Identifica il device all'interno del device tree. \end{DoxyCompactList}\item 
static struct platform\+\_\+driver \hyperlink{group___kernel-_module_ga8dba1541b58fa63f8208232ffce4fc47}{my\+G\+P\+I\+O\+K\+\_\+driver}
\begin{DoxyCompactList}\small\item\em Definisce quali funzioni probe() e remove() chiamare quando viene caricato un driver. \end{DoxyCompactList}\item 
static struct file\+\_\+operations \hyperlink{group___kernel-_module_ga9f31111fdb3b4a5944e18d45045e0f01}{my\+G\+P\+I\+O\+\_\+fops}
\begin{DoxyCompactList}\small\item\em definisce la corrispondenza tra funzioni kernel e funzioni driver. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Descrizione dettagliata}
Device-\/driver in kernel-\/mode per my\+G\+P\+I\+O. 

\subsubsection*{Platform-\/device}

I device driver, anche se sono moduli kernel, non si scrivono come normali moduli Kernel.

I \char`\"{}platform-\/device\char`\"{} sono device che non possono annunciarsi al software (non possono dire \char`\"{}\+Hey,
sono qui'!\char`\"{} al sistema operativo), quindi sono intrinsecamente \char`\"{}non-\/scopribili\char`\"{}, nel senso che il sistema, al boot, deve sapere che ci sono, ma non e' in grado di scoprirli. A differenza dei device P\+C\+I o U\+S\+B, che non sono platform-\/device, un device I²\+C non viene enumerato a livello hardware, per cui e' necessario che il sistema operativo sappia, a tempo di \char`\"{}compilazione\char`\"{}, cioe' prima del boot -\/ quale device sia connesso al bus I²\+C.

I non-\/discoverable devices stanno proliferando molto velocemente nel mondo embedded, per cui il Kernel Linux offre ancora la possibilita' di specificare quale hardware sia presente nel sistema. Bisogna distinguere in\+:
\begin{DoxyItemize}
\item Platform Driver
\item Platform Device
\end{DoxyItemize}

Per quanto riguarda la parte driver, il kernel Linux kernel definisce un insieme di operazioni standard che possono essere effettuate su un platform-\/device. Un riferimento pue' essere \href{http://lxr.free-electrons.com/source/include/linux/platform_device.h#L173}{\tt http\+://lxr.\+free-\/electrons.\+com/source/include/linux/platform\+\_\+device.\+h\#\+L173}.

Le callbacks probe() e remove() costituiscono l'insieme minimo di operazioni che devono essere implementate. Tali funzioni devono avere gli stessi parametri delle due seguenti, ma possono avere nome qualsiasi.


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keywordtype}{int} sample\_drv\_probe(\textcolor{keyword}{struct} platform\_device *pdev) \{
        \textcolor{comment}{//Empty Probe function.}
\}

\textcolor{keyword}{static} \textcolor{keywordtype}{int} sample\_drv\_remove(\textcolor{keyword}{struct} platform\_device *pdev) \{
        \textcolor{comment}{//Empty remove function.}
\}
\end{DoxyCode}


La definizione di quali funzioni probe() e remove() chiamare quando viene caricato un driver viene effettuato attraverso la seguente struttura e la chiamata alla macro \hyperlink{group___kernel-_module_ga61e890be90fe5582db8048893ca0ebbf}{module\+\_\+platform\+\_\+driver()}, la quale prende in input la struttura seguente ed implementa, al posto nostro, le funzioni module\+\_\+init() e module\+\_\+close() standard, chiamate quando il modulo viene caricato o rimosso dal kernel.


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keyword}{struct }platform\_driver sample\_pldriver = \{
    .probe  = sample\_drv\_probe,
    .remove = sample\_drv\_remove,
    .driver = \{
        .name  = \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME},
    \},
\};

\hyperlink{group___kernel-_module_ga61e890be90fe5582db8048893ca0ebbf}{module\_platform\_driver}(sample\_pldriver);
\end{DoxyCode}


Si noti D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E\+: deve essere identica alla stringa indicata, nel device-\/tree, al campo \char`\"{}compatible\char`\"{}.

Affinche' il driver possa essere caricato a caldo, e' necessario aggiungere alla struttura di cui sopra qualche informazione in piu'. Tutti i device-\/driver devono esporre un I\+D. A tempo di compilazione, il processo di build estrae queste informazioni dai driver per la preparazione di una tabella. Quando si \char`\"{}inserisce\char`\"{} il device, la tabella viene riferita dal kernel e, se viene trovata una entry corrispondente al driver per quel device, il driver viene caricato ed inizializzato.

Usando la struttura


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keyword}{struct }of\_device\_id device\_match[] = \{
        \{.compatible = \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME}\},
        \{\},
\};

\hyperlink{group___kernel-_module_ga4982cc224a0881ae5d106fce7526fb68}{MODULE\_DEVICE\_TABLE}(of, device\_match);
\end{DoxyCode}


si identifica un particolare device. La macro \hyperlink{group___kernel-_module_ga4982cc224a0881ae5d106fce7526fb68}{M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+L\+E()} viene usata per inserire una nuova entry nella tabella accennata precedentemente. Alla struttura platform\+\_\+driver possono essere aggiunte anche queste informazioni, per cui essa si presentera' come riportato di seguito.


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keyword}{struct }platform\_driver sample\_pldriver = \{
    .probe  = sample\_drv\_probe,
    .remove = sample\_drv\_remove,
    .driver = \{
        .name  = \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME},
        .owner = THIS\_MODULE,
        .of\_match\_table = device\_match,
    \},
\};
\end{DoxyCode}


\subsubsection*{Inizializzazione del driver -\/ probe()}

\paragraph*{Corrispondenza tra funzioni kernel e funzioni driver.}

Essendo un device \char`\"{}visto\char`\"{} come un file, ogni device driver deve implementare tutte le system-\/call previste per l'interfacciamento con un file. La corrispondenza tra la system-\/call e la funzione fornita dal driver viene stabilita attraverso la struttura


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keyword}{struct }file\_operations myGPIO\_fops = \{
    .owner      = THIS\_MODULE,
    .llseek     = driver\_seek,
    .read       = driver\_read,
    .write      = driver\_write,
    .poll       = driver\_poll,
    .open       = driver\_open,
    .release    = driver\_release
\};
\end{DoxyCode}


Ogni campo della struttura deve puntare ad una funzione del driver che implementa uno specifico \char`\"{}operatore\char`\"{} su file, oppure impostata a N\+U\+L\+L se l'operatore non e' supportato. L'esatto comportamento del kernel, quando uno dei puntatori e' N\+U\+L\+L, varia da funzione a funzione. La lista seguente introduce tutti gli operatori che un'applicazione puo' invocare su un device. La lista e' stata mantenuta snella, includendo solo i campi strettamente necessari.


\begin{DoxyItemize}
\item {\itshape struct module $\ast$owner} \+:~\newline
 il primo campo della struttura non e' un operatore, ma un puntatore al modulo che \char`\"{}possiede\char`\"{} la struttura. Il campo ha lo scopo di evitare che il modulo venga rimosso dal kernel quando uno degli operatori e' in uso. Viene inizializzato usando la macro T\+H\+I\+S\+\_\+\+M\+O\+D\+U\+L\+E, definita in $<$linux/module.\+h$>$.
\item {\itshape loff\+\_\+t ($\ast$llseek) (struct file $\ast$, loff\+\_\+t, int)} \+: il campo llseek e' usato per cambiare la posizione della \char`\"{}testina\char`\"{} di lettura/ scrittura in un file. La funzione restituisce la nuova posizione della testina. loff\+\_\+t e' un intero a 64 bit (anche su architetture a 32 bit). Eventuali errori vengono segnalati con un valore di ritorno negativo. Se questo campo e' posto a N\+U\+L\+L, eventuali chiamate a seek modifigheranno la posizione della testina in un modo impredicibile.
\item {\itshape ssize\+\_\+t ($\ast$read) (struct file $\ast$, char \+\_\+ \+\_\+user $\ast$, size\+\_\+t, loff\+\_\+t $\ast$)} \+:~\newline
 usata per leggere dati dal device. Se lasciato a N\+U\+L\+L, ogni chiamata a read fallira' e non sara' possibile leggere dal device. La funzione restituisce il numero di byte letti con successo ma, nel caso si verifichi un errore, restituisce un numero intero negativo.
\item {\itshape ssize\+\_\+t ($\ast$write) (struct file $\ast$, const char \+\_\+ \+\_\+user $\ast$, size\+\_\+t, loff\+\_\+t $\ast$)} \+:~\newline
 invia dati al device. Se N\+U\+L\+L ogni chiamata alla system-\/call write causera' un errore. Il valore di ritorno, se non negativo, rappresenta il numero di byte correttamente scritti.
\item {\itshape unsigned int ($\ast$poll) (struct file $\ast$, struct poll\+\_\+table\+\_\+struct $\ast$)} \+:~\newline
 questo metodo e' il back-\/end di tre diverse system-\/calls\+: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno. La funzione dovrebbe restituire una maschera che indichi se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili. Se viene lasciata N\+U\+L\+L si intende che le operazioni di lettura/scrittura sul device siano sempre non-\/bloccanti.
\item {\itshape int ($\ast$open) (struct inode $\ast$, struct file $\ast$)} \+:~\newline
 Anche se, di solito, e' la prima operazione che si effettua su un file, non e' strettamente necessaria la sua implementazione. Se lasciata N\+U\+L\+L, l'apertura del device andra' comunque a buon fine, ma al driver non verra' inviata alcuna notifica.
\item {\itshape int ($\ast$release) (struct inode $\ast$, struct file $\ast$)} \+:~\newline
 questo operatore viene invocato quando il file viene rilasciato. Come open, puo' essere lasciato N\+U\+L\+L. 
\end{DoxyItemize}

\subsection{Documentazione delle definizioni}
\hypertarget{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E@{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}}
\index{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E@{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E~\char`\"{}my\+G\+P\+I\+O\+K\char`\"{}}}\label{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}


Nome identificativo del device-\/driver. D\+E\+V\+E corrispondere al valore del campo \char`\"{}compatible\char`\"{} nel device tree source. 



\subsection{Documentazione delle funzioni}
\hypertarget{group___kernel-_module_ga4982cc224a0881ae5d106fce7526fb68}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+L\+E@{M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+L\+E}}
\index{M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+L\+E@{M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+L\+E}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+L\+E}]{\setlength{\rightskip}{0pt plus 5cm}M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+L\+E (
\begin{DoxyParamCaption}
\item[{of}]{, }
\item[{{\bf my\+G\+P\+I\+Ok\+\_\+match}}]{}
\end{DoxyParamCaption}
)}}\label{group___kernel-_module_ga4982cc224a0881ae5d106fce7526fb68}
una nuova entry nella tabella delle corrispondenze device -\/ driver. 
\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in,out}  & {\em of} & riferimento alla tabella \\
\hline
\mbox{\tt in}  & {\em my\+G\+P\+I\+Ok\+\_\+match} & struttura of\+\_\+device\+\_\+id \\
\hline
\end{DoxyParams}
\hypertarget{group___kernel-_module_ga61e890be90fe5582db8048893ca0ebbf}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!module\+\_\+platform\+\_\+driver@{module\+\_\+platform\+\_\+driver}}
\index{module\+\_\+platform\+\_\+driver@{module\+\_\+platform\+\_\+driver}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{module\+\_\+platform\+\_\+driver}]{\setlength{\rightskip}{0pt plus 5cm}module\+\_\+platform\+\_\+driver (
\begin{DoxyParamCaption}
\item[{{\bf my\+G\+P\+I\+O\+K\+\_\+driver}}]{}
\end{DoxyParamCaption}
)}}\label{group___kernel-_module_ga61e890be90fe5582db8048893ca0ebbf}
la macro \hyperlink{group___kernel-_module_ga61e890be90fe5582db8048893ca0ebbf}{module\+\_\+platform\+\_\+driver()} prende in input la struttura platform\+\_\+driver ed implementa le funzioni module\+\_\+init() e module\+\_\+close() standard, chiamate quando il modulo viene caricato o rimosso dal kernel.


\begin{DoxyParams}{Parametri}
{\em my\+G\+P\+I\+O\+K\+\_\+driver} & struttura platform\+\_\+driver associata al driver \\
\hline
\end{DoxyParams}
\hypertarget{group___kernel-_module_ga7aa7d2d19eb7034855c87a17e433918d}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+open@{my\+G\+P\+I\+O\+K\+\_\+open}}
\index{my\+G\+P\+I\+O\+K\+\_\+open@{my\+G\+P\+I\+O\+K\+\_\+open}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+open}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+open (
\begin{DoxyParamCaption}
\item[{struct inode $\ast$}]{inode, }
\item[{struct file $\ast$}]{file}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga7aa7d2d19eb7034855c87a17e433918d}


Invocata all'apertura del file corrispondente al device. 


\begin{DoxyParams}{Parametri}
{\em inode} & \\
\hline
{\em file} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}

\end{DoxyReturn}
\hypertarget{group___kernel-_module_ga27a9fd0cd8497c6fb4415ffcf0733270}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+poll@{my\+G\+P\+I\+O\+K\+\_\+poll}}
\index{my\+G\+P\+I\+O\+K\+\_\+poll@{my\+G\+P\+I\+O\+K\+\_\+poll}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+poll}]{\setlength{\rightskip}{0pt plus 5cm}static unsigned int my\+G\+P\+I\+O\+K\+\_\+poll (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file, }
\item[{struct poll\+\_\+table\+\_\+struct $\ast$}]{wait}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga27a9fd0cd8497c6fb4415ffcf0733270}


Verifica che le operazioni di lettura/scrittura risultino non-\/bloccanti. 

Questo metodo e' il back-\/end di tre diverse system-\/calls\+: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno.


\begin{DoxyParams}{Parametri}
{\em file} & \\
\hline
{\em wait} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
restituisce una maschera di bit che indica se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili. 
\end{DoxyReturn}
\hypertarget{group___kernel-_module_gae40973a06d72f7c41a9af07513a62307}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+probe@{my\+G\+P\+I\+O\+K\+\_\+probe}}
\index{my\+G\+P\+I\+O\+K\+\_\+probe@{my\+G\+P\+I\+O\+K\+\_\+probe}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+probe}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+probe (
\begin{DoxyParamCaption}
\item[{struct platform\+\_\+device $\ast$}]{op}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_gae40973a06d72f7c41a9af07513a62307}


Viene chiamata quando il modulo viene inserito. 

Inizializza il driver e la periferica.


\begin{DoxyRetVals}{Valori di ritorno}
{\em 0} & nel caso in cui non si sia verificato nessun errore; \\
\hline
{\em -\/1} & nel caso \\
\hline
\end{DoxyRetVals}
\hypertarget{group___kernel-_module_gac03e8e943c9886549d64625253b8c4bf}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+read@{my\+G\+P\+I\+O\+K\+\_\+read}}
\index{my\+G\+P\+I\+O\+K\+\_\+read@{my\+G\+P\+I\+O\+K\+\_\+read}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+read}]{\setlength{\rightskip}{0pt plus 5cm}static ssize\+\_\+t my\+G\+P\+I\+O\+K\+\_\+read (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file, }
\item[{char $\ast$}]{buf, }
\item[{size\+\_\+t}]{count, }
\item[{loff\+\_\+t $\ast$}]{ppos}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_gac03e8e943c9886549d64625253b8c4bf}


legge dati dal device. 


\begin{DoxyParams}{Parametri}
{\em file} & \\
\hline
{\em buf} & \\
\hline
{\em count} & \\
\hline
{\em ppos} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
La funzione restituisce il numero di byte letti con successo ma, nel caso si verifichi un errore, restituisce un numero intero negativo. 
\end{DoxyReturn}
\hypertarget{group___kernel-_module_gaf310cbdd4b64b3e108ed0cd67374fa9b}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+release@{my\+G\+P\+I\+O\+K\+\_\+release}}
\index{my\+G\+P\+I\+O\+K\+\_\+release@{my\+G\+P\+I\+O\+K\+\_\+release}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+release}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+release (
\begin{DoxyParamCaption}
\item[{struct inode $\ast$}]{inode, }
\item[{struct file $\ast$}]{file}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_gaf310cbdd4b64b3e108ed0cd67374fa9b}


Invocata alla chiusura del file corrispondente al device. 


\begin{DoxyParams}{Parametri}
{\em inode} & \\
\hline
{\em file} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}

\end{DoxyReturn}
\hypertarget{group___kernel-_module_ga59fddfaa36dea357f4bbdfceb0f47f8c}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+remove@{my\+G\+P\+I\+O\+K\+\_\+remove}}
\index{my\+G\+P\+I\+O\+K\+\_\+remove@{my\+G\+P\+I\+O\+K\+\_\+remove}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+remove}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+remove (
\begin{DoxyParamCaption}
\item[{struct platform\+\_\+device $\ast$}]{op}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga59fddfaa36dea357f4bbdfceb0f47f8c}
Viene chiamata automaticamente alla rimozione del mosulo.

Dealloca tutte la memoria utilizzata dal driver. \hypertarget{group___kernel-_module_gaee309b7824d1efb418d9aa5e8c888c7c}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+seek@{my\+G\+P\+I\+O\+K\+\_\+seek}}
\index{my\+G\+P\+I\+O\+K\+\_\+seek@{my\+G\+P\+I\+O\+K\+\_\+seek}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+seek}]{\setlength{\rightskip}{0pt plus 5cm}static loff\+\_\+t my\+G\+P\+I\+O\+K\+\_\+seek (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file, }
\item[{loff\+\_\+t}]{off, }
\item[{int}]{whence}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_gaee309b7824d1efb418d9aa5e8c888c7c}


usato per cambiare la posizione della \char`\"{}testina\char`\"{} di lettura/scrittura in un file. 


\begin{DoxyParams}{Parametri}
{\em file} & \\
\hline
{\em off} & \\
\hline
{\em whence} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
La funzione restituisce la nuova posizione della testina o -\/1 nel caso in cui si verifichi un errore. 
\end{DoxyReturn}
\hypertarget{group___kernel-_module_ga93f7a4111f4555747323e4afcb1343fd}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+write@{my\+G\+P\+I\+O\+K\+\_\+write}}
\index{my\+G\+P\+I\+O\+K\+\_\+write@{my\+G\+P\+I\+O\+K\+\_\+write}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+write}]{\setlength{\rightskip}{0pt plus 5cm}static ssize\+\_\+t my\+G\+P\+I\+O\+K\+\_\+write (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file, }
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{size, }
\item[{loff\+\_\+t $\ast$}]{off}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga93f7a4111f4555747323e4afcb1343fd}


Invia dati al device. 


\begin{DoxyParams}{Parametri}
{\em file} & \\
\hline
{\em buf} & \\
\hline
{\em size} & \\
\hline
{\em off} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
Il valore di ritorno, se non negativo, rappresenta il numero di byte correttamente scritti. 
\end{DoxyReturn}


\subsection{Documentazione delle variabili}
\hypertarget{group___kernel-_module_ga9f31111fdb3b4a5944e18d45045e0f01}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+\_\+fops@{my\+G\+P\+I\+O\+\_\+fops}}
\index{my\+G\+P\+I\+O\+\_\+fops@{my\+G\+P\+I\+O\+\_\+fops}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+\_\+fops}]{\setlength{\rightskip}{0pt plus 5cm}struct file\+\_\+operations my\+G\+P\+I\+O\+\_\+fops\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga9f31111fdb3b4a5944e18d45045e0f01}
{\bfseries Valore iniziale\+:}
\begin{DoxyCode}
= \{
        .owner      = THIS\_MODULE,
        .llseek     = \hyperlink{group___kernel-_module_gaee309b7824d1efb418d9aa5e8c888c7c}{myGPIOK\_seek},
        .read       = \hyperlink{group___kernel-_module_gac03e8e943c9886549d64625253b8c4bf}{myGPIOK\_read},
        .write      = \hyperlink{group___kernel-_module_ga93f7a4111f4555747323e4afcb1343fd}{myGPIOK\_write},
        .poll       = \hyperlink{group___kernel-_module_ga27a9fd0cd8497c6fb4415ffcf0733270}{myGPIOK\_poll},
        .open       = \hyperlink{group___kernel-_module_ga7aa7d2d19eb7034855c87a17e433918d}{myGPIOK\_open},
        .release    = \hyperlink{group___kernel-_module_gaf310cbdd4b64b3e108ed0cd67374fa9b}{myGPIOK\_release}
\}
\end{DoxyCode}


definisce la corrispondenza tra funzioni kernel e funzioni driver. 

Essendo un device \char`\"{}visto\char`\"{} come un file, ogni device driver deve implementare tutte le system-\/call previste per l'interfacciamento con un file. La corrispondenza tra la system-\/call e la funzione fornita dal driver viene stabilita attraverso tale struttura. \hypertarget{group___kernel-_module_ga8dba1541b58fa63f8208232ffce4fc47}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+driver@{my\+G\+P\+I\+O\+K\+\_\+driver}}
\index{my\+G\+P\+I\+O\+K\+\_\+driver@{my\+G\+P\+I\+O\+K\+\_\+driver}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+driver}]{\setlength{\rightskip}{0pt plus 5cm}struct platform\+\_\+driver my\+G\+P\+I\+O\+K\+\_\+driver\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga8dba1541b58fa63f8208232ffce4fc47}
{\bfseries Valore iniziale\+:}
\begin{DoxyCode}
= \{
        .probe = \hyperlink{group___kernel-_module_gae40973a06d72f7c41a9af07513a62307}{myGPIOK\_probe},
        .remove = \hyperlink{group___kernel-_module_ga59fddfaa36dea357f4bbdfceb0f47f8c}{myGPIOK\_remove},
        .driver = \{
                .name = \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME},
                .owner = THIS\_MODULE,
                .of\_match\_table = \hyperlink{group___kernel-_module_ga91f28437e0a553effa546d16fa44f03a}{myGPIOk\_match},
        \},
\}
\end{DoxyCode}


Definisce quali funzioni probe() e remove() chiamare quando viene caricato un driver. 

\hypertarget{group___kernel-_module_ga91f28437e0a553effa546d16fa44f03a}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+Ok\+\_\+match@{my\+G\+P\+I\+Ok\+\_\+match}}
\index{my\+G\+P\+I\+Ok\+\_\+match@{my\+G\+P\+I\+Ok\+\_\+match}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+Ok\+\_\+match}]{\setlength{\rightskip}{0pt plus 5cm}struct of\+\_\+device\+\_\+id my\+G\+P\+I\+Ok\+\_\+match\mbox{[}$\,$\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga91f28437e0a553effa546d16fa44f03a}
{\bfseries Valore iniziale\+:}
\begin{DoxyCode}
= \{
        \{.compatible = \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME}\},
        \{\},
\}
\end{DoxyCode}


Identifica il device all'interno del device tree. 

Tutti i device-\/driver devono esporre un I\+D. A tempo di compilazione, il processo di build estrae queste informazioni dai driver per la preparazione di una tabella. Quando si \char`\"{}inserisce\char`\"{} il device, la tabella viene riferita dal kernel e, se viene trovata una entry corrispondente al driver per quel device, il driver viene caricato ed inizializzato. 