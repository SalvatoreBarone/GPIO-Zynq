\hypertarget{group___kernel-_module}{\section{Kernel-\/\+Module}
\label{group___kernel-_module}\index{Kernel-\/\+Module@{Kernel-\/\+Module}}
}


Device-\/driver in kernel-\/mode per my\+G\+P\+I\+O.  


Diagramma di collaborazione per Kernel-\/\+Module\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=269pt]{group___kernel-_module}
\end{center}
\end{figure}
\subsection*{Strutture dati}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}
\begin{DoxyCompactList}\small\item\em Stuttura per l'astrazione di un device. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Definizioni}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}~\char`\"{}my\+G\+P\+I\+O\+K\char`\"{}
\begin{DoxyCompactList}\small\item\em Nome identificativo del device-\/driver. D\+E\+V\+E corrispondere al valore del campo \char`\"{}compatible\char`\"{} nel device tree source. \end{DoxyCompactList}\item 
\#define \hyperlink{group___kernel-_module_ga605a877d5e63c79a65d4a57d364680b4}{R\+E\+Q\+U\+I\+R\+E\+D\+\_\+\+M\+I\+N\+O\+R\+\_\+\+N\+U\+M\+B\+E\+R}~1
\begin{DoxyCompactList}\small\item\em Numero di minor-\/number richiesti da driver. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Funzioni}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{group___kernel-_module_gae40973a06d72f7c41a9af07513a62307}{my\+G\+P\+I\+O\+K\+\_\+probe} (struct platform\+\_\+device $\ast$op)
\begin{DoxyCompactList}\small\item\em Viene chiamata quando il modulo viene inserito. \end{DoxyCompactList}\item 
static int \hyperlink{group___kernel-_module_ga59fddfaa36dea357f4bbdfceb0f47f8c}{my\+G\+P\+I\+O\+K\+\_\+remove} (struct platform\+\_\+device $\ast$op)
\item 
static int \hyperlink{group___kernel-_module_gad013759c18fbf6ea96005b9b3bfa5b4e}{my\+G\+P\+I\+O\+K\+\_\+open} (struct inode $\ast$inode, struct file $\ast$file\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Invocata all'apertura del file corrispondente al device. \end{DoxyCompactList}\item 
static int \hyperlink{group___kernel-_module_ga17ce7f574723246c790b70b06e3e7103}{my\+G\+P\+I\+O\+K\+\_\+release} (struct inode $\ast$inode, struct file $\ast$file\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Invocata alla chiusura del file corrispondente al device. \end{DoxyCompactList}\item 
static loff\+\_\+t \hyperlink{group___kernel-_module_ga66e7f726b72320a272b633ecbaecefff}{my\+G\+P\+I\+O\+K\+\_\+llseek} (struct file $\ast$file\+\_\+ptr, loff\+\_\+t off, int whence)
\begin{DoxyCompactList}\small\item\em Implementa le system-\/call lseek() e llseek(). \end{DoxyCompactList}\item 
static unsigned int \hyperlink{group___kernel-_module_gaba935e8a8215c2ebce9a7147fd4f5147}{my\+G\+P\+I\+O\+K\+\_\+poll} (struct file $\ast$file\+\_\+ptr, struct poll\+\_\+table\+\_\+struct $\ast$wait)
\begin{DoxyCompactList}\small\item\em Verifica che le operazioni di lettura/scrittura risultino non-\/bloccanti. \end{DoxyCompactList}\item 
static ssize\+\_\+t \hyperlink{group___kernel-_module_ga90ac339df9c02ae5f11a2a7727adc923}{my\+G\+P\+I\+O\+K\+\_\+read} (struct file $\ast$file\+\_\+ptr, char $\ast$buf, size\+\_\+t count, loff\+\_\+t $\ast$off)
\begin{DoxyCompactList}\small\item\em Legge dati dal device. \end{DoxyCompactList}\item 
static ssize\+\_\+t \hyperlink{group___kernel-_module_ga1eea0f6c86e8966ba9b701da57502aad}{my\+G\+P\+I\+O\+K\+\_\+write} (struct file $\ast$file\+\_\+ptr, const char $\ast$buf, size\+\_\+t size, loff\+\_\+t $\ast$off)
\begin{DoxyCompactList}\small\item\em Invia dati al device. \end{DoxyCompactList}\item 
static irqreturn\+\_\+t \hyperlink{group___kernel-_module_ga2fc230a12a97aa63e43b2dc4aec73511}{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler} (int irq, struct pt\+\_\+regs $\ast$regs)
\end{DoxyCompactItemize}
\subsection*{Variabili}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t} $\ast$ \hyperlink{group___kernel-_module_gae370dfc26b06b6cc24a7bcc152f4969e}{my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr} = N\+U\+L\+L
\begin{DoxyCompactList}\small\item\em Puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, contenente tutti i dati necessari al device driver. \end{DoxyCompactList}\item 
static dev\+\_\+t \hyperlink{group___kernel-_module_ga434e034e4625b1949f0c626823870a39}{my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number}
\begin{DoxyCompactList}\small\item\em Major e minor number per il device driver. \end{DoxyCompactList}\item 
static struct class $\ast$ \hyperlink{group___kernel-_module_gaaf8d1bce7d6389684a037e94381c275c}{my\+G\+P\+I\+O\+K\+\_\+class} = N\+U\+L\+L
\item 
static struct device $\ast$ \hyperlink{group___kernel-_module_ga2d345c792760e3103059b6b6e0bfdaee}{my\+G\+P\+I\+O\+K\+\_\+device} = N\+U\+L\+L
\item 
static struct of\+\_\+device\+\_\+id \hyperlink{group___kernel-_module_ga91f28437e0a553effa546d16fa44f03a}{my\+G\+P\+I\+Ok\+\_\+match} \mbox{[}$\,$\mbox{]}
\begin{DoxyCompactList}\small\item\em Identifica il device all'interno del device tree. \end{DoxyCompactList}\item 
static struct platform\+\_\+driver \hyperlink{group___kernel-_module_ga8dba1541b58fa63f8208232ffce4fc47}{my\+G\+P\+I\+O\+K\+\_\+driver}
\begin{DoxyCompactList}\small\item\em Definisce quali funzioni probe() e remove() chiamare quando viene caricato un driver. \end{DoxyCompactList}\item 
static struct file\+\_\+operations \hyperlink{group___kernel-_module_ga9f31111fdb3b4a5944e18d45045e0f01}{my\+G\+P\+I\+O\+\_\+fops}
\begin{DoxyCompactList}\small\item\em mantiene puntatori a funzioni che definiscono il gli operatori che agiscono su un file/device. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Descrizione dettagliata}
Device-\/driver in kernel-\/mode per my\+G\+P\+I\+O. 

\subsubsection*{Platform-\/device}

I device driver, anche se sono moduli kernel, non si scrivono come normali moduli Kernel.

I \char`\"{}platform-\/device\char`\"{} sono device che non possono annunciarsi al software (non possono dire \char`\"{}\+Hey,
sono qui'!\char`\"{} al sistema operativo), quindi sono intrinsecamente \char`\"{}non-\/scopribili\char`\"{}, nel senso che il sistema, al boot, deve sapere che ci sono, ma non e' in grado di scoprirli. A differenza dei device P\+C\+I o U\+S\+B, che non sono platform-\/device, un device I²\+C non viene enumerato a livello hardware, per cui e' necessario che il sistema operativo sappia, a tempo di \char`\"{}compilazione\char`\"{}, cioe' prima del boot -\/ quale device sia connesso al bus I²\+C.

I non-\/discoverable devices stanno proliferando molto velocemente nel mondo embedded, per cui il Kernel Linux offre ancora la possibilita' di specificare quale hardware sia presente nel sistema. Bisogna distinguere in\+:
\begin{DoxyItemize}
\item Platform Driver
\item Platform Device
\end{DoxyItemize}

Per quanto riguarda la parte driver, il kernel Linux kernel definisce un insieme di operazioni standard che possono essere effettuate su un platform-\/device. Un riferimento pue' essere \href{http://lxr.free-electrons.com/source/include/linux/platform_device.h#L173}{\tt http\+://lxr.\+free-\/electrons.\+com/source/include/linux/platform\+\_\+device.\+h\#\+L173}.

Le callbacks probe() e remove() costituiscono l'insieme minimo di operazioni che devono essere implementate. Tali funzioni devono avere gli stessi parametri delle due seguenti, ma possono avere nome qualsiasi.


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keywordtype}{int} sample\_drv\_probe(\textcolor{keyword}{struct} platform\_device *pdev) \{
        \textcolor{comment}{//Empty Probe function.}
\}

\textcolor{keyword}{static} \textcolor{keywordtype}{int} sample\_drv\_remove(\textcolor{keyword}{struct} platform\_device *pdev) \{
        \textcolor{comment}{//Empty remove function.}
\}
\end{DoxyCode}


La definizione di quali funzioni probe() e remove() chiamare quando viene caricato un driver viene effettuato attraverso la seguente struttura e la chiamata alla macro \hyperlink{my_g_p_i_o_k_8c_a61e890be90fe5582db8048893ca0ebbf}{module\+\_\+platform\+\_\+driver()}, la quale prende in input la struttura seguente ed implementa, al posto nostro, le funzioni module\+\_\+init() e module\+\_\+close() standard, chiamate quando il modulo viene caricato o rimosso dal kernel.


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keyword}{struct }platform\_driver sample\_pldriver = \{
    .probe  = sample\_drv\_probe,
    .remove = sample\_drv\_remove,
    .driver = \{
        .name  = \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME},
    \},
\};

\hyperlink{my_g_p_i_o_k_8c_a61e890be90fe5582db8048893ca0ebbf}{module\_platform\_driver}(sample\_pldriver);
\end{DoxyCode}


Si noti D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E\+: deve essere identica alla stringa indicata, nel device-\/tree, al campo \char`\"{}compatible\char`\"{}.

Affinche' il driver possa essere caricato a caldo, e' necessario aggiungere alla struttura di cui sopra qualche informazione in piu'. Tutti i device-\/driver devono esporre un I\+D. A tempo di compilazione, il processo di build estrae queste informazioni dai driver per la preparazione di una tabella. Quando si \char`\"{}inserisce\char`\"{} il device, la tabella viene riferita dal kernel e, se viene trovata una entry corrispondente al driver per quel device, il driver viene caricato ed inizializzato.

Usando la struttura


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keyword}{struct }of\_device\_id device\_match[] = \{
        \{.compatible = \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME}\},
        \{\},
\};

\hyperlink{my_g_p_i_o_k_8c_a4982cc224a0881ae5d106fce7526fb68}{MODULE\_DEVICE\_TABLE}(of, device\_match);
\end{DoxyCode}


si identifica un particolare device. La macro \hyperlink{my_g_p_i_o_k_8c_a4982cc224a0881ae5d106fce7526fb68}{M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+L\+E()} viene usata per inserire una nuova entry nella tabella accennata precedentemente. Alla struttura platform\+\_\+driver possono essere aggiunte anche queste informazioni, per cui essa si presentera' come riportato di seguito.


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keyword}{struct }platform\_driver sample\_pldriver = \{
    .probe  = sample\_drv\_probe,
    .remove = sample\_drv\_remove,
    .driver = \{
        .name  = \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME},
        .owner = THIS\_MODULE,
        .of\_match\_table = device\_match,
    \},
\};
\end{DoxyCode}
 

\subsection{Documentazione delle definizioni}
\hypertarget{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E@{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}}
\index{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E@{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E~\char`\"{}my\+G\+P\+I\+O\+K\char`\"{}}}\label{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}


Nome identificativo del device-\/driver. D\+E\+V\+E corrispondere al valore del campo \char`\"{}compatible\char`\"{} nel device tree source. 

\hypertarget{group___kernel-_module_ga605a877d5e63c79a65d4a57d364680b4}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!R\+E\+Q\+U\+I\+R\+E\+D\+\_\+\+M\+I\+N\+O\+R\+\_\+\+N\+U\+M\+B\+E\+R@{R\+E\+Q\+U\+I\+R\+E\+D\+\_\+\+M\+I\+N\+O\+R\+\_\+\+N\+U\+M\+B\+E\+R}}
\index{R\+E\+Q\+U\+I\+R\+E\+D\+\_\+\+M\+I\+N\+O\+R\+\_\+\+N\+U\+M\+B\+E\+R@{R\+E\+Q\+U\+I\+R\+E\+D\+\_\+\+M\+I\+N\+O\+R\+\_\+\+N\+U\+M\+B\+E\+R}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{R\+E\+Q\+U\+I\+R\+E\+D\+\_\+\+M\+I\+N\+O\+R\+\_\+\+N\+U\+M\+B\+E\+R}]{\setlength{\rightskip}{0pt plus 5cm}\#define R\+E\+Q\+U\+I\+R\+E\+D\+\_\+\+M\+I\+N\+O\+R\+\_\+\+N\+U\+M\+B\+E\+R~1}}\label{group___kernel-_module_ga605a877d5e63c79a65d4a57d364680b4}


Numero di minor-\/number richiesti da driver. 



\subsection{Documentazione delle funzioni}
\hypertarget{group___kernel-_module_ga2fc230a12a97aa63e43b2dc4aec73511}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler@{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler}}
\index{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler@{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler}]{\setlength{\rightskip}{0pt plus 5cm}static irqreturn\+\_\+t my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler (
\begin{DoxyParamCaption}
\item[{int}]{irq, }
\item[{struct pt\+\_\+regs $\ast$}]{regs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga2fc230a12a97aa63e43b2dc4aec73511}

\begin{DoxyParams}{Parametri}
{\em irq} & \\
\hline
{\em regs} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}

\end{DoxyReturn}
\hypertarget{group___kernel-_module_ga66e7f726b72320a272b633ecbaecefff}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+llseek@{my\+G\+P\+I\+O\+K\+\_\+llseek}}
\index{my\+G\+P\+I\+O\+K\+\_\+llseek@{my\+G\+P\+I\+O\+K\+\_\+llseek}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+llseek}]{\setlength{\rightskip}{0pt plus 5cm}static loff\+\_\+t my\+G\+P\+I\+O\+K\+\_\+llseek (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file\+\_\+ptr, }
\item[{loff\+\_\+t}]{off, }
\item[{int}]{whence}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga66e7f726b72320a272b633ecbaecefff}


Implementa le system-\/call lseek() e llseek(). 

\begin{DoxyWarning}{Avvertimento}
L'implementazione di read() e write() non sposta la testina di lettura/scrittura!
\end{DoxyWarning}

\begin{DoxyParams}{Parametri}
{\em file\+\_\+ptr} & \\
\hline
{\em off} & \\
\hline
{\em whence} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}

\end{DoxyReturn}
\hypertarget{group___kernel-_module_gad013759c18fbf6ea96005b9b3bfa5b4e}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+open@{my\+G\+P\+I\+O\+K\+\_\+open}}
\index{my\+G\+P\+I\+O\+K\+\_\+open@{my\+G\+P\+I\+O\+K\+\_\+open}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+open}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+open (
\begin{DoxyParamCaption}
\item[{struct inode $\ast$}]{inode, }
\item[{struct file $\ast$}]{file\+\_\+ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_gad013759c18fbf6ea96005b9b3bfa5b4e}


Invocata all'apertura del file corrispondente al device. 

\paragraph*{Il metodo open()}

Il metodo open di un device driver viene fornito per effettuare ogni inizializzazione necessaria ad operazioni successive. Effettua le seguenti operazioni\+:
\begin{DoxyItemize}
\item verifica che non si siano manifestati errori;
\item inizializza il device
\item aggiorna il puntatore f\+\_\+op, se necessario;
\item alloca e popola ogni struttura dati necessaria, ponendola successivamente nel campo private\+\_\+data della struttura dati file.
\end{DoxyItemize}

In primo luogo e' necessario identificare il device che sta per essere aperto. Tenendo presente che il prototipo di qualunque metodo open e'


\begin{DoxyCode}
1 int (*open)(struct inode *inode, struct file *filp);
\end{DoxyCode}


il parametro inode contiene tutte le informazioni necessarie all'interno del campo i\+\_\+cdev, il quale contiene la struttura cdev inizializzata precedentemente dalla funzione di probe(). Il problema e' che non abbiamo bisogno della sola struttura cdev, ma della struttura che la contiene, in questo caso della struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}. Fortunatamente i programmatori del kernel hanno reso la vita semplice agli altri, predisponendo la macro container\+\_\+if() definita in $<$linux/kernel.\+h$>$.


\begin{DoxyCode}
1 container\_of(pointer, container\_type, container\_field);
\end{DoxyCode}


La macro prende in ingresso un puntatore ad un campo di tipo container\+\_\+field, di una struttura container\+\_\+type, restituendo il puntatore alla struttura che la contiene.


\begin{DoxyParams}{Parametri}
{\em inode} & \\
\hline
{\em file} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}

\end{DoxyReturn}
\hypertarget{group___kernel-_module_gaba935e8a8215c2ebce9a7147fd4f5147}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+poll@{my\+G\+P\+I\+O\+K\+\_\+poll}}
\index{my\+G\+P\+I\+O\+K\+\_\+poll@{my\+G\+P\+I\+O\+K\+\_\+poll}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+poll}]{\setlength{\rightskip}{0pt plus 5cm}static unsigned int my\+G\+P\+I\+O\+K\+\_\+poll (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file\+\_\+ptr, }
\item[{struct poll\+\_\+table\+\_\+struct $\ast$}]{wait}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_gaba935e8a8215c2ebce9a7147fd4f5147}


Verifica che le operazioni di lettura/scrittura risultino non-\/bloccanti. 

Questo metodo e' il back-\/end di tre diverse system-\/calls\+: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno.


\begin{DoxyParams}{Parametri}
{\em file} & \\
\hline
{\em wait} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
restituisce una maschera di bit che indica se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili. 
\end{DoxyReturn}
\hypertarget{group___kernel-_module_gae40973a06d72f7c41a9af07513a62307}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+probe@{my\+G\+P\+I\+O\+K\+\_\+probe}}
\index{my\+G\+P\+I\+O\+K\+\_\+probe@{my\+G\+P\+I\+O\+K\+\_\+probe}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+probe}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+probe (
\begin{DoxyParamCaption}
\item[{struct platform\+\_\+device $\ast$}]{op}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_gae40973a06d72f7c41a9af07513a62307}


Viene chiamata quando il modulo viene inserito. 

Inizializza il driver e la periferica. Alloca un oggetto \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, che astrae un device my\+G\+P\+I\+O, e lo inizializza, associandogli gli operatori che permetteranno di interagire con tale device da user-\/space.

\subparagraph*{Inizializzazione del driver}

Il device G\+P\+I\+O viene gestito come un character-\/device, ossia un device su cui e' possibile leggere e/o scrivere byte. Il kernel usa, internamente, una struttura cdev per rappresentare i device a caratteri. Prima che il kernel invochi le funzioni definite dal driver per il device, bisogna allocare e registrare uno, o piu', oggetti cdev. Per farlo e' necessario includere $<$linux/cdev.\+h$>$, che definisce tale struttura e le relative funzioni.

\subparagraph*{Major-\/number e Minor-\/number}

Ai device drivers sono associati un major-\/number ed un minor-\/number. Il major-\/number viene usato dal kernel per identificare il driver corretto corrispondente ad uno specifico device, quando si effettuano operazioni su di esso. Il ruolo del minor number dipende dal device e viene gestito internamente dal driver. Il driver scritto per G\+P\+I\+O non usera' minor-\/number. La registrazione di un device driver puo' essere effettuata chiamando {\bfseries alloc\+\_\+chrdev\+\_\+region()}, la quale alloca un char-\/device numbers. Il major number viene scelto dinamicamente e restituito dalla funzione attraverso il parametro dev. La funzione restituisce un valore negativo nel caso in cui si verifichino errori, 0 altrimenti. 
\begin{DoxyCode}
1 int alloc\_chrdev\_region (dev\_t * dev, unsigned baseminor, unsigned count, const char *name);
\end{DoxyCode}

\begin{DoxyItemize}
\item dev\+: major e minor number
\item baseminor\+: primo dei minor number richiesti
\item count\+: numero di minornumber richiesti
\item name\+: nome del device driver
\end{DoxyItemize}

\subparagraph*{Device Class}

Ai device-\/drivers viene associata una classe ed un device-\/name. Per creare ed associare una classe ad un device driver si puo' usare la seguente. 
\begin{DoxyCode}
1 struct class * class\_create(struct module * owner, const char * name);
\end{DoxyCode}

\begin{DoxyItemize}
\item owner\+: puntatore al modulo che \char`\"{}possiede\char`\"{} la classe, T\+H\+I\+S\+\_\+\+M\+O\+D\+U\+L\+E
\item name\+: puntatore alla stringa identificativa (il nome) del device driver, D\+R\+I\+V\+E\+R\+\_\+\+N\+A\+M\+E
\end{DoxyItemize}

\subparagraph*{Operatori}

Essendo un device \char`\"{}visto\char`\"{} come un file, ogni device driver deve implementare tutte le system-\/call previste per l'interfacciamento con un file. La corrispondenza tra la system-\/call e la funzione fornita dal driver viene stabilita attraverso la struttura file\+\_\+operations. La struttura dati file\+\_\+operations, definita in $<$linux/fs.\+h$>$ mantiene puntatori a funzioni definite dal driver che consentono di definire il comportamento degli operatori che agiscono su un file.


\begin{DoxyCode}
1 static struct file\_operations myGPIO\_fops = \{
2     .owner      = THIS\_MODULE,
3     .llseek     = driver\_seek,
4     .read       = driver\_read,
5     .write      = driver\_write,
6     .poll       = driver\_poll,
7     .open       = driver\_open,
8     .release    = driver\_release
9 \};
\end{DoxyCode}


Ogni campo della struttura deve puntare ad una funzione del driver che implementa uno specifico \char`\"{}operatore\char`\"{} su file, oppure impostata a N\+U\+L\+L se l'operatore non e' supportato. L'esatto comportamento del kernel, quando uno dei puntatori e' N\+U\+L\+L, varia da funzione a funzione. La lista seguente introduce tutti gli operatori che un'applicazione puo' invocare su un device. La lista e' stata mantenuta snella, includendo solo i campi strettamente necessari.


\begin{DoxyItemize}
\item {\itshape struct module $\ast$owner} \+:~\newline
 il primo campo della struttura non e' un operatore, ma un puntatore al modulo che \char`\"{}possiede\char`\"{} la struttura. Il campo ha lo scopo di evitare che il modulo venga rimosso dal kernel quando uno degli operatori e' in uso. Viene inizializzato usando la macro T\+H\+I\+S\+\_\+\+M\+O\+D\+U\+L\+E, definita in $<$linux/module.\+h$>$.
\item {\itshape loff\+\_\+t ($\ast$llseek) (struct file $\ast$, loff\+\_\+t, int)} \+: il campo llseek e' usato per cambiare la posizione della \char`\"{}testina\char`\"{} di lettura/ scrittura in un file. La funzione restituisce la nuova posizione della testina. loff\+\_\+t e' un intero a 64 bit (anche su architetture a 32 bit). Eventuali errori vengono segnalati con un valore di ritorno negativo. Se questo campo e' posto a N\+U\+L\+L, eventuali chiamate a seek modifigheranno la posizione della testina in un modo impredicibile.
\item {\itshape ssize\+\_\+t ($\ast$read) (struct file $\ast$, char \+\_\+ \+\_\+user $\ast$, size\+\_\+t, loff\+\_\+t $\ast$)} \+:~\newline
 usata per leggere dati dal device. Se lasciato a N\+U\+L\+L, ogni chiamata a read fallira' e non sara' possibile leggere dal device. La funzione restituisce il numero di byte letti con successo ma, nel caso si verifichi un errore, restituisce un numero intero negativo.
\item {\itshape ssize\+\_\+t ($\ast$write) (struct file $\ast$, const char \+\_\+ \+\_\+user $\ast$, size\+\_\+t, loff\+\_\+t $\ast$)} \+:~\newline
 invia dati al device. Se N\+U\+L\+L ogni chiamata alla system-\/call write causera' un errore. Il valore di ritorno, se non negativo, rappresenta il numero di byte correttamente scritti.
\item {\itshape unsigned int ($\ast$poll) (struct file $\ast$, struct poll\+\_\+table\+\_\+struct $\ast$)} \+:~\newline
 questo metodo e' il back-\/end di tre diverse system-\/calls\+: poll, epoll e select, le quali sono usate per capire se una operazione di lettura/scrittura du un device possano risultare bloccanti o meno. La funzione dovrebbe restituire una maschera che indichi se sia possibile effettuare operazioni di lettura/scrittura non bloccanti, in modo che il kernel possa bloccare il processo e risvegliarlo solo quando tali operazioni diventino possibili. Se viene lasciata N\+U\+L\+L si intende che le operazioni di lettura/scrittura sul device siano sempre non-\/bloccanti.
\item {\itshape int ($\ast$open) (struct inode $\ast$, struct file $\ast$)} \+:~\newline
 Anche se, di solito, e' la prima operazione che si effettua su un file, non e' strettamente necessaria la sua implementazione. Se lasciata N\+U\+L\+L, l'apertura del device andra' comunque a buon fine, ma al driver non verra' inviata alcuna notifica.
\item {\itshape int ($\ast$release) (struct inode $\ast$, struct file $\ast$)} \+:~\newline
 questo operatore viene invocato quando il file viene rilasciato. Come open, puo' essere lasciato N\+U\+L\+L.
\end{DoxyItemize}

L'inizializzazione di un device a caratteri passa anche attraverso la definizione di questo tipo di operatori. Essi possono essere impostati attraverso l'uso della funzione 
\begin{DoxyCode}
1 void cdev\_init (struct cdev *cdev, const struct file\_operations *fops);
\end{DoxyCode}
 la quale prende, come parametri
\begin{DoxyItemize}
\item cdev\+: puntatore a struttura cdev da inizializzare;
\item fops\+: puntatore a struttura file\+\_\+operation con cui inizializzare il device.
\end{DoxyItemize}

\subparagraph*{Aggiunta del device}

Il driver, a questo punto, e' pronto per essere aggiunto. E' possibile aggiungere il driver usando 
\begin{DoxyCode}
1 int cdev\_add (struct cdev *p, dev\_t dev, unsigned count);
\end{DoxyCode}
 La quale accetta come parametri
\begin{DoxyItemize}
\item p\+: puntatore a struttura cdev structure per il device
\item dev\+: device number (precedentemente inizializzato usando la funzione {\itshape alloc\+\_\+chrdev\+\_\+region()})
\item count\+: numero di minor-\/numbers richiesti per il device
\end{DoxyItemize}

La funzione restituisce un numero negativo in caso di errore.

Il passo successivo e' la registrazione del device e la sua aggiunta al filesystem. Tale operazione puo' essere effettuata chiamando 
\begin{DoxyCode}
1 struct device * device\_create( struct class *class, struct device *parent, dev\_t devt, const char *fmt,
       ...)
\end{DoxyCode}

\begin{DoxyItemize}
\item class\+: puntatore alla struttura class alla quale il device deve essere registrato
\item parent\+: puntatore ad eventuale device parent
\item devt\+: tmajor number
\item fmt\+: nome del device.
\end{DoxyItemize}

La funzione pu' essere usata solo sulla classe dei device a caratteri. Crea un device all'interno del filesystem, associandogli il major number preventivamente inizializzato. La funzione restituisce il puntatore alla struttura device creata all'interno del filesystem. Si noti che il puntatre alla struttura classes D\+E\+V\+E essere stato precedentemente creato attraverso una chiamata alla funzione {\itshape class\+\_\+create()}.

\subparagraph*{Accedere al segmento di memoria a cui la periferica e' mappata}

Un driver, tipicamente, prende possesso del segmento di memoria cui e' mappato il device con la funzione di probe. Il problema e' che il device e' mappato ad un indirizzo di memoria fisico ed il Kernel, così come qualsiasi altro programma, lavora su indirizzi di memoria virtuali. La funzione


\begin{DoxyCode}
1 int of\_address\_to\_resource(struct device\_node *node, int index, struct resource *r);
\end{DoxyCode}


popola una struttura resource con l'indirizzo di memoria cui e' mapato il device usando le informazioni contenute all'interno del device tree. Ad esempio, se il device tree contiene 
\begin{DoxyCode}
1 reg = <0x41200000 0x10000>;
\end{DoxyCode}
 signidifa che l'indirizzo fisico associato al device e' l'indirizzo 0x41200000, che al device sono riservati 0x10000 bytes. of\+\_\+address\+\_\+to\+\_\+resource() settera' res.\+start = 0x41200000 e res.\+end = 0x4120ffff.

Le regioni di memoria per di I/\+O vanno allocate prima di poter essere usate.


\begin{DoxyCode}
1 struct resource *request\_mem\_region(unsigned long start, unsigned long len, char *name);
\end{DoxyCode}


Questa funzione alloca una regione di memoria di len byte a partire da start restituendone l'indirizzo, mentre nel caso in cui si verifichi un errore viene restituito N\+U\+L\+L. La funzione viene chiamata per ottenere l'accesso esclusivo della regione di memoria, per evitare che driver diversi tentino di accedere allo stesso spazio di memoria.

L'allocazione dello spazio di memoria non e' l'unico step da eseguire prima che tale memoria possa essere usata. E' necessario fare in modo che sia resa accessibile al kernel attraverso un mapping, usando la funzione.


\begin{DoxyCode}
1 void *ioremap(unsigned long phys\_addr, unsigned long size);
\end{DoxyCode}



\begin{DoxyItemize}
\item \subparagraph*{Interrupts}
\end{DoxyItemize}

The L\+K\+M driver must register a handler function for the interrupt, which defines the actions that the interrupt should perform. L'handler deve essere compatibile con il tipo puntatore a funzione irq\+\_\+handler\+\_\+t, così definito. 
\begin{DoxyCode}
1 struct irqreturn\_t (*irq\_handler\_t)(int irq, struct pt\_regs * regs);
\end{DoxyCode}
 Il modulo definisce la funzione \hyperlink{group___kernel-_module_ga2fc230a12a97aa63e43b2dc4aec73511}{my\+G\+P\+I\+O\+K\+\_\+irq\+\_\+handler()}. L'handler puo' essere registrato usando


\begin{DoxyCode}
1 int request\_irq(    unsigned int irqNumber,
2                     irqreturn\_t (*handler)(int, void *, struct pt\_regs *),
3                     unsigned long irqflags,
4                     const char *devname,
5                     void *dev\_id);
\end{DoxyCode}


I\+L parametro irq\+Number puo' essere determinato automaticamente usando la funzione


\begin{DoxyCode}
1 unsigned int irq\_of\_parse\_and\_map(struct device\_node *node, int index);
\end{DoxyCode}


La funzione irq\+\_\+of\+\_\+parse\+\_\+and\+\_\+map() effettua un looks-\/up nella specifica degli interrupt all'interno del device tree e restituisce un irq number cosi' come de lo aspetta request\+\_\+irq() (cioe' compaci con l'enumerazione in /proc/interrupts). Il secondo argomento della funzione e', tipicamente, zero, ad indicare che, all'interno del device tree, verra' preso in considerazione soltanto il primo degli interrupt specificate. Il device tree, nella sezione dedicata al gpio,reca 
\begin{DoxyCode}
1 interrupts = <0 29 4>;
\end{DoxyCode}


Il primo numero (0) e' un flag che indica se l'interrupt sia connesso ad una line S\+P\+I (shared peripheral interrupt). Un valore diverso da zero indica che la linea e' S\+P\+I.

Il secondo numero si riferisce all'interrupt number. Per farla breve, quando si definisce la parte hardware, in questo specifico esempio il device G\+P\+I\+O e' connesso alla linea 61 del G\+I\+C. Sottraendo 32 si orriene 29.

Il terzo numero si riferisce alla tipologia dell'interrupt. Sono possibili tre valori\+:
\begin{DoxyItemize}
\item 0 \+: power-\/up default
\item 1 \+: rising-\/edge
\item 4 \+: a livelli, active alto
\end{DoxyItemize}


\begin{DoxyRetVals}{Valori di ritorno}
{\em 0} & nel caso in cui non si sia verificato nessun errore; \\
\hline
{\em -\/\+E\+N\+O\+M\+E\+M} & nel caso in cui non sia possibile allocare memoria; \\
\hline
{\em $<$0} & per altri errori \\
\hline
\end{DoxyRetVals}
\hypertarget{group___kernel-_module_ga90ac339df9c02ae5f11a2a7727adc923}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+read@{my\+G\+P\+I\+O\+K\+\_\+read}}
\index{my\+G\+P\+I\+O\+K\+\_\+read@{my\+G\+P\+I\+O\+K\+\_\+read}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+read}]{\setlength{\rightskip}{0pt plus 5cm}static ssize\+\_\+t my\+G\+P\+I\+O\+K\+\_\+read (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file\+\_\+ptr, }
\item[{char $\ast$}]{buf, }
\item[{size\+\_\+t}]{count, }
\item[{loff\+\_\+t $\ast$}]{off}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga90ac339df9c02ae5f11a2a7727adc923}


Legge dati dal device. 

\paragraph*{Operazioni di lettura e scrittura}

I metodi read() e write() effettuano operazioni simili, ossia copiare dati da/verso il device. Il loro prototipo e' molto simile.


\begin{DoxyCode}
1 ssize\_t read(struct file *filp, char \_\_user *buff, size\_t count, loff\_t *offp);
2 
3 ssize\_t write(struct file *filp, const char \_\_user *buff, size\_t count, loff\_t *offp);
\end{DoxyCode}


Per entrambi i metodifilep e' il puntatore al file che rapresenta il device, count e' la dimensione dei dati da trasferire, buff e' il puntatore al buffer contenente i dati (da scrivere per la write() o letti per la read()). Infine offp e' il puntatore ad un oggetto \char`\"{}long offset type\char`\"{} che indica la posizione alla quale si sta effettuando l'accesso.

Buff e' un puntatore appartenente allo spazio di indirizzamento del programma user-\/space che utilizza il modulo kernel. Il modulo, quindi, non puo' accedere direttamente ad esso, dereferenziandolo, per diverse ragioni, tra le quali\+:
\begin{DoxyItemize}
\item a seconda dell'architettura sulla quale il driver e' in esecuzione e di come il kernel e' stato configurato, il puntatore userspace potrebbe non essere valido mentre il modulo kernel viene eseguito;
\item la memoria user-\/space e' paginata e potrebbe non essere presente in R\+A\+M quando la system-\/call viene effettuata, per cui dereferenziando il puntatore potrebbe originarsi un page-\/fault con conseguente terminazione del processo che ha effettuato la system-\/call;
\item il puntatore in questione potrebbe essere stato fornito da un programma user-\/space buggato o malizioso, motivo per cui dereferenziandolo verrebbe a crearsi un punto di accesso attraverso il quale il programma userspace puo' modificare la memoria senza costrizioni.
\end{DoxyItemize}

Ovviamente il driver deve essere in grado di poter accedere al buffer userspace, per cui tale accesso va fatto solo ed esclusivamente attraverso delle funzioni fornite dal kernel stesso, e definite in $<$asm/uaccess.\+h$>$


\begin{DoxyCode}
1 unsigned long copy\_to\_user(void \_\_user *to, const void *from, unsigned long count);
2 
3 unsigned long copy\_from\_user(void *to, const void \_\_user *from, unsigned long count);
\end{DoxyCode}


Queste due funzioni non si limitano a copiare dati da/verso userspacem\+: verificano, infatti, anche che il puntatore al buffer userspace sia valido. Se il puntatore non risultasse valido la copia non viene effettuata.

Sia il metodo read() che il metodo write() restituiscono un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte trasferiti con successo.

\subparagraph*{Accesso ai registri del device}

Si potrebbe senrire la tentazione di usare il puntatore restituito da ioremap() dereferenziandolo per accedere alla memoria. Questo modo di procedere non e' portabile ed e' prono ad errori. Il modo corretto di accedere alla memoria e' attraverso l'uso delle funzioni per il memory-\/mapped I/\+O, definite in $<$asm/io.\+h$>$.

Per leggere dalla memoria vengono usate le seguenti\+:


\begin{DoxyCode}
1 unsigned int ioread8(void *addr);
2 unsigned int ioread16(void *addr);
3 unsigned int ioread32(void *addr);
\end{DoxyCode}


addr e' l'indirizzo di memoria virtuale del device, ottenuto mediante chiamata a ioremap(), a cui viene, eventualmente, aggiunto un offset. Il valore restituito dalle funzioni e' quello letto dalla particolare locazione di memoria a cui viene effettuato accesso.


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em file} & \\
\hline
\mbox{\tt out}  & {\em buf} & \\
\hline
\mbox{\tt in}  & {\em count} & \\
\hline
\mbox{\tt in}  & {\em ppos} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
restituisce un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte scritti con successo. 
\end{DoxyReturn}
\hypertarget{group___kernel-_module_ga17ce7f574723246c790b70b06e3e7103}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+release@{my\+G\+P\+I\+O\+K\+\_\+release}}
\index{my\+G\+P\+I\+O\+K\+\_\+release@{my\+G\+P\+I\+O\+K\+\_\+release}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+release}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+release (
\begin{DoxyParamCaption}
\item[{struct inode $\ast$}]{inode, }
\item[{struct file $\ast$}]{file\+\_\+ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga17ce7f574723246c790b70b06e3e7103}


Invocata alla chiusura del file corrispondente al device. 


\begin{DoxyParams}{Parametri}
{\em inode} & \\
\hline
{\em file} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}

\end{DoxyReturn}
\hypertarget{group___kernel-_module_ga59fddfaa36dea357f4bbdfceb0f47f8c}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+remove@{my\+G\+P\+I\+O\+K\+\_\+remove}}
\index{my\+G\+P\+I\+O\+K\+\_\+remove@{my\+G\+P\+I\+O\+K\+\_\+remove}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+remove}]{\setlength{\rightskip}{0pt plus 5cm}static int my\+G\+P\+I\+O\+K\+\_\+remove (
\begin{DoxyParamCaption}
\item[{struct platform\+\_\+device $\ast$}]{op}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga59fddfaa36dea357f4bbdfceb0f47f8c}
Viene chiamata automaticamente alla rimozione del mosulo.

Dealloca tutta la memoria utilizzata dal driver, de-\/inizializzando il device. \hypertarget{group___kernel-_module_ga1eea0f6c86e8966ba9b701da57502aad}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+write@{my\+G\+P\+I\+O\+K\+\_\+write}}
\index{my\+G\+P\+I\+O\+K\+\_\+write@{my\+G\+P\+I\+O\+K\+\_\+write}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+write}]{\setlength{\rightskip}{0pt plus 5cm}static ssize\+\_\+t my\+G\+P\+I\+O\+K\+\_\+write (
\begin{DoxyParamCaption}
\item[{struct file $\ast$}]{file\+\_\+ptr, }
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{size, }
\item[{loff\+\_\+t $\ast$}]{off}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga1eea0f6c86e8966ba9b701da57502aad}


Invia dati al device. 

\paragraph*{Operazioni di lettura e scrittura}

I metodi read() e write() effettuano operazioni simili, ossia copiare dati da/verso il device. Il loro prototipo e' molto simile.


\begin{DoxyCode}
1 ssize\_t read(struct file *filp, char \_\_user *buff, size\_t count, loff\_t *offp);
2 
3 ssize\_t write(struct file *filp, const char \_\_user *buff, size\_t count, loff\_t *offp);
\end{DoxyCode}


Per entrambi i metodifilep e' il puntatore al file che rapresenta il device, count e' la dimensione dei dati da trasferire, buff e' il puntatore al buffer contenente i dati (da scrivere per la write() o letti per la read()). Infine offp e' il puntatore ad un oggetto \char`\"{}long offset type\char`\"{} che indica la posizione alla quale si sta effettuando l'accesso.

Buff e' un puntatore appartenente allo spazio di indirizzamento del programma user-\/space che utilizza il modulo kernel. Il modulo, quindi, non puo' accedere direttamente ad esso, dereferenziandolo, per diverse ragioni, tra le quali\+:
\begin{DoxyItemize}
\item a seconda dell'architettura sulla quale il driver e' in esecuzione e di come il kernel e' stato configurato, il puntatore userspace potrebbe non essere valido mentre il modulo kernel viene eseguito;
\item la memoria user-\/space e' paginata e potrebbe non essere presente in R\+A\+M quando la system-\/call viene effettuata, per cui dereferenziando il puntatore potrebbe originarsi un page-\/fault con conseguente terminazione del processo che ha effettuato la system-\/call;
\item il puntatore in questione potrebbe essere stato fornito da un programma user-\/space buggato o malizioso, motivo per cui dereferenziandolo verrebbe a crearsi un punto di accesso attraverso il quale il programma userspace puo' modificare la memoria senza costrizioni.
\end{DoxyItemize}

Ovviamente il driver deve essere in grado di poter accedere al buffer userspace, per cui tale accesso va fatto solo ed esclusivamente attraverso delle funzioni fornite dal kernel stesso, e definite in $<$asm/uaccess.\+h$>$


\begin{DoxyCode}
1 unsigned long copy\_to\_user(void \_\_user *to, const void *from, unsigned long count);
2 
3 unsigned long copy\_from\_user(void *to, const void \_\_user *from, unsigned long count);
\end{DoxyCode}


Queste due funzioni non si limitano a copiare dati da/verso userspacem\+: verificano, infatti, anche che il puntatore al buffer userspace sia valido. Se il puntatore non risultasse valido la copia non viene effettuata.

Sia il metodo read() che il metodo write() restituiscono un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte trasferiti con successo.

\subparagraph*{Accesso ai registri del device}

Si potrebbe senrire la tentazione di usare il puntatore restituito da ioremap() dereferenziandolo per accedere alla memoria. Questo modo di procedere non e' portabile ed e' prono ad errori. Il modo corretto di accedere alla memoria e' attraverso l'uso delle funzioni per il memory-\/mapped I/\+O, definite in $<$asm/io.\+h$>$.

Per scrivere nella memoria vengono usate le seguenti\+:


\begin{DoxyCode}
1 void iowrite8(u8 value, void *addr);
2 void iowrite16(u16 value, void *addr);
3 void iowrite32(u32 value, void *addr);
\end{DoxyCode}


addr e' l'indirizzo di memoria virtuale del device, ottenuto mediante chiamata a ioremap(), a cui viene, eventualmente, aggiunto un offset. value e' il valore che verra' scritto alla particolare locazione di memoria a cui viene effettuato accesso.


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em file} & \\
\hline
\mbox{\tt in}  & {\em buf} & \\
\hline
\mbox{\tt in}  & {\em size} & \\
\hline
\mbox{\tt in}  & {\em off} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Restituisce}
restituisce un valore negativo nel caso in cui si sia verificato un errore. Un valore maggiore o uguale a zero indica il numero di byte scritti con successo. 
\end{DoxyReturn}


\subsection{Documentazione delle variabili}
\hypertarget{group___kernel-_module_ga9f31111fdb3b4a5944e18d45045e0f01}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+\_\+fops@{my\+G\+P\+I\+O\+\_\+fops}}
\index{my\+G\+P\+I\+O\+\_\+fops@{my\+G\+P\+I\+O\+\_\+fops}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+\_\+fops}]{\setlength{\rightskip}{0pt plus 5cm}struct file\+\_\+operations my\+G\+P\+I\+O\+\_\+fops\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga9f31111fdb3b4a5944e18d45045e0f01}
{\bfseries Valore iniziale\+:}
\begin{DoxyCode}
= \{
        .owner      = THIS\_MODULE,
        .llseek     = \hyperlink{group___kernel-_module_ga66e7f726b72320a272b633ecbaecefff}{myGPIOK\_llseek},
        .read       = \hyperlink{group___kernel-_module_ga90ac339df9c02ae5f11a2a7727adc923}{myGPIOK\_read},
        .write      = \hyperlink{group___kernel-_module_ga1eea0f6c86e8966ba9b701da57502aad}{myGPIOK\_write},
        .poll       = \hyperlink{group___kernel-_module_gaba935e8a8215c2ebce9a7147fd4f5147}{myGPIOK\_poll},
        .open       = \hyperlink{group___kernel-_module_gad013759c18fbf6ea96005b9b3bfa5b4e}{myGPIOK\_open},
        .release    = \hyperlink{group___kernel-_module_ga17ce7f574723246c790b70b06e3e7103}{myGPIOK\_release}
\}
\end{DoxyCode}


mantiene puntatori a funzioni che definiscono il gli operatori che agiscono su un file/device. 

Essendo un device \char`\"{}visto\char`\"{} come un file, ogni device driver deve implementare tutte le system-\/call previste per l'interfacciamento con un file. La corrispondenza tra la system-\/call e la funzione fornita dal driver viene stabilita attraverso tale struttura. La struttura dati file\+\_\+operations, definita in $<$linux/fs.\+h$>$ mantiene puntatori a funzioni definite dal driver che consentono di definire il comportamento degli operatori che agiscono su un file. \hypertarget{group___kernel-_module_gaaf8d1bce7d6389684a037e94381c275c}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+class@{my\+G\+P\+I\+O\+K\+\_\+class}}
\index{my\+G\+P\+I\+O\+K\+\_\+class@{my\+G\+P\+I\+O\+K\+\_\+class}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+class}]{\setlength{\rightskip}{0pt plus 5cm}struct class$\ast$ my\+G\+P\+I\+O\+K\+\_\+class = N\+U\+L\+L\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_gaaf8d1bce7d6389684a037e94381c275c}
\hypertarget{group___kernel-_module_gae370dfc26b06b6cc24a7bcc152f4969e}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr@{my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr}}
\index{my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr@{my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf my\+G\+P\+I\+O\+K\+\_\+t}$\ast$ my\+G\+P\+I\+O\+K\+\_\+dev\+\_\+ptr = N\+U\+L\+L}}\label{group___kernel-_module_gae370dfc26b06b6cc24a7bcc152f4969e}


Puntatore a struttura \hyperlink{structmy_g_p_i_o_k__t}{my\+G\+P\+I\+O\+K\+\_\+t}, contenente tutti i dati necessari al device driver. 

\hypertarget{group___kernel-_module_ga2d345c792760e3103059b6b6e0bfdaee}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+device@{my\+G\+P\+I\+O\+K\+\_\+device}}
\index{my\+G\+P\+I\+O\+K\+\_\+device@{my\+G\+P\+I\+O\+K\+\_\+device}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+device}]{\setlength{\rightskip}{0pt plus 5cm}struct device$\ast$ my\+G\+P\+I\+O\+K\+\_\+device = N\+U\+L\+L\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga2d345c792760e3103059b6b6e0bfdaee}
\hypertarget{group___kernel-_module_ga8dba1541b58fa63f8208232ffce4fc47}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+driver@{my\+G\+P\+I\+O\+K\+\_\+driver}}
\index{my\+G\+P\+I\+O\+K\+\_\+driver@{my\+G\+P\+I\+O\+K\+\_\+driver}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+driver}]{\setlength{\rightskip}{0pt plus 5cm}struct platform\+\_\+driver my\+G\+P\+I\+O\+K\+\_\+driver\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga8dba1541b58fa63f8208232ffce4fc47}
{\bfseries Valore iniziale\+:}
\begin{DoxyCode}
= \{
        .probe = \hyperlink{group___kernel-_module_gae40973a06d72f7c41a9af07513a62307}{myGPIOK\_probe},
        .remove = \hyperlink{group___kernel-_module_ga59fddfaa36dea357f4bbdfceb0f47f8c}{myGPIOK\_remove},
        .driver = \{
                .name = \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME},
                .owner = THIS\_MODULE,
                .of\_match\_table = \hyperlink{group___kernel-_module_ga91f28437e0a553effa546d16fa44f03a}{myGPIOk\_match},
        \},
\}
\end{DoxyCode}


Definisce quali funzioni probe() e remove() chiamare quando viene caricato un driver. 

\hypertarget{group___kernel-_module_ga91f28437e0a553effa546d16fa44f03a}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+Ok\+\_\+match@{my\+G\+P\+I\+Ok\+\_\+match}}
\index{my\+G\+P\+I\+Ok\+\_\+match@{my\+G\+P\+I\+Ok\+\_\+match}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+Ok\+\_\+match}]{\setlength{\rightskip}{0pt plus 5cm}struct of\+\_\+device\+\_\+id my\+G\+P\+I\+Ok\+\_\+match\mbox{[}$\,$\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga91f28437e0a553effa546d16fa44f03a}
{\bfseries Valore iniziale\+:}
\begin{DoxyCode}
= \{
        \{.compatible = \hyperlink{group___kernel-_module_ga25634d21648ca7fb7a2aca614bafaaeb}{DRIVER\_NAME}\},
        \{\},
\}
\end{DoxyCode}


Identifica il device all'interno del device tree. 

Tutti i device-\/driver devono esporre un I\+D. A tempo di compilazione, il processo di build estrae queste informazioni dai driver per la preparazione di una tabella. Quando si \char`\"{}inserisce\char`\"{} il device, la tabella viene riferita dal kernel e, se viene trovata una entry corrispondente al driver per quel device, il driver viene caricato ed inizializzato. \hypertarget{group___kernel-_module_ga434e034e4625b1949f0c626823870a39}{\index{Kernel-\/\+Module@{Kernel-\/\+Module}!my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number@{my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number}}
\index{my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number@{my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number}!Kernel-\/\+Module@{Kernel-\/\+Module}}
\subsubsection[{my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number}]{\setlength{\rightskip}{0pt plus 5cm}dev\+\_\+t my\+G\+P\+I\+O\+K\+\_\+\+Mm\+\_\+number\hspace{0.3cm}{\ttfamily [static]}}}\label{group___kernel-_module_ga434e034e4625b1949f0c626823870a39}


Major e minor number per il device driver. 

