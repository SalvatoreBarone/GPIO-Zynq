\hypertarget{group___u_i_o-simple}{\section{U\+I\+O-\/simple}
\label{group___u_i_o-simple}\index{U\+I\+O-\/simple@{U\+I\+O-\/simple}}
}


Questo e' un programma di esempio per l'interfacciamento con una periferica my\+G\+P\+I\+O.  


Diagramma di collaborazione per U\+I\+O-\/simple\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=217pt]{group___u_i_o-simple}
\end{center}
\end{figure}
\subsection*{Funzioni}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group___u_i_o-simple_ga05909651fa170a63e98e3f8e13451b7b}{howto} (void)
\begin{DoxyCompactList}\small\item\em Stampa un messaggio che fornisce indicazioni sull'utilizzo del programma. \end{DoxyCompactList}\item 
int \hyperlink{group___u_i_o-simple_gab6b18eb1bf7bc996599c06dc6dad8f53}{parse\+\_\+args} (int argc, char $\ast$$\ast$argv, char $\ast$$\ast$uio, uint8\+\_\+t $\ast$op\+\_\+mode, uint32\+\_\+t $\ast$mode\+\_\+value, uint8\+\_\+t $\ast$op\+\_\+write, uint32\+\_\+t $\ast$write\+\_\+value, uint8\+\_\+t $\ast$op\+\_\+read)
\begin{DoxyCompactList}\small\item\em Effettua il parsing dei parametri passati al programma. \end{DoxyCompactList}\item 
void \hyperlink{group___u_i_o-simple_ga879d8b839631449ecb5bc4d0721432b6}{gpio\+\_\+op} (void $\ast$vrt\+\_\+gpio\+\_\+addr, uint8\+\_\+t op\+\_\+mode, uint32\+\_\+t mode\+\_\+value, uint8\+\_\+t op\+\_\+write, uint32\+\_\+t write\+\_\+value, uint8\+\_\+t op\+\_\+read)
\begin{DoxyCompactList}\small\item\em Effettua operazioni su un device. \end{DoxyCompactList}\item 
int \hyperlink{group___u_i_o-simple_ga3c04138a5bfe5d72780bb7e82a18e627}{main} (int argc, char $\ast$$\ast$argv)
\begin{DoxyCompactList}\small\item\em funzione \hyperlink{group___u_i_o-simple_ga3c04138a5bfe5d72780bb7e82a18e627}{main()}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Descrizione dettagliata}
Questo e' un programma di esempio per l'interfacciamento con una periferica my\+G\+P\+I\+O. 

In questo specifico esempio l'interfacciamento avviene da user-\/space, interagendo attraverso il driver uio.

E' possibile accedere ad ognuno dei device attraverso un file diverso. Tale file sara' /dev/uio0 per il primo device, /dev/uio1 per il secondo, /dev/uio2 per il terzo e cosi' via. Tale file puo' essere usato per accedere allo spazio degli indirizzi del device usando mmap().

In questo caso, rispetto al caso No\+Driver, accedere al device e' estremamente piu' semplice. Se il device e' compatibile con il driver U\+I\+O, e' possibile \char`\"{}aprire\char`\"{} un file in /dev/uio\+X, effettuare il mapping connettendo l'indirizzo fisico del device allo spazio di indirizzamento del processo, senza la necessita' di conoscere l'indirizzo della periferica col quale di intende comunicare. Ad ogni periferica compatibile con U\+I\+O e' associato un file diverso in /dev/uio\+X attraverso il quale e' possibile raggiungere il device. 

\subsection{Documentazione delle funzioni}
\hypertarget{group___u_i_o-simple_ga879d8b839631449ecb5bc4d0721432b6}{\index{U\+I\+O-\/simple@{U\+I\+O-\/simple}!gpio\+\_\+op@{gpio\+\_\+op}}
\index{gpio\+\_\+op@{gpio\+\_\+op}!U\+I\+O-\/simple@{U\+I\+O-\/simple}}
\subsubsection[{gpio\+\_\+op}]{\setlength{\rightskip}{0pt plus 5cm}void gpio\+\_\+op (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{vrt\+\_\+gpio\+\_\+addr, }
\item[{uint8\+\_\+t}]{op\+\_\+mode, }
\item[{uint32\+\_\+t}]{mode\+\_\+value, }
\item[{uint8\+\_\+t}]{op\+\_\+write, }
\item[{uint32\+\_\+t}]{write\+\_\+value, }
\item[{uint8\+\_\+t}]{op\+\_\+read}
\end{DoxyParamCaption}
)}}\label{group___u_i_o-simple_ga879d8b839631449ecb5bc4d0721432b6}


Effettua operazioni su un device. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em vrt\+\_\+gpio\+\_\+addr} & indirizzo di memoria del device gpio \\
\hline
\mbox{\tt in}  & {\em op\+\_\+mode} & sara' impostato ad 1 se l'utente intende effettuare scrittuara su mode \\
\hline
\mbox{\tt in}  & {\em mode\+\_\+value} & conterra' il valore che l'utente intende scrivere nel registro mode \\
\hline
\mbox{\tt in}  & {\em op\+\_\+write} & sara' impostato ad 1 se l'utente intende effettuare scrittuara su write \\
\hline
\mbox{\tt in}  & {\em write\+\_\+value} & conterra' il valore che l'utente intende scrivere nel registro write \\
\hline
\mbox{\tt in}  & {\em op\+\_\+read} & sara' impostato ad 1 se l'utente intende effettuare lettura da read\\
\hline
\end{DoxyParams}
La funzione viene invocata dopo che sia stato eseguito il parsing dei parametri passati al programma quando esso viene invocato. E' stata scritta per funzionare sia con il G\+P\+I\+O Xilinx che con il G\+P\+I\+O custom my\+G\+P\+I\+O. E' possibile utilizzare il primo definendo la macro {\bfseries X\+I\+L\+\_\+\+G\+P\+I\+O}. Effettua, sul device, le operazioni impostate, in accordo con i parametri passati al programma alla sua invocazione. \subparagraph*{Impostazione della modalita' di funzionamento}

Nel caso in cui si stia operando su un device G\+P\+I\+O Xilinx, le operazioni di impostazione della modalita' di funzionamento del G\+P\+I\+O vengono effettuate scrivendo direttamente sul registro M\+O\+D\+E del device. In caso contrario si e' preferito utilizzare la funzioni \hyperlink{group__my_g_p_i_o_ga38a2ea04d07af50f7f570f0367594c8b}{my\+G\+P\+I\+O\+\_\+set\+Mode()} (Si veda il modulo my\+G\+P\+I\+O). Funzionalmente non c'e' differenza.

\subparagraph*{Operazione di scrittura}

Nel caso in cui si stia operando su un device G\+P\+I\+O Xilinx, le operazioni di scrittura del valore dei pin del device G\+P\+I\+O vengono effettuate scrivendo direttamente sul registro W\+R\+I\+T\+E del device. In caso contrario si e' preferito utilizzare la funzioni \hyperlink{group__my_g_p_i_o_gab742e68093ad4c90fe299b64fd6736ca}{my\+G\+P\+I\+O\+\_\+set\+Value()} (Si veda il modulo my\+G\+P\+I\+O). Funzionalmente non c'e' differenza.

\subparagraph*{Operazione di lettura}

Nel caso in cui si stia operando su un device G\+P\+I\+O Xilinx, le operazioni di lettura del valore dei pin del device G\+P\+I\+O vengono effettuate leggendo direttamente dal registro R\+E\+A\+D del device. In caso contrario si e' preferito utilizzare la funzioni \hyperlink{group__my_g_p_i_o_gadb3ecd03ea82420488977134c9313e18}{my\+G\+P\+I\+O\+\_\+get\+Read()} (Si veda il modulo my\+G\+P\+I\+O). Funzionalmente non c'e' differenza. La lettura e' non bloccante\+: viene semplicemente letto il valore contenuto nel registro. U\+I\+O permette l'implementazione di meccanismi di lettura basati su interruzione, ma in questo caso, per semplicita', tale meccanismo e' stato omesso. Si veda il modulo U\+I\+O-\/interrupt.\hypertarget{group___u_i_o-simple_ga05909651fa170a63e98e3f8e13451b7b}{\index{U\+I\+O-\/simple@{U\+I\+O-\/simple}!howto@{howto}}
\index{howto@{howto}!U\+I\+O-\/simple@{U\+I\+O-\/simple}}
\subsubsection[{howto}]{\setlength{\rightskip}{0pt plus 5cm}void howto (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{group___u_i_o-simple_ga05909651fa170a63e98e3f8e13451b7b}


Stampa un messaggio che fornisce indicazioni sull'utilizzo del programma. 

\hypertarget{group___u_i_o-simple_ga3c04138a5bfe5d72780bb7e82a18e627}{\index{U\+I\+O-\/simple@{U\+I\+O-\/simple}!main@{main}}
\index{main@{main}!U\+I\+O-\/simple@{U\+I\+O-\/simple}}
\subsubsection[{main}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$$\ast$}]{argv}
\end{DoxyParamCaption}
)}}\label{group___u_i_o-simple_ga3c04138a5bfe5d72780bb7e82a18e627}


funzione \hyperlink{group___u_i_o-simple_ga3c04138a5bfe5d72780bb7e82a18e627}{main()}. 

\subparagraph*{Parsing dei parametri di invocazione}

Il parsing dei parametri passati al programma all'atto della sua invocazione viene effettuato dalla funzione \hyperlink{group___u_i_o-simple_gab6b18eb1bf7bc996599c06dc6dad8f53}{parse\+\_\+args()}. Si rimanda alla sua documentazione per i dettagli sui parametri riconosciuti.

Se non viene specificato il device U\+I\+O col quale interagire e' impossibile continuare. Per questo motivo, in questo caso, il programma viene terminato.

\subparagraph*{Accesso ad un device /dev/uio\+X}

Il driver generic-\/\+U\+I\+O e' il driver generico per eccellenza. Ad ogni periferica compatibile con U\+I\+O e' associato un file diverso in /dev/uio\+X attraverso il quale e' possibile raggiungere il device. Tale file sara' /dev/uio0 per il primo device, /dev/uio1 per il secondo, /dev/uio2 per il terzo e cosi' via. on for subsequent devices. Tale file puo' essere usato per accedere allo spazio degli indirizzi del device usando mmap().

In questo caso, rispetto all'esempio no\+Driver, accedere al device e' estremamente piu' semplice. Se il device e' compatibile con il driver U\+I\+O, e' possibile \char`\"{}aprire\char`\"{} un file in /dev/uio\+X, effettuare il mapping, connettendo il device allo spazio di indirizzamento del processo, senza la necessita' di conoscere l'indirizzo fisico della periferica col quale di intende comunicare.

L'accesso al device /dev/uio\+X viene ottenuto mediante la system-\/call open()\+: 
\begin{DoxyCode}
1 #include <sys/stat.h>
2 #include <fcntl.h>
3 int open(const char *path, int oflag, ...  );
\end{DoxyCode}
 la quale restituisce il descrittore del file /dev/uio\+X, usato nel seguito per effettuare le operazioni di I/\+O. I valori del parametro oflag specificano il modo in cui il file /dev/uio\+X viene aperto. In questo caso viene usato O\+\_\+\+R\+D\+W\+R, il quale garantisce accesso in lettura ed in scrittura. Altri valori sono O\+\_\+\+R\+D\+O\+N\+L\+Y, il quale garantisce accesso in sola lettura, ed O\+\_\+\+W\+R\+O\+N\+L\+Y, che, invece, garantisce accesso in sola scrittura.

\subparagraph*{Mapping un device /dev/uio\+X}

La \char`\"{}conversione\char`\"{} dell'indirizzo fisico del device in indirizzo virtuale appartenente allo spazio di indirizzamento del processo viene effettuato tramite la chiamata alla funzione mmap(), la quale stabilisce un mapping tra lo spazio di indirizzamento di un processo ed un file, una porzione di memoria condivisa o un qualsiasi altro memory-\/object, restituendo un indirizzo virtuale valido, attraverso il quale e' possibile accedere al blocco di memoria fisico. 
\begin{DoxyCode}
1 #include <sys/mman.h>
2 void *mmap(void *addr, size\_t len, int prot, int flags, int fildes, off\_t off);
\end{DoxyCode}
 Per semplicita' supponiamo che la chiamata alla funzione sia la seguente\+: \begin{center}pa=mmap(addr, len, prot, flags, fildes, off);\end{center}  la semantica dei diversi parametri e'\+:
\begin{DoxyItemize}
\item pa\+: indirizzo virtuale dell'address-\/space locale del processo, a cui viene eseguito il map; se il mapping ha successo viene restituito qualcosa di diverso da M\+A\+P\+\_\+\+F\+A\+I\+L\+E\+D;
\item addr\+:
\item len\+: lunghezza, in byte, del blocco mappato; in questo caso viene usato il valore restituito da sysconf(\+\_\+\+S\+C\+\_\+\+P\+A\+G\+E\+S\+I\+Z\+E);
\item prot\+: specifica i permessi di accesso al blocco di memoria del quale si sta facendo il mapping;
\begin{DoxyItemize}
\item P\+R\+O\+T\+\_\+\+R\+E\+A\+D indica che il blocco puo' essere letto;
\item P\+R\+O\+T\+\_\+\+W\+R\+I\+T\+E indica che il blocco puo' essere scritto;
\item P\+R\+O\+T\+\_\+\+N\+O\+N\+E sta ad indicare che il blocco non puo' essere acceduto;
\end{DoxyItemize}
\item flags\+:fornisce informazioni aggiuntive circa la gestione del blocco di dati di cui si sta facendo il mapping; il valore del flag puo' essere uno dei seguenti\+:
\begin{DoxyItemize}
\item M\+A\+P\+\_\+\+S\+H\+A\+R\+E\+D\+: modifiche al blocco sono condivise con chiunque altri lo stia usando;
\item M\+A\+P\+\_\+\+P\+R\+I\+V\+A\+T\+E\+: le modifiche sono primate;
\end{DoxyItemize}
\end{DoxyItemize}
\begin{DoxyItemize}
\item filedes\+: descrittore del file /dev/mem
\item off\+: indirizzo fisico del blocco che si intente mappare; e' necessario che sia allineato alla dimensione della pagina di memoria, cosi' come restituito dalla funzione sysconf(\+\_\+\+S\+C\+\_\+\+P\+A\+G\+E\+S\+I\+Z\+E);
\end{DoxyItemize}

In questo caso la chiamata a mmap avviene con i seguenti parametri\+: 
\begin{DoxyCode}
1 uint32\_t page\_size = sysconf(\_SC\_PAGESIZE);     // dimensione della pagina
2 void* vrt\_gpio\_addr = mmap(NULL, page\_size, PROT\_READ | PROT\_WRITE, MAP\_SHARED, descriptor, 0);
\end{DoxyCode}


Rispetto al \char`\"{}driver\char`\"{} nodriver, la chiamata differisce per un solo perticolare\+: essendo descriptor il descrittore di uio\+X, e l'offset specificato nullo, la funzione restituisce direttamente l'indirizzo virtuale del device nello spazio di indirizzamento del processo.

\subparagraph*{Operazioni sul device}

Una volta effettuato il mapping, le operazioni preventivate con l'invocazione del programma vengono effettuate dalla funzione \hyperlink{group___u_i_o-simple_ga879d8b839631449ecb5bc4d0721432b6}{gpio\+\_\+op()}. Si rimanda alla sua documentazione per i dettagli sulle operazioni effettuate().\hypertarget{group___u_i_o-simple_gab6b18eb1bf7bc996599c06dc6dad8f53}{\index{U\+I\+O-\/simple@{U\+I\+O-\/simple}!parse\+\_\+args@{parse\+\_\+args}}
\index{parse\+\_\+args@{parse\+\_\+args}!U\+I\+O-\/simple@{U\+I\+O-\/simple}}
\subsubsection[{parse\+\_\+args}]{\setlength{\rightskip}{0pt plus 5cm}int parse\+\_\+args (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$$\ast$}]{argv, }
\item[{char $\ast$$\ast$}]{uio, }
\item[{uint8\+\_\+t $\ast$}]{op\+\_\+mode, }
\item[{uint32\+\_\+t $\ast$}]{mode\+\_\+value, }
\item[{uint8\+\_\+t $\ast$}]{op\+\_\+write, }
\item[{uint32\+\_\+t $\ast$}]{write\+\_\+value, }
\item[{uint8\+\_\+t $\ast$}]{op\+\_\+read}
\end{DoxyParamCaption}
)}}\label{group___u_i_o-simple_gab6b18eb1bf7bc996599c06dc6dad8f53}


Effettua il parsing dei parametri passati al programma. 


\begin{DoxyParams}[1]{Parametri}
\mbox{\tt in}  & {\em argc} & \\
\hline
\mbox{\tt in}  & {\em argv} & \\
\hline
\mbox{\tt out}  & {\em uio\+\_\+file} & file uio da usare \\
\hline
\mbox{\tt out}  & {\em op\+\_\+mode} & sara' impostato ad 1 se l'utente intende effettuare scrittuara su mode \\
\hline
\mbox{\tt out}  & {\em mode\+\_\+value} & conterra' il valore che l'utente intende scrivere nel registro mode \\
\hline
\mbox{\tt out}  & {\em op\+\_\+write} & sara' impostato ad 1 se l'utente intende effettuare scrittuara su write \\
\hline
\mbox{\tt out}  & {\em write\+\_\+value} & conterra' il valore che l'utente intende scrivere nel registro write \\
\hline
\mbox{\tt out}  & {\em op\+\_\+read} & sara' impostato ad 1 se l'utente intende effettuare lettura da read\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Valori di ritorno}
{\em 0} & se il parsing ha successo \\
\hline
{\em -\/1} & se si verifica un errore \\
\hline
\end{DoxyRetVals}
\subparagraph*{Parsing dei parametri del programma.}

Il parsing viene effettuato usando la funzione getopt(). 
\begin{DoxyCode}
1 #include <unistd.h>
2 int getopt(int argc, char * const argv[], const char *optstring);
\end{DoxyCode}
 Essa prende in input i parametri argc ed argv passati alla funzione \hyperlink{group___u_i_o-simple_ga3c04138a5bfe5d72780bb7e82a18e627}{main()} quando il programma viene invocato. Quando una delle stringhe che compongono argv comincia con il carattere '-\/', getopt() la considera una opzione. Il carattere immediatamente successivo il '-\/' identifica la particolare opzione. La funzione puo' essere chiamata ripetutamente, fino a quando non restituisce -\/1, ad indicare che sono stati analizzati tutti i parametri passati al programma. Quando getopt() trova un'opzione, restituisce quel carattere ed aggiorna la variabile globale optind, che punta al prossimo parametro contenuto in argv. La stringa optstring indica quali sono le opzioni considerate. Se una opzione e' seguita da '\+:' vuol dire che essa e' seguita da un argomento. Tale argomento puo' essere ottenuto mediante la variabile globale optarg.

\subparagraph*{Parametri riconosciuti}

La funzione riconosce i parametri\+:
\begin{DoxyItemize}
\item 'd' \+: seguito dal percordo del device /dev/uio\+X col quale interagire
\item 'w' \+: operazione di scrittura, seguito dal valore che si intende scrivere, in esadecimale; la scrittura verra' effettuata sul registro W\+R\+I\+T\+E;
\item 'm' \+: impostazione modalita', seguito dalla modalita' col quale impostare il device; la scrittura verra' effettuata sul registro M\+O\+D\+E;
\item 'r' \+: operazione di lettura, primo di argomento; la lettura viene effettuata dal registro R\+E\+A\+D ed e' non bloccante, nel senso che viene semplicemente letto il contenuto del registro.
\end{DoxyItemize}